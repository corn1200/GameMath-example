# 게임 수학 정리 문서
게임 개발에 필요한 수학 개념에 대해 정리한 문서입니다.

# 목차
* [1. 수와 집합](README-ORIGIN.md/#1-수와-집합)
    * [1.1. 연산과 수의 구조](README-ORIGIN.md/#11-연산과-수의-구조)
    * [1.2. 수의 구조](README-ORIGIN.md/#12-수의-구조)
    * [1.3. 수의 표현](README-ORIGIN.md/#13-수의-표현)
* [2. 함수](README-ORIGIN.md/#2-함수)
    * [2.1. 함수의 개념과 종류](README-ORIGIN.md/#21-함수의-개념과-종류)
    * [2.2. 합성함수](README-ORIGIN.md/#22-합성함수)
    * [2.3. 항등함수와 역함수](README-ORIGIN.md/#23-항등함수와-역함수)
    * [2.4. 곱집합을 활용한 좌표 평면으로의 확장](README-ORIGIN.md/#24-곱집합을-활용한-좌표-평면으로의-확장)
* [3. 데카르트 좌표계](README-ORIGIN.md/#3-데카르트-좌표계)
* [4. 벡터 공간과 벡터](README-ORIGIN.md/#4-벡터-공간과-벡터)
    * [4.1. 스칼라와 벡터](README-ORIGIN.md/#41-스칼라와-벡터)
    * [4.2. 벡터 공간의 연산](README-ORIGIN.md/#42-벡터-공간의-연산)
    * [4.3. 벡터의 크기와 이동](README-ORIGIN.md/#43-벡터의-크기와-이동)
* [5. 벡터의 결합과 생성](README-ORIGIN.md/#5-벡터의-결합과-생성)
* [6. 삼각함수](README-ORIGIN.md/#6-삼각함수)
    * [6.1. 삼각함수의 성질](README-ORIGIN.md/#61-삼각함수의-성질)
    * [6.2. 각의 측정법](README-ORIGIN.md/#62-각의-측정법)
* [7. 삼각함수를 활용한 물체의 회전](README-ORIGIN.md/#7-삼각함수를-활용한-물체의-회전)
* [8. 삼각함수의 역함수](README-ORIGIN.md/#8-삼각함수의-역함수)
* [9. 극좌표계](README-ORIGIN.md/#9-극좌표계)
* [10. 선형성: 예측 가능한 비례 관계](README-ORIGIN.md/#10-선형성-예측-가능한-비례-관계)
    * [10.1. 선형 함수](README-ORIGIN.md/#101-선형-함수)
    * [10.2. 벡터 공간의 선형 변환](README-ORIGIN.md/#102-벡터-공간의-선형-변환)
* [11. 행렬](README-ORIGIN.md/#11-행렬)
    * [11.1. 행렬의 기본 연산](README-ORIGIN.md/#111-행렬의-기본-연산)
    * [11.2. 행렬의 곱셈](README-ORIGIN.md/#112-행렬의-곱셈)
    * [11.3. 정방행렬의 곱셈](README-ORIGIN.md/#113-정방행렬의-곱셈)
* [12. 행렬의 설계](README-ORIGIN.md/#12-행렬의-설계)
    * [12.1. 크기 변환행렬](README-ORIGIN.md/#121-크기-변환행렬)
    * [12.2. 회전 변환행렬](README-ORIGIN.md/#122-회전-변환행렬)
    * [12.3. 전단 변환행렬](README-ORIGIN.md/#123-전단-변환행렬)
    * [12.4. 삼각함수의 덧셈 정리](README-ORIGIN.md/#124-삼각함수의-덧셈-정리)
* [13. 역행렬](README-ORIGIN.md/#13-역행렬)
    * [13.1. 역행렬의 존재를 판별하는 행렬식](README-ORIGIN.md/#131-역행렬의-존재를-판별하는-행렬식)
    * [13.2. 크기 변환행렬의 역행렬](README-ORIGIN.md/#132-크기-변환행렬의-역행렬)
    * [13.3. 전단 변환행렬의 역행렬](README-ORIGIN.md/#133-전단-변환행렬의-역행렬)
    * [13.4. 회전 변환행렬의 역행렬](README-ORIGIN.md/#134-회전-변환행렬의-역행렬)
    * [13.5. 행렬 곱의 역행렬](README-ORIGIN.md/#135-행렬-곱의-역행렬)
* [14. 이동 변환을 위한 아핀 공간](README-ORIGIN.md/#14-이동-변환을-위한-아핀-공간)
* [15. 아핀 공간의 구성 요소](README-ORIGIN.md/#15-아핀-공간의-구성-요소)
    * [15.1. 점](README-ORIGIN.md/#151-점)
    * [15.2. 이동 벡터](README-ORIGIN.md/#152-이동-벡터)
    * [15.3. 아핀 공간의 성질](README-ORIGIN.md/#153-아핀-공간의-성질)
* [16. 아핀 결합](README-ORIGIN.md/#16-아핀-결합)
    * [16.1. 두 점의 결합](README-ORIGIN.md/#161-두-점의-결합)
* [17. 벡터의 내적](README-ORIGIN.md/#17-벡터의-내적)
    * [17.1. 내적의 성질](README-ORIGIN.md/#171-내적의-성질)
    * [17.2. 내적과 삼각함수의 관계](README-ORIGIN.md/#172-내적과-삼각함수의-관계)
    * [17.3. 행렬의 곱셈을 내적으로 표현하기](README-ORIGIN.md/#173-행렬의-곱셈을-내적으로-표현하기)
* [18. 시야 판별](README-ORIGIN.md/#18-시야-판별)
    * [18.1. 앞뒤 판별](README-ORIGIN.md/#181-앞뒤-판별)
    * [18.2. 시야 판별](README-ORIGIN.md/#182-시야-판별)
* [19. 조명 효과의 구현](README-ORIGIN.md/#19-조명-효과의-구현)
* [20. 투영 벡터](#20-투영-벡터)
* [21. 세 점의 결합](#21-세-점의-결합)
* [22. 메시](#22-메시)
* [23. 무게중심좌표](#23-무게중심좌표)
    * [23.1. 무게중심좌표의 계산](#231-무게중심좌표의-계산)
* [24. 텍스처 매핑](#24-텍스처-매핑)
* [25. 3차원 공간의 설계](#25-3차원-공간의-설계)
* [26. 3차원 공간의 트랜스폼](#26-3차원-공간의-트랜스폼)
    * [26.1. 오일러 각](#261오일러-각)
    * [26.2. 회전행렬의 유도](#262-회전행렬의-유도)
    * [26.3. 3차원 모델링 행렬](#263-3차원-모델링-행렬)
* [27. 카메라 공간](#27-카메라-공간)
* [28. 오일러 각의 특징](#28-오일러-각의-특징)
    * [28.1 짐벌락 현상](#281-짐벌락-현상)
    * [28.2 회전 보간의 계산](#282-회전-보간의-계산)
* [29. 벡터의 외적](#29-벡터의-외적)
    * [29.1. 평행성 판별](#291-평행성-판별)
    * [29.2. 법선 벡터](#292-법선-벡터)
    * [29.3. 좌우 방향 판별](#293-좌우-방향-판별)
* [30. 벡터로부터 회전행렬 생성](#30-벡터로부터-회전행렬-생성)
* [31. 렌더링 계산량을 줄여주는 백페이스 컬링](#31-렌더링-계산량을-줄여주는-백페이스-컬링)
* [32. 오일러 각의 문제를 해결하는 로드리게스 회전 공식](#32-오일러-각의-문제를-해결하는-로드리게스-회전-공식)
* [33. 삼중곱](#33-삼중곱)
    * [33.1. 스칼라 삼중곱](#331-스칼라-삼중곱)
    * [33.2. 벡터 삼중곱](#332-벡터-삼중곱)
* [34. 원근 투영 변환의 원리](#34-원근-투영-변환의-원리)
* [35. 동차 좌표계](#35-동차-좌표계)
* [36. 깊이 값](#36-깊이-값)
* [37. 원근 보정 매핑](#37-원근-보정-매핑)
* [38. 깊이 버퍼](#38-깊이-버퍼)
* [39. 절두체 컬링](README-ORIGIN3.md/#39-절두체-컬링)
    * [39.1. 평면의 방정식](README-ORIGIN3.md/#391-평면의-방정식)
    * [39.2. 평면의 방정식의 정규화](README-ORIGIN3.md/#392-평면의-방정식의-정규화)
    * [39.3. 평면의 방정식을 활용한 절두체 표현](README-ORIGIN3.md/#393-평면의-방정식을-활용한-절두체-표현)
    * [39.4. 원근 투영 행렬로부터 평면의 방정식 만들기](README-ORIGIN3.md/#394-원근-투영-행렬로부터-평면의-방정식-만들기)
* [40. 바운딩 볼륨](README-ORIGIN3.md/#40-바운딩-볼륨)
    * [40.1. 구 바운딩 볼륨의 판정](README-ORIGIN3.md/#401-구-바운딩-볼륨의-판정)
    * [40.2. aabb와의 판정](README-ORIGIN3.md/#402-aabb와의-판정)
* [41. 삼각형 클리핑](README-ORIGIN3.md/#41-삼각형-클리핑)
* [42. 복소수](README-ORIGIN3.md/#42-복소수)
    * [42.1. 허수](README-ORIGIN3.md/#421-허수)
    * [42.2. 복소수의 구조](README-ORIGIN3.md/#422-복소수의-구조)
* [43. 복소평면](README-ORIGIN3.md/#43-복소평면)
    * [43.1. 단위 복소수와의 곱](README-ORIGIN3.md/#431-단위-복소수와의-곱)
    * [43.2. 켤레 복소수의 회전 변환](README-ORIGIN3.md/#432-켤레-복소수의-회전-변환)
* [44. 복소수와 행렬의 관계](README-ORIGIN3.md/#44-복소수와-행렬의-관계)
* [45. 자연지수함수](README-ORIGIN3.md/#45-자연지수함수)
    * [45.1. 무리수 e](README-ORIGIN3.md/#451-무리수-e)
    * [45.2. 자연지수함수](README-ORIGIN3.md/#452-자연지수함수)
* [46. 미분](README-ORIGIN3.md/#46-미분)
    * [46.1. 도함수](README-ORIGIN3.md/#461-도함수)
    * [46.2. 자연지수함수의 도함수)](README-ORIGIN3.md/#462-자연지수함수의-도함수)
    * [46.3. sin 함수와 cos 함수의 도함수)](README-ORIGIN3.md/#463-sin-함수와-cos-함수의-도함수)
* [47. 급수](README-ORIGIN3.md/#47-급수)
    * [47.1. 등비수열](README-ORIGIN3.md/#471-등비수열)
    * [47.2. 급수](README-ORIGIN3.md/#472-급수)
    * [47.3. 매클로린 급수](README-ORIGIN3.md/#473-매클로린-급수)
* [48. 오일러 공식](README-ORIGIN3.md/#48-오일러-공식)
* [49. 사원수 대수](README-ORIGIN3.md/#49-사원수-대수)
    * [49.1. 사원수를 구성하는 세 허수](README-ORIGIN3.md/#491-사원수를-구성하는-세-허수)
    * [49.2. 사원수의 구조](README-ORIGIN3.md/#492-사원수의-구조)
    * [49.3. 사원수와 벡터](README-ORIGIN3.md/#493-사원수와-벡터)
* [50. 사원수의 회전](README-ORIGIN3.md/#50-사원수의-회전)
    * [50.1. 사원수와 오일러 공식](README-ORIGIN3.md/#501-사원수와-오일러-공식)
    * [50.2. 회전 사원수를 이용한 3차원 공간에서의 회전](README-ORIGIN3.md/#502-회전-사원수를-이용한-3차원-공간에서의-회전)
* [51. 사원수의 변환](README-ORIGIN3.md/#51-사원수의-변환)
    * [51.1. 오일러 각에서 사원수로의 변환](README-ORIGIN3.md/#511-오일러-각에서-사원수로의-변환)
    * [51.2. 사원수에서 오일러 각으로의 변환](README-ORIGIN3.md/#512-사원수에서-오일러-각으로의-변환)
    * [51.3. 사원수에서 회전 변환행렬로의 변환](README-ORIGIN3.md/#513-사원수에서-회전-변환행렬로의-변환)
    * [51.4. 회전 변환행렬에서 사원수로의 변환](README-ORIGIN3.md/#514-회전-변환행렬에서-사원수로의-변환)
* [52. 사원수의 보간](README-ORIGIN3.md/#52-사원수의-보간)

# 20. 투영 벡터
***벡터 내적은 어떤 벡터를 다른 벡터에 직교 투영하는 용도로 사용된다***.  
예를 들어 [그림 6-13](#그림-6-13-카메라-공간의-분석-예시)과 같이 카메라가 만드는 공간을 분석할 때 ***카메라와 물체 사이의 거리*** 외에도 ***카메라에서 물체까지의 깊이*** 값이 필요한 경우도 있다.  
이 경우 내적을 활용한 투영 벡터를 구하는 공식이 활용된다.

###### 그림 6-13 카메라 공간의 분석 예시
![카메라 공간의 분석 예시](/img/)

[그림 6-14](#그림-6-14-벡터-투영-과정의-시각화)와 같이 임의의 두 벡터 $\vec{u}$와 $\vec{v}$가 주어졌을 때 벡터 $\vec{u}$를 벡터 $\vec{v}$에 투영하는 상황을 생각해보자.     
투영한 벡터를 $\vec{v'}$로 표기했는데, 투영한 벡터는 대상 벡터 $\vec{v}$와 방향이 같기 때문이다.

###### 그림 6-14 벡터 투영 과정의 시각화
![벡터 투영 과정의 시각화](/img/)

따라서 투영한 벡터 $\vec{v'}$의 크기를 알고 있다면 [그림 6-15](#그림-6-15-투영-벡터식-유도에-사용되는-단위-벡터)에서 보듯이 $\vec{v}$를 정규화시킨 단위 벡터 $\hat{v}$를 구하고 그 크기를 곱하면 투영된 벡터를 얻을 수 있다.

###### 그림 6-15 투영 벡터식 유도에 사용되는 단위 벡터
![투영 벡터식 유도에 사용되는 단위 벡터](/img/)

이를 수식으로 표현하면 다음과 같다.

$$\vec{v'} = |\vec{v'}| \cdot \hat{v}$$

내적을 활용해 $\vec{u}$로부터 $\vec{v'}$를 구하도록 수식을 전개한다.

$$
\begin{matrix}
\vec{v'} &=& |\vec{v'}| \cdot \hat{v} \\
&=& |\vec{v'}| \cdot \frac{\vec{v}}{|\vec{v}|} \\
&=& |\vec{u}| \cdot \cos \theta \cdot \frac{\vec{v}}{|\vec{v}|} \\
&=& |\vec{u}| \cdot \frac{\vec{u} \cdot \vec{v}}{|\vec{u}||\vec{v}|} \cdot \frac{\vec{v}}{|\vec{v}|} \\
&=& \frac{(\vec{u} \cdot \vec{v})}{|\vec{v}|^2} \cdot \vec{v} \\
&=& \frac{(\vec{u} \cdot \vec{v})}{(\vec{v} \cdot \vec{v})} \cdot \vec{v} \\
\end{matrix}
$$

1. 단위 벡터 $\hat{v}$를 구하기 위해 벡터 $\vec{v}$를 정규화한다.
2. $\vec{v'}$의 크기는 벡터 $\vec{u}$의 크기에 $\cos \theta$를 곱해 얻을 수 있다.
3. $\cos \theta$는 내적 공식 $\vec{u} \cdot \vec{v} = |\vec{u}||\vec{v}| \cos \theta$로부터 얻을 수 있다.
4. 분자와 분모를 소거하고 정리한다.
5. 벡터의 크기의 제곱을 내적으로 변경한다.

위 식에서 투영할 벡터 $\vec{v}$의 크기가 1이면 위 식은 다음과 같이 단순하게 정리된다.

$$\vec{v'} = (\vec{u} \cdot \vec{v}) \cdot \vec{v}$$

# 21. 세 점의 결합
아핀 결합식에 사용하는 스칼라(계수) 값의 범위에 따라 직선, 반직선, 선분 등 다양한 종류의 선을 만들 수 있다.     
세 점 $P_1, P_2, P_3$를 결합하는 경우 스칼라는 2개에서 3개로 늘어나는데 세 스칼라의 합은 1이 되어야 하므로 아핀 결합 식은 다음과 같이 전개된다.

###### 식 7-1

$$P' = s \cdot P_1 + t \cdot P_2 + (1 - s - t) \cdot P_3$$

[식 7-1](#식-7-1)을 점에서 점을 빼는 수식으로 바꿔 전개하면 다음과 같다.

###### 식 7-2

$$(P' - P_3) = s(P_1 - P_3) + t(P_2 - P_3)$$

[식 7-2](#식-7-2)의 각 괄호를 $\vec{u}, \vec{v}, \vec{w}$의 벡터로 치환하면 다음과 같이 벡터로 구성된 수식이 만들어진다.

###### 식 7-3

$$\vec{w} = s \cdot \vec{u} + t \cdot \vec{v}$$

벡터 $\vec{u}$와 $\vec{v}$가 서로 선형 독립의 관계라면 벡터 $\vec{w}$는 2차원 벡터 공간 $R^2$에 존재하는 모든 벡터를 생성할 수 있다.    
따라서 ***세 점의 아핀 결합은 평면의 모든 점을 만들어낸다***.

###### 그림 7-1 선형 독립의 관계를 가지는 두 벡터의 결합으로 만들어내는 평면의 점
![선형 독립의 관계를 가지는 두 벡터의 결합으로 만들어내는 평면의 점](/img/)

선분이 만들어지는 조건과 동일하게 $s$와 $t$의 값을 $|0, 1|$ 범위로 고정시키면 어떤 모습이 될지 확인해보자.  
[그림 7-2](#그림-7-2-세-점의-아핀-결합에서-범위를-제한한-경우)와 같이 스칼라 $s$와 $t$의 값을 몇 가지 지정해보면 해당 영역은 삼각형이 됨을 알 수 있다.

###### 그림 7-2 세 점의 아핀 결합에서 범위를 제한한 경우
![세 점의 아핀 결합에서 범위를 제한한 경우](/img/)

아핀 결합식에서 스칼라 값을 $|0, 1|$ 범위로 제한하면 시작과 끝의 범위가 명확해지므로 선분과 동일하게 그릴 수 있는 도형이 만들어진다.    
이렇게 아핀 결합에서 모든 스칼라 값을 $|0, 1|$ 범위로 한정한 결합을 ***컨벡스 결합(Convex combination)*** 이라고 부른다.   
컨벡스 결합은 [식 5-2](#식-5-2)의 아핀 결합식에 각 스칼라의 범위를 $|0, 1|$로 제한하는 조건을 추가해 다음과 같이 표현할 수 있다.

###### 식 7-4

$$\sum_{i=0}^n c_i \cdot P_i (s.t. \sum_{i=0}^n c_i = 1, 0 \leq c_i \leq 1)$$

선분이나 삼각형처럼 컨벡스 결합으로 만든 영역을 ***컨벡스 영역(Convex region)*** 이라고 한다.  
컨벡스 영역이란 ***'볼록한 형태의 영역'*** 이라 해석할 수 있다.    
수학에서 정의한 ***'볼록함'*** 이란, ***영역 내 임의의 두 점을 연결한 선분을 만들었을 때 그 선분은 언제나 해당 컨벡스 영역 안에 속하는 성질***을 의미한다.   
예를 들어 [그림 7-3](#그림-7-3-삼각형의-컨벡스-성질)의 삼각형 내 임의의 두 점 $P_1$과 $P_2$를 선택해 선분을 그리면, 선분 $\overline{P_1 P_2}$는 언제나 삼각형 내에 속한다.

###### 그림 7-3 삼각형의 컨벡스 성질
![삼각형의 컨벡스 성질](/img/)

컨벡스의 반대는 오목한 모양을 뜻하는 ***컨케이브(Concave)*** 다.   
[그림 7-4](#그림-7-4-컨벡스-영역a과-컨케이브-영역b의-비교)는 컨벡스 영역과 컨케이브 영역을 함께 비교한다.   
(b)의 ***컨케이브 영역은 임의의 두 점을 이은 선분이 영역 밖으로 벗어나는 경우가 발생***한다.

###### 그림 7-4 컨벡스 영역(a)과 컨케이브 영역(b)의 비교

아핀 공간에서 점 4개를 결합한 식을 벡터로 바꿔 표현하면 다음과 같이 전개된다.

$$\vec{x} = a \cdot \vec{u} + b \cdot \vec{v} + c \cdot \vec{w}$$

세 벡터 $\vec{u}, \vec{v}, \vec{w}$가 선형 독립 관계를 이룬다면 3차원 공간의 모든 벡터를 생성할 수 있으므로 아핀 결합으로 생성된 벡터 $\vec{x}$는 3차원 공간의 벡터가 된다.     
이때 스칼라 $a, b, c$의 값을 $|0, 1|$ 범위로 제한한다면 [그림 7-5](#그림-7-5-3차원-공간의-컨벡스-도형의-일종인-삼각뿔)와 같은 ***삼각뿔(Tetrahedron)*** 영역이 형성된다.  
삼각뿔 영역 또한 내부의 두 점을 연결한 선분은 항상 해당 영역에 속하는 컨벡스 성질을 가진다.

###### 그림 7-5 3차원 공간의 컨벡스 도형의 일종인 삼각뿔
![3차원 공간의 컨벡스 도형의 일종인 삼각뿔](/img/)

컨벡스 결합으로 만들어지는 1차원의 선분, 2차원의 삼각형, 3차원의 삼각뿔 중에서 ***가상 공간의 물체를 표현하는 데 가장 적합한 도형은 삼각형***이다.    
삼각형으로는 2차원의 물체를 효과적으로 표현할 수 있으며, 3차원의 물체도 표면만을 다루기 때문에 삼각형만으로 표현하는 것이 가장 효과적이기 때문이다.

# 22. 메시
3차원 공간의 입체적인 물체 또한 삼각형을 이어붙이면 표현이 가능하다.    
그래서 물체를 표현하기 위해 삼각형 ***데이터를 체계적으로 읽고 쓰는 방법***이 필요한데, ***삼각형을 중심으로 물체에 관련된 정보를 기록한 데이터***를 ***메시(Mesh)*** 라고 한다.   
[그림 7-6](#그림-7-6-메시의-예시)에서 그 사례를 볼 수 있다.    
(a)는 메시를 구성하는 삼각형의 세 점을 선을 이어 표현한 화면이고, (b)는 삼각형이 만들어내는 면에 이미지를 입혀서 물체를 렌더링한 결과다.

###### 그림 7-6 메시의 예시
![메시의 예시](/img/)

메시는 다수의 삼각형으로 구성되고, 메시를 이루는 삼각형은 다시 3개의 점으로 구성된다.   
메시는 결국 다수의 점으로 구성된다고 정리할 수 있다.

메시는 삼각형을 이용해 물체의 외형을 표현하기 때문에, 삼각형을 이루는 각 점의 위치를 가지고 있어야 한다.    
위치 정보만 담지 않고, 물체를 표현하는 데 활용할 수 있는 색상이나 방향과 같은 다양한 부가 정보도 담아 함께 제공한다.    
이렇게 ***위치 정보와 부가 정보를 묶은 특별한 점***을 ***정점(Vertex)*** 이라고 한다.

즉 메시는 정점들이 모인 데이터라고 할 수 있는데, 컴퓨터에서 메시를 읽어 물체를 표현할 때에는 메시의 정점 정보를 빠르게 읽기 위해서 ***메모리에 정점 정보를 일렬로 나열하는 배열의 형태로 관리한다***.     
이를 ***정점 버퍼(Vertex buffer)*** 라고 한다.     
정점 버퍼의 정보만으로는 어떤 세 정점이 모여 삼각형을 구성하는지 알 수 없다.    
그래서 삼각형을 구성하는 정점의 인덱스(순번)만 기록한 배열을 별도로 만들어 관리한다.    
이를 ***인덱스 버퍼(Index buffer)*** 라고 한다.    
인덱스 정보는 삼각형의 수만큼 필요하기 때문에 인덱스 버퍼의 크기는 항상 3의 배수다.     
이렇게 정점 버퍼와 인덱스 버퍼의 두 가지 배열 정보를 사용해 삼각형들을 하나씩 그려나가면 최종적으로 [그림 7-6](#그림-7-6-메시의-예시)과 같은 물체를 표현할 수가 있다.   
[그림 7-7](#그림-7-7-정사각형을-구성하는-메시-정보)은 두 개의 삼각형으로 이뤄진 정사각형 메시를 정점 버퍼와 인덱스 버퍼로 저장한 예시다.     
예시와 같이 두 삼각형이 빗변을 맞대고 나란히 붙어 있다면 0번째 점과 2번째 점은 두 삼각형이 공유해 사용할 수 있다.

###### 그림 7-7 정사각형을 구성하는 메시 정보

정점 배열과 인덱스 배열을 채운 후, 삼각형을 구성하는 세 점에서 두 점씩 묶어 선으로 삼각형을 표현해보자.     
삼각형을 하나씩 표현해나가면 [그림 7-6](#그림-7-6-메시의-예시)의 (a)와 같이 메시를 형상화할 수 있다.    
이렇게 삼각형의 외곽선만 그려 메시를 표현하는 방법을 ***와이어프레임(Wireframe)*** 이라고 한다.

# 23. 무게중심좌표
[식 7-1](#식-7-1)에 사용된 세 스칼라 $s, t, 1 - s - t$는 모두 실수이므로, 이들을 묶어서 하나의 3차원 벡터를 생성할 수 있다.     
이렇게 아핀 결합의 스칼라를 묶어 만든 좌표를 ***무게중심좌표(Barycentric coordinate)*** 라고 한다.     
무게중심좌표는 [그림 7-8](#그림-7-8-무게중심좌표의-의미)과 같이 삼각형에 관련된 정보를 담고 있기에, 삼각형에 관련된 기능을 구현할 때 유용하게 활용된다.

###### 그림 7-8 무게중심좌표의 의미
![무게중심좌표의 의미](/img/)

# 23.1. 무게중심좌표의 계산
[식 7-4](#식-7-4)에서 세 점의 아핀 결합이 삼각형이 되려면 모든 스칼라의 값이 $|0, 1|$ 범위 내에 있어야 했다.    
무게중심좌표를 구성하는 스칼라 값이 하나라도 $|0, 1|$ 범위를 벗어난다면 아핀 결합으로 생성된 점은 삼각형 외부에 있다고 할 수 있다.      
이러한 성질을 활용하면 주어진 점이 삼각형 영역의 내부에 있는지 외부에 있는지 판단할 수 있다.    
세 점의 아핀 결합 수식을 벡터로 변경한 [식 7-3](#식-7-3)을 도식화하면 [그림 7-9](#그림-7-9-삼각형을-구성하는-세-벡터)와 같다.

###### 그림 7-9 삼각형을 구성하는 세 벡터
![삼각형을 구성하는 세 벡터](/img/)

여기서 아핀 결합으로 생성되는 점 $P'$가 삼각형 내부에 있는지 판별하기 위해 ***내적***을 활용한다.     
[식 7-3](#식-7-3)의 벡터 $\vec{w}$에 $\vec{u}$와 $\vec{v}$를 각각 내적하면 다음 수식이 나온다.

$$\vec{w} \cdot \vec{u} = (s \cdot \vec{u} + t \cdot \vec{v}) \cdot \vec{u}$$

$$\vec{w} \cdot \vec{v} = (s \cdot \vec{u} + t \cdot \vec{v}) \cdot \vec{v}$$

내적 연산한 수식을 분배법칙에 따라 풀어주면 다음과 같이 전개된다.

$$\vec{w} \cdot \vec{u} = s(\vec{u} \cdot \vec{u}) + t(\vec{u} \cdot \vec{v})$$

$$\vec{w} \cdot \vec{v} = s(\vec{u} \cdot \vec{v}) + t(\vec{v} \cdot \vec{v})$$

여기서 $s$를 소거하기 위해, 1번 식에는 $(\vec{u} \cdot \vec{v})$를, 2번 식에는 $(\vec{u} \cdot \vec{u})$를 곱해 각각 전개한다.  

$$(\vec{w} \cdot \vec{u})(\vec{u} \cdot \vec{v}) = s(\vec{u} \cdot \vec{u})(\vec{u} \cdot \vec{v}) + t(\vec{u} \cdot \vec{v})(\vec{u} \cdot \vec{v})$$

$$(\vec{w} \cdot \vec{v})(\vec{u} \cdot \vec{u}) = s(\vec{u} \cdot \vec{v})(\vec{u} \cdot \vec{u}) + t(\vec{v} \cdot \vec{v})(\vec{u} \cdot \vec{u})$$

1번 식에서 2번 식을 빼 $s$를 소거하고 $t$만 남긴다.     
식을 풀어 $t$에 대해 정리하면 다음과 같은 식이 만들어진다.

$$t = \frac{(\vec{w} \cdot \vec{u})(\vec{u} \cdot \vec{v}) - (\vec{w} \cdot \vec{v})(\vec{u} \cdot \vec{u})}{(\vec{u} \cdot \vec{v})^2 - (\vec{u} \cdot \vec{u})(\vec{v} \cdot \vec{v})}$$

다시 예전 식으로 돌아가서, $s$에 대해 정리하기 위해 1번 식과 2번 식의 양변에 $(\vec{v} \cdot \vec{v})$와 $(\vec{u} \cdot \vec{v})$를 각각 곱한다.

$$(\vec{w} \cdot \vec{u})(\vec{v} \cdot \vec{v}) = s(\vec{u} \cdot \vec{u})(\vec{v} \cdot \vec{v}) + t(\vec{u} \cdot \vec{v})(\vec{v} \cdot \vec{v})$$

$$(\vec{w} \cdot \vec{v})(\vec{u} \cdot \vec{v}) = s(\vec{u} \cdot \vec{v})(\vec{u} \cdot \vec{v}) + t(\vec{v} \cdot \vec{v})(\vec{u} \cdot \vec{v})$$

1번 식에서 2번 식을 빼 $t$를 소거하고 $s$에 대해 정리한 식은 다음과 같다.

$$s = \frac{(\vec{w} \cdot \vec{v})(\vec{u} \cdot \vec{v}) - (\vec{w} \cdot \vec{u})(\vec{v} \cdot \vec{v})}{(\vec{u} \cdot \vec{v})^2 - (\vec{u} \cdot \vec{u})(\vec{v} \cdot \vec{v})}$$

이렇게 얻어진 무게중심좌표 $(s, t, 1 - s - t)$의 세 값 모두 $|0, 1|$ 범위 안에 있다면 점 $P_4$는 삼각형 안에 있고, 세 값 중 하나라도 $|0, 1|$ 범위를 벗어나면 점 $P_4$는 삼각형 밖에 있다고 판단할 수 있다.

이 식을 사용할 때 주의할 점은 공통분모 $(\vec{u} \cdot \vec{v})^2 - (\vec{u} \cdot \vec{u})(\vec{v} \cdot \vec{v})$의 결과가 0이 나올 수도 있다는 것이다.    
이처럼 분모 값이 0이라면 무게중심좌표를 구할 수 없다.   
어떤 경우에 분모 값이 0이 되는지 살펴보자.  
분모 $(\vec{u} \cdot \vec{v})^2 - (\vec{u} \cdot \vec{u})(\vec{v} \cdot \vec{v})$의 내적을 $\cos$ 공식으로 변경하면 다음과 같다.

$$(|\vec{u}||\vec{v}|)^2 \cdot \cos^2 \theta - (|\vec{u}||\vec{v}|)^2$$

이 값이 0이 되기 위한 조건은 벡터 $\vec{u}$ 또는 $\vec{v}$의 크기가 0이거나 벡터 $\vec{u}$와 $\vec{v}$가 이루는 각 $\theta$ 값이 $0^\circ$이거나 $180^\circ$일 때다.    
이는 두 벡터가 평행한 상태임을 의미하며, 두 벡터가 평행하면 [그림 7-10](#그림-7-10-퇴화삼각형의-예시)과 같이 선형 종속의 관계를 이루며, 선형 종속의 관계를 이루는 세 점의 결합은 삼각형이 아닌 선분을 만들어낸다.     
이러한 삼각형을 ***퇴화삼각형(Degenerate triangle)*** 이라 하며, 퇴화삼각형이 검출되면 그리기에서 제외한다.

###### 그림 7-10 퇴화삼각형의 예시
![퇴화삼각형의 예시](/img/)

# 24. 텍스처 매핑
무게중심좌표는 메시에 이미지를 입히는 용도로 활용할 수도 있다.  
메시에 이미지를 입히기 위해 변환된 데이터를 ***텍스처(Texture)*** 라고 하며, 메시에 이미지를 입히는 작업을 ***텍스처 매핑(Texture mapping)*** 이라 한다.

사진이나 그림을 저장한 이미지는 가로와 세로의 픽셀 수에 따른 고유한 해상도를 가진다.     
하지만 이미지를 메시에 입히기 위해 텍스처로 변환하면 관리 방식을 통일하기 위해 이미지의 원본 해상도에 관계없이 텍스처의 가로, 세로 크기는 1로 정규화된다.   
따라서 렌더링 과정에서 텍스처를 사용할 때에는 $|0, 1|$ 범위로 구성된 ***2차원 좌표계***를 사용한다.   
텍스처를 구성하는 2차원 좌표계를 ***UV 좌표계***라고 한다.

UV 좌표계는 2차원 벡터로 구성되며 가로 정보는 U, 세로 정보는 V로 지정된다.  

# 25. 3차원 공간의 설계
상하와 좌우만 존재했던 2차원 공간의 좌표계에서는 $x$축이 오른쪽, $y$축은 위쪽으로 방향이 명확했기 때문에 좌표계를 구성하는 데 큰 어려움이 없었다.   
3차원 공간은 2차원의 공간에 새로운 축을 추가해야 하는데, 이를 어떻게 설정하느냐에 따라 공간의 체계가 달라진다.

3차원 공간을 설계하는 방법은 크게 두 가지로 구분된다.
[그림 8-1](#그림-8-1-3차원-좌표계의-구성)처럼 사용자가 보는 모니터 화면이 데카르트 좌표계로 표현된다면, 나머지 한 축의 방향은 모니터가 바라보는 방향과 모니터 뒤편으로 향하는 뒤쪽 방향 두 가지로 나뉜다.  
나머지 한 축이 모니터가 바라보는 방향과 일치하는 체계를 ***오른손 좌표계(Right-handed coordinate system)*** 라 하고, 반대로 모니터 뒤편을 향하는 체계를 ***왼손 좌표계(Left-handed coordinate system)*** 라 한다.

###### 그림 8-1 3차원 좌표계의 구성
![3차원 좌표계의 구성](/img/)

왼손 좌표계와 오른손 좌표계는 용어가 의미하는 그대로 왼손과 오른손으로 파악해볼 수 있다.    
3차원 공간의 세 기저 축 $x, y, z$에 대해 $x \rightarrow y \rightarrow z \rightarrow x \rightarrow y$의 순서로 세 축이 순환된다고 생각해보자.    
주먹을 쥔 상태에서 엄지손가락만 세우고 나머지 네 손가락을 펴고 $x$축에서 $y$축 방향으로 손을 감으면, 나머지 축은 엄지 손가락이 가리키는 방향을 향한다.      
[그림 8-2](#그림-8-2-3차원-공간의-오른손-좌표계와-왼손-좌표계)와 같이 왼손을 사용해 $x$축에서 $y$축 방향으로 네 손가락을 감으면 엄지손가락은 모니터 뒤편을 향하고, 오른손을 감으면 엄지손가락은 모니터를 보는 자신을 향한다.

###### 그림 8-2 3차원 공간의 오른손 좌표계와 왼손 좌표계
![3차원 공간의 오른손 좌표계와 왼손 좌표계](/img/)

이렇게 왼손 좌표계와 오른손 좌표계 중 하나로 3차원 공간의 체계를 정했다면, 그 다음으로는 세 축의 용도를 지정해야 한다.      
2차원 공간에서 $x$축은 오른쪽과 왼쪽 방향, $y$축은 위와 아래 방향을 지정하는 용도로 사용됐다.   
하지만 3차원 공간에서는 이를 지정하는 방법이 프로그램마다 모두 다르다.  
위/아래 방향을 기준축으로 하여 각 소프트웨어별 좌표계 시스템을 나타낸 [그림 8-3](#그림-8-3-3d-소프트웨어가-사용하는-좌표계-시스템)을 살펴보면 (a)는 3D 모델링 소프트웨어 3DS 맥스가 사용하는 좌표계다.    
맥스는 오른손 좌표계를 사용하며 위와 아래 방향을 지정하는 데 $z$축을 사용한다.  
(b)는 게임 엔진인 유니티(Unity)가 사용하는 좌표계다.    
유니티는 왼손 좌표계를 사용하며 위와 아래 방향은 $y$축을 사용한다.  
(c)는 게임 엔진인 언리얼(Unreal)이 사용하는 좌표계다.   
언리얼도 유니티와 동일하게 왼손 좌표계를 사용하지만 위와 아래 방향은 $z$축을 사용한다.

###### 그림 8-3 3D 소프트웨어가 사용하는 좌표계 시스템
![3D 소프트웨어가 사용하는 좌표계 시스템](/img/)

3DS 맥스는 z업 오른손 좌표계, 유니티 엔진은 y업 왼손 좌표계, 언리얼 엔진은 z업 왼손 좌표계를 사용한다고 표현한다.

# 26. 3차원 공간의 트랜스폼
3차원 공간의 트랜스폼은 기저벡터가 하나 더 증가했을 뿐, 2차원 공간의 트랜스폼 설계 방식과 크게 다르지 않다.     
2차원 공간에서 이동 변환을 지원하기 위해 3차원 공간을 사용했듯이, 3차원 공간 역시 이동 변환을 위해 한 차원 더 늘어난 ***4차원 공간을 사용***한다.

2차원 공간의 크기 변환은 직교하는 $x$축과 $y$축이 서로 독립적으로 동작했다.     
3차원은 $x$축과 $y$축에 직교하는 $z$축이 하나 더 늘어났을 뿐이다.   
세 축은 모두 독립적으로 동작하기 때문에 3차원 공간의 크기 변환행렬은 다음과 같이 설계할 수 있다.

$$S = 
\begin{bmatrix}
S_x & 0 & 0 & 0 \\
0 & S_y & 0 & 0 \\
0 & 0 & S_z & 0 \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
$$

3차원 공간의 이동 변환도 모든 축이 독립적으로 동작한다.     
따라서 3차원 공간의 이동 행렬은 다음과 같이 설계할 수 있다.

$$T = 
\begin{bmatrix}
1 & 0 & 0 & t_x \\
0 & 1 & 0 & t_y \\
0 & 0 & 1 & t_z \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
$$

***회전 변환은 강체 변환의 성질을 가진다***.  
그렇기에 3차원 공간의 회전 변환은 3차원 공간을 구성하는 ***세 표준기저벡터가 동일한 크기와 직교성을 유지***한 상태로 함께 움직여야 한다.  
회전 변환으로 달라진 세 표준기저벡터값을 알 수 있다면 이를 열벡터로 꽂아넣어 회전 변환행렬 $R$을 만들어낼 수 있다.  

###### 그림 8-5 세 축의 기저벡터로 만들어지는 회전행렬
![세 축의 기저벡터로 만들어지는 회전행렬](/img/)

하지만 위와 같은 방법으로 3차원 공간의 회전을 지정한다는 것은 매번 3개의 변화된 표준기저벡터 값을 계산해야 하기 때문에 복잡한 일이 된다.   
따라서 회전을 지정할 때는 일반적으로 회전하는 중심축과 각으로 표현된 회전량을 지정하는 방식을 사용한다.     

2차원 공간은 하나의 평면만 존재하기 때문에 각으로 회전량을 지정하면 원하는 회전을 설계할 수 있다.   
하지만 3차원 공간은 무수히 많은 평면으로 구성되기 때문에 새로운 방식이 필요하다.

# 26.1. 오일러 각
***오일러 각(Euler's angle)*** 은 3차원 공간에서 물체가 놓인 방향을 3개의 각을 사용해 표시하는 방법이다.   
오일러 각은 직관적으로 이해하기 쉽기 때문에 3차원 공간을 사용하는 프로그램에서 자주 사용된다.   
[그림 8-6](#그림-8-6-유니티-엔진에서-오일러-각을-사용해-3차원-회전을-지정하는-예시)은 물체의 회전을 설정하기 위해 오일러 각을 설정하는 유니티 엔진의 인터페이스 화면이다.

###### 그림 8-6 유니티 엔진에서 오일러 각을 사용해 3차원 회전을 지정하는 예시
![유니티 엔진에서 오일러 각을 사용해 3차원 회전을 지정하는 예시](/img/)

게임 엔진에서 오일러 각을 사용해 물체의 방향을 표시할 때는 표준기저벡터를 사용한다.     
그래서 오일러 각은 표준기저벡터를 중심으로 회전하는 각의 크기로 지정된다.   
세 표준기저벡터를 중심으로 회전하는 각을 모으면 다음의 3차원 벡터로 표현할 수 있다. 

$$(\theta_x, \theta_y, \theta_z)$$

각의 값은 실수이기 때문에, ***오일러 각은 Vector3 구조체를 사용해 관리할 수 있다***.  
실제로 ***유니티 엔진에서는 Vector3를 사용해 오일러 각의 정보를 관리***한다.

이렇게 만들어진 ***오일러 각의 정보를 모든 프로그램에서 범용적으로 사용하기에는 문제가 있다***.   
왜냐하면 소프트웨어마다 $x, y, z$ ***축의 용도가 다르기 때문***이다.   
예를 들어 언리얼 엔진에서의 $x, y, z$축 회전과 유니티 엔진에서의 $x, y, z$축 회전은 서로 다르게 동작하기 때문에, 언리얼 엔진에서의 오일러 각 정보를 그대로 유니티 엔진으로 넘겨 사용할 수 없다.     
이런 문제를 해결하기 위해 $x, y, z$축 대신 ***회전의 움직임으로 회전 동작을 구분하고 각을 지정하는 방법을 사용***한다.

***표준기저벡터를 축으로 하는 회전의 움직임은 방향에 따라 요(Yaw), 롤(Roll), 피치(Pitch)로 불린다***.     
원래 항공기의 회전을 표현할 때 사용하는 용어인데, 게임에서도 동일하게 사용된다.     
요, 롤, 피치의 움직임은 [그림 8-7](#그림-8-7-요-롤-피치-회전)과 같다.

###### 그림 8-7 요, 롤, 피치 회전
![요, 롤, 피치 회전](/img/)

요, 롤, 피치의 움직임으로 오일러 각을 지정하면, 서로 다른 좌표계를 사용하는 프로그램 간에도 데이터를 쉽게 변환할 수 있다.

오일러 각을 사용해 3차원 공간의 회전을 표현할 수 있게 되었지만 ***렌더링 과정에서 3차원 공간의 회전을 사용하기 위해서는 어쩔 수 없이 회전행렬을 생성해야 한다***.

***오일러 각은 표준기저벡터를 중심으로 진행되는 세 번의 연속적인 회전을 의미한다***.  
예를 들어 $x$축 회전은 $yz$ 평면의 회전을 의미하는데, 이 경우 $x$값은 변하지 않고 오직 $y$축과 $z$축의 값만 변한다.     
따라서 $x$축의 회전행렬 $R_x$는 다음과 같이 설계할 수 있다.

$$R_x = 
\begin{bmatrix}
1 & 0 & 0 \\
0 & \cos \theta & -\sin \theta \\
0 & \sin \theta & \cos \theta \\
\end{bmatrix}
$$

동일한 방법으로 나머지 $y$축과 $z$축의 회전행렬 $R_y$와 $R_z$는 각각 다음과 같다.

$$R_y = 
\begin{bmatrix}
\cos \theta & 0 & \sin \theta \\
0 & 1 & 0 \\
-\sin \theta & 0 & \cos \theta \\
\end{bmatrix}
$$

$$R_z = 
\begin{bmatrix}
\cos \theta & -\sin \theta & 0 \\
\sin \theta & \cos \theta & 0 \\
0 & 0 & 1 \\
\end{bmatrix}
$$

주의 깊게 살펴볼 부분은 $y$축의 회전행렬 $R_y$다.   
다른 행렬은 모두 우측 상단의 $\sin$ 함수가 음의 부호인 반면 회전행렬 $R_y$는 좌측 하단의 $\sin$ 함수가 음의 부호를 가진다.  
3차원 공간에서는 $x \rightarrow y \rightarrow z \rightarrow x \rightarrow y$의 순서로 세 축이 순환되기 때문에 $y$축에 직교하는 평면은 $xz$ 평면이 아니라 $zx$ 평면이다.

# 26.2. 회전행렬의 유도
각 기저 축의 회전행렬을 구했다면, 이를 순서대로 적용해 최종 회전행렬을 만들어야 한다.   
세 번의 연속적인 회전으로 구성된 오일러 각 회전 방법은 [표 8-1](#표-8-1-오일러-각-조합에-대한-경우의-수)과 같이 총 6가지의 경우가 발생한다.

###### 표 8-1 오일러 각 조합에 대한 경우의 수
|경우|회전축의 순서|회전 동작의 순서|
|---|---|---|
|1|$x \rightarrow y \rightarrow z$|피치 $\rightarrow$ 요 $\rightarrow$ 롤|
|2|$x \rightarrow z \rightarrow y$|피치 $\rightarrow$ 롤 $\rightarrow$ 요|
|3|$y \rightarrow x \rightarrow z$|요 $\rightarrow$ 피치 $\rightarrow$ 롤|
|4|$y \rightarrow z \rightarrow x$|요 $\rightarrow$ 롤 $\rightarrow$ 피치|
|5|$z \rightarrow x \rightarrow y$|롤 $\rightarrow$ 피치 $\rightarrow$ 요|
|6|$z \rightarrow y \rightarrow x$|롤 $\rightarrow$ 요 $\rightarrow$ 피치|

언리얼 엔진과 유니티 엔진은 5번의 $z \rightarrow x \rightarrow y$의 순서를 사용한다.

***각 회전행렬을 순서대로 곱해 오일러 각에 대응되는 회전행렬*** $R$ ***을 생성할 수 있다***.

###### 식 8-1

$$R = R_{yaw} \cdot R_{pitch} \cdot R_{roll}$$

요, 피치, 롤 각의 값을 각 $\alpha, \beta, \gamma$라고 한다면 행렬 곱은 다음과 같이 계산된다.

$$
\begin{matrix}
R_\alpha \cdot R_\beta \cdot R_\gamma &=& 
\begin{bmatrix}
\cos \alpha & 0 & \sin \alpha \\
0 & 1 & 0 \\
-\sin \alpha & 0 & \cos \alpha \\
\end{bmatrix}
\begin{bmatrix}
1 & 0 & 0 \\
0 & \cos \beta & -\sin \beta \\
0 & \sin \beta & \cos \beta \\
\end{bmatrix}
\begin{bmatrix}
\cos \gamma & -\sin \gamma & 0 \\
\sin \gamma & \cos \gamma & 0 \\
0 & 0 & 1 \\
\end{bmatrix} \\
&=& 
\begin{bmatrix}
\cos \alpha \cos \gamma + \sin \alpha \sin \beta \sin \gamma & -\cos \alpha \sin \gamma + \sin \alpha \sin \beta \cos \gamma & \sin \alpha \cos \beta \\
\cos \beta \sin \gamma & \cos \beta \cos \gamma & -\sin \beta \\
-\sin \alpha \cos \gamma + \cos \alpha \sin \beta \sin \gamma & \sin \alpha \sin \gamma + \cos \alpha \sin \beta \cos \gamma & \cos \alpha \cos \beta \\
\end{bmatrix}
\end{matrix}
$$

***계산된 회전행렬의 열벡터는 표준기저벡터가 회전 변환된 로컬 축을 의미한다***.   
따라서 오일러 각으로 변환된 각 로컬 축의 값은 다음과 같이 계산해 얻을 수 있다.

$$x_{local} = (\cos \alpha \cos \gamma + \sin \alpha \sin \beta \sin \gamma, \cos \beta \sin \gamma, -\sin \alpha \cos \gamma + \cos \alpha \sin \beta \sin \gamma)$$

$$y_{local} = (-\cos \alpha \sin \gamma + \sin \alpha \sin \beta \cos \gamma, \cos \beta \cos \gamma, \sin \alpha \sin \gamma + \cos \alpha \sin \beta \cos \gamma)$$

$$z_{local} = (\sin \alpha \cos \beta, -\sin \beta, \cos \alpha \cos \beta)$$

3차원 공간의 트랜스폼도 회전 변환이 발생할 때마다 로컬 축 데이터를 갱신하면 게임 로직에서 유용하게 사용할 수 있을 뿐만 아니라, 렌더링 로직에 필요한 회전행렬도 바로 만들어 낼 수 있다.  
이 계산식으로 얻어낸 로컬 축 벡터를 각각 $\vec{x} = (x_x, x_y, x_z)$, $\vec{y} = (y_x, y_y, y_z)$, $\vec{z} = (z_x, z_y, z_z)$로 지정하고, 이들을 열벡터로 꽂아넣어 얻어지는 3차원 공간의 회전행렬 $R$은 다음과 같다.

$$R = 
\begin{bmatrix}
x_x & y_x & z_x & 0 \\
x_y & y_y & z_y & 0 \\
x_z & y_z & z_z & 0 \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
$$

# 26.3. 3차원 모델링 행렬
***3차원 공간의 트랜스폼***을 구성하는 ***크기(S)***, ***회전(R)***, ***이동(T)*** 변환행렬은 다음과 같다.  

$$S = 
\begin{bmatrix}
S_x & 0 & 0 & 0 \\
0 & S_y & 0 & 0 \\
0 & 0 & S_z & 0 \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
$$

$$R = 
\begin{bmatrix}
X_x & Y_x & Z_x & 0 \\
X_y & Y_y & Z_y & 0 \\
X_z & Y_z & Z_z & 0 \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
$$

$$T = 
\begin{bmatrix}
1 & 0 & 0 & t_x \\
0 & 1 & 0 & t_y \\
0 & 0 & 1 & t_z \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
$$

이 세 행렬을 $TRS$ 연산 순서에 따라 곱해 만든 ***모델링 행렬*** $M$은 다음과 같이 계산된다.

$$M = T \cdot R \cdot S = 
\begin{bmatrix}
X_xS_x & Y_xS_y & Z_xS_z & t_x \\
X_yS_x & Y_yS_y & Z_yS_z & t_y \\
X_zS_x & Y_zS_y & Z_zS_z & t_z \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
$$

# 27. 카메라 공간
2차원 카메라를 구현할 때에는 이동 기능만 부여했지만 3차원 공간의 카메라에는 이동과 회전 기능을 함께 부여한다.

3차원 공간에서 카메라 설정은 고려할 요소가 많다.    
[그림 8-8](#그림-8-8-3차원-공간의-카메라-설정)과 같이 월드 공간의 원점에 카메라가 있고, 카메라가 바라보는 방향에 게임 오브젝트가 위치한 상황을 가정해본다.  
이 상황에서 카메라의 $x$축과 $y$축으로 최종 화면을 생성한다고 설정했을 때 화면의 $x$축 방향은 익숙한 오른쪽이 아닌 왼쪽을 향하게 된다.

###### 그림 8-8 3차원 공간의 카메라 설정
![3차원 공간의 카메라 설정](/img/)

이는 보편적으로 인지하는 2차원 데카르트 좌표계와 다르기 때문에 바로잡아 줄 필요가 있다.     
그래서 카메라가 만들어내는 화면의 $x$축이 왼쪽을 향하도록 [그림 8-9](#그림-8-9-뷰-공간으로-재해석된-3차원-공간)와 같이 $y$축으로 $180^\circ$ 회전시켜 ***뷰 공간***을 구성한다.

이 경우 뷰 공간의 $z$축은 카메라의 뒤를 향하고, 뷰 공간에서 $x$축과 $z$축은 월드 공간의 $x$축과 $z$축의 반대 방향을 가지게 된다.

###### 그림 8-9 뷰 공간으로 재해석된 3차원 공간
![뷰 공간으로 재해석된 3차원 공간](/img/)

***카메라에는 크기의 개념이 없기 때문에, 카메라의 트랜스폼은 크기 변환을 제외한 회전과 이동 변환으로만 구성된다***.   
카메라의 트랜스폼에 저장된 위치 값을 $t = (t_x, t_y, t_z)$로 지정하고, 로컬 축 값을 각각 $x = (x_x, x_y, x_z)$, $y = (y_x, y_y, y_z)$, $z = (z_x, z_y, z_z)$로 지정한다.    
이동 행렬 $T$와 회전 행렬 $R$은 다음과 같다.

$$T = 
\begin{bmatrix}
1 & 0 & 0 & t_x \\
0 & 1 & 0 & t_y \\
0 & 0 & 1 & t_z \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
$$

$$R = 
\begin{bmatrix}
x_x & y_x & z_x & 0 \\
x_y & y_y & z_y & 0 \\
x_z & y_z & z_z & 0 \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
$$

뷰 행렬을 구하기 위한 역행렬을 계산해보자.  
이동 $T$의 역행렬 $T^{-1}$은 덧셈의 역원인 반대수를 사용해 구할 수 있다.    
***이동의 역행렬을 적용하면 모든 좌표는 카메라를 중심으로 재배치된다***.

$$T^{-1} = 
\begin{bmatrix}
1 & 0 & 0 & -t_x \\
0 & 1 & 0 & -t_y \\
0 & 0 & 1 & -t_z \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
$$

회전 변환 역시 이동 변환과 동일하게 역행렬을 적용시킨다.    
예를 들어 물체는 가만히 있는데 카메라가 $30^\circ$ 회전하는 상황이라면, 화면을 바라보는 사용자는 마치 물체가 $-30^\circ$ 회전하는 것으로 느낄 것이다.   
***직교행렬인 회전 변환행렬*** $R$의 ***역행렬*** $R^{-1}$은 다음과 같이 ***전치행렬***로 구할 수 있다.

$$R^{-1} = 
\begin{bmatrix}
x_x & x_y & x_z & 0 \\
y_x & y_y & y_z & 0 \\
z_x & z_y & z_z & 0 \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
$$

이동의 역행렬과 회전의 역행렬을 구했다면 이들을 적용해 최종 뷰 행렬을 완성할 수 있다.   
여기서, 이동의 역행렬을 먼저 적용할지, 회전의 역행렬을 먼저 적용할지를 선택해야 한다.   
적용 순서를 고려한다면 ***이동의 역행렬을 적용한 후에 회전의 역행렬을 적용해야 한다***.   
***카메라에 회전을 적용할 시점에 모든 좌표는 카메라를 중심으로 변환되어 있어야 하기 때문이다***.  
이는 트랜스폼의 순서를 거꾸로 돌리는 것과 동일한 원리로 볼 수 있다.

정리하면 크기 변환 $S$를 제외한 카메라의 트랜스폼으로부터 얻어지는 모델링 행렬 $M$은 다음과 같다.

$$M = T \cdot R$$

모델링 행렬의 역행렬 $M^{-1}$은 바로 뷰 행렬이 되며, 다음과 같이 전개된다.

$$M^{-1} = (T \cdot R)^{-1} = R^{-1} \cdot T^{-1}$$

두 행렬을 곱한 결과는 다음과 같다.  
마지막 4열은 내적을 사용해 간략하게 정리한다.

$$R^{-1} \cdot T^{-1} = 
\begin{bmatrix}
x_x & x_y & x_z & -x \cdot t \\
y_x & y_y & y_z & -y \cdot t \\
z_x & z_y & z_z & -z \cdot t \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
$$

마지막으로 최종 뷰 좌표계는 [그림 8-9](#그림-8-9-뷰-공간으로-재해석된-3차원-공간)와 같이 $y$축으로 $180^\circ$ 회전한 구조를 가져야 한다.   
이를 위해 $x$축 기저와 $z$축 기저를 반전시킨다.     
반전을 적용한 최종 뷰 행렬 $V$는 다음과 같다.

$$V = R^{-1} \cdot T^{-1} = 
\begin{bmatrix}
-x_x & -x_y & -x_z & x \cdot t \\
y_x & y_y & y_z & -y \cdot t \\
-z_x & -z_y & -z_z & z \cdot t \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
$$

뷰 좌표계에서 카메라 정면에 위치한 모든 물체의 $z$값은 음수다.

# 28. 오일러 각의 특징
3차원 트랜스폼의 회전을 담당하는 오일러 각 방식은 장점과 단점이 명확하게 존재한다.  

오일러 각은 ***3차원 공간의 회전을 지정할 때 직관적인 인터페이스를 제공***한다.   
설정할 값도 세 가지뿐이고, 직관적인 표준기저벡터를 회전축으로 사용하기 때문에 회전을 설계하기가 용이하다.   
이러한 오일러각은 사용자 입장에서 물체의 회전을 설정할 때 가장 적합하다.    
대다수 3차원 그래픽 소프트웨어에서 3차원 회전을 설정하는 인터페이스로 오일러 각 방식을 사용한다.

오일러 각의 또 다른 장점은 ***적은 용량으로 3차원 공간의 회전 정보를 기록할 수 있다***는 점이다.      
행렬을 사용해 3차원 공간의 회전을 표현하려면 최소 9개의 실수 데이터가 필요하지만, 오일러 각은 3개의 데이터만 있으면 3차원 공간의 회전을 표현할 수 있다.     
이는 트랜스폼 정보를 줄일 수 있어 적은 용량으로 게임 데이터를 관리할 수 있게 도와준다.

# 28.1. 짐벌락 현상
오일러 각을 사용해 3차원 공간의 회전을 다룰 때에는 특정 상황에서 회전 움직임이 제한되는 ***짐벌락(Gimbal lock)*** 이라 불리는 이상 현상을 감안해야 한다.     
짐벌락 현상을 알아보기 위해 오일러 각을 사용해 [그림 8-10](#그림-8-10-짐벌락-현상을-알아보기-위한-기준-설정)의 게임 오브젝트를 회전시켜 본다.

###### 그림 8-10 짐벌락 현상을 알아보기 위한 기준 설정
![짐벌락 현상을 알아보기 위한 기준 설정](/img/)

여기서 물체를 앞 방향인 $z$축으로 $90^\circ$ 회전(Roll)시킨다면, [그림 8-11](#그림-8-11-z축으로-90도-회전한-결과-화면)과 같이 얼굴 면이 반시계 방향으로 돌아가는 회전이 발생한다.

###### 그림 8-11 z축으로 90도 회전한 결과 화면
![z축으로 90도 회전한 결과 화면](/img/)

우측 방향인 $x$축으로 $-90^\circ$ 회전시킨다.    
목을 중심으로 시계 방향으로 돌아가게 된다.  
[그림 8-12](#그림-8-12-x축으로-회전한-결과-화면)처럼 게임 오브젝트는 위를 바라보게 된다.

###### 그림 8-12 x축으로 회전한 결과 화면
![x축으로 회전한 결과 화면](/img/)

위쪽 방향인 $y$축 회전을 적용한다.  
$y$축의 회전은 [그림 8-13](#그림-8-13-y축으로--45도-회전한-결과-화면)과 같이 얼굴 면이 돌아가는 회전이 되는데, 이는 처음 진행한 $z$축의 회전과 동일하다.

###### 그림 8-13 y축으로 -45도 회전한 결과 화면
![y축으로 -45도 회전한 결과 화면](/img/)

결과적으로 $z$축과 $y$축은 얼굴을 돌리는 동일한 회전이 되어버려, 세 개의 축으로 자유롭게 회전하지 못하고 두 개의 축만 회전에 사용됐다.  
이렇게 회전이 제약되는 현상을 짐벌락이라고 한다.

# 28.2. 회전 보간의 계산
3차원 공간에서 시작 회전과 끝 회전을 지정하고 시간에 따라 두 회전 사이를 부드럽게 전환하기는 기능은 카메라의 움직임이나 캐릭터 애니메이션을 구현하는 데 필요하다.   
이를 구현하기 위해서는 경과된 시간에 따라 회전이 변화되도록 중간 회전 값을 계산할 수 있어야 하는데 이를 ***회전 보간(Rotational interpolation)*** 이라고 한다.

중간 회전 값은 다음과 같이 선형 보간의 식을 사용해 얻을 수 있다.

$$\theta' = (1 - t)\theta_{start} + t\theta_{end}$$

예를 들어 동일한 평면 상에서 $15^\circ$에서 시작해 $165^\circ$로 끝나는 회전의 $\frac{1}{3}$ 비율에 해당하는 회전 보간 값은 $65^\circ$인데, 이는 다음의 수식으로 계산할 수 있다.

$$\frac{2}{3} \cdot 15^\circ + \frac{1}{3} \cdot 165^\circ = 65^\circ$$

***선형 보간식이 성립하려면 두 각의 회전 변환을 곱한 결과가 두 각의 합의 회전 변환과 동일해야 한다***.    
2차원 공간의 회전에서는 두 결과가 동일하기 때문에 2차원 공간의 회전에서 선형 보간식을 사용하는 데 아무런 문제가 없다.   
3차원 공간의 오일러 각 회전에서도 선형 보간식을 사용하는 데 문제가 없는지는 두 오일러 각의 회전 변환을 곱한 결과가 두 오일러 각의 합의 회전 변환과 동일한지 확인하면 알 수 있다.    
세 기저벡터 중에서 $y$축에 대해서만 회전하는 오일러 각 회전을 살펴보면, $y$축으로 $\alpha$와 $\beta$만큼 회전하는 오일러 각의 데이터는 각각 다음과 같다.

$$(0, \alpha, 0)$$

$$(0, \beta, 0)$$

[식 8-1](#식-8-1)에 의해 두 오일러 각에 대응하는 회전 변환 $R_\alpha$와 $R_\beta$는 다음과 같이 계산된다.

$$R_\alpha = R_{yaw\alpha} \cdot I \cdot I = R_{yaw\alpha}$$

$$R_\beta = R_{yaw\beta} \cdot I \cdot I = R_{yaw\beta}$$

두 오일러 각을 합한 회전 변환 $R_{(\alpha + \beta)}$는 다음과 같다.

$$R_{(\alpha + \beta)} = R_{yaw(\alpha + \beta)} \cdot I \cdot I = R_{yaw(\alpha + \beta)}$$

두 오일러 각에 대응하는 회전 변환 $R_\alpha$와 $R_\beta$를 곱한 결과를 전개해보자.

$$
\begin{matrix}
R_\beta \cdot R_\alpha &=& (R_{yaw\beta} \cdot R_{pitch\beta} \cdot R_{roll\beta}) \cdot (R_{yaw\alpha} \cdot R_{pitch\alpha} \cdot R_{roll\alpha}) \\
&=& (R_{yaw\beta} \cdot I \cdot I) \cdot (R_{yaw\alpha} \cdot I \cdot I) \\
&=& R_{yaw\beta} \cdot R_{yaw\alpha} \\
&=& R_{yaw(\beta + \alpha)} \\
&=& R_{(\alpha + \beta)} \\
\end{matrix}
$$

$y$축만 사용하는 두 오일러 각을 곱한 결과는 두 오일러 각을 합한 회전 변환 $R_{(\alpha + \beta)}$와 동일함을 확인할 수 있다.     
***오일러 각에서 한 축만 사용한다는 것은 결국 2차원 평면에서의 회전과 동일하다***.    
따라서 해당 상황에서는 선형 보간식을 사용하는 데 문제가 없다.

$x$축과 $y$축, 두 축에 대해서 회전하는 오일러 각에 대해 알아보자.   
두 축에 대해 $\alpha$와 $\beta$만큼 회전하는 오일러 각의 데이터는 각각 다음과 같다.

$$(\alpha, \alpha, 0)$$

$$(\beta, \beta, 0)$$

[식 8-1](#식-8-1)에 의해 두 오일러 각에 대응하는 회전 변환 $R_\alpha$와 $R_\beta$는 다음과 같이 계산된다.

$$R_\alpha = R_{yaw\alpha} \cdot R_{pitch\alpha} \cdot I = R_{yaw\alpha} \cdot R_{pitch\alpha}$$

$$R_\beta = R_{yaw\beta} \cdot R_{pitch\beta} \cdot I = R_{yaw\beta} \cdot R_{pitch\beta}$$

두 오일러 각을 합한 각의 회전 변환 $R_{(\alpha + \beta)}$는 다음과 같다.

$$R_{(\alpha + \beta)} = R_{yaw(\alpha + \beta)} \cdot R_{pitch(\alpha + \beta)} \cdot I = R_{yaw(\alpha + \beta)} \cdot R_{pitch(\alpha + \beta)}$$

두 오일러 각에 대응하는 회전 변환 $R_\alpha$와 $R_\beta$를 곱한 결과는 두 오일러 각을 합한 회전 변환 $R_{(\alpha + \beta)}$와 다르다.

$$
\begin{matrix}
R_\beta \cdot R_\alpha &=& (R_{yaw\beta} \cdot R_{pitch\beta} \cdot R_{roll\beta}) \cdot (R_{yaw\alpha} \cdot R_{pitch\alpha} \cdot R_{roll\alpha}) \\
&=& (R_{yaw\beta} \cdot R_{pitch\beta} \cdot I) \cdot (R_{yaw\alpha} \cdot R_{pitch\alpha} \cdot I) \\
&=& R_{yaw\beta} \cdot R_{pitch\beta} \cdot R_{yaw\alpha} \cdot R_{pitch\alpha} \\
&\neq& R_{(\alpha + \beta)} \\
\end{matrix}
$$

따라서 ***두 축 이상을 사용하는 오일러 각은 선형 보간식을 사용할 수 없다***.

일반적으로 게임에서 캐릭터의 회전은 $y$축에 대응하는 요 회전만을 사용하기 때문에 캐릭터 회전 보간은 오일러 각으로 충분히 구현 가능하다.     
하지만 비행기 조종 같은 3차원 공간에서 2개 이상의 기저축이 결합된 방식으로 회전을 진행하는 경우 오일러 각 방식을 사용해 회전 보간을 구현하는 작업은 어려워진다.     
3차원 공간에서 자유로운 회전 보간을 구현하고 싶은 경우에는 ***로드리게스 회전 공식***을 사용하거나 ***사원수***를 사용해야 한다.

# 29. 벡터의 외적
벡터에는 내적 외에도 ***외적(Cross product)*** 이라는 연산이 있는데 내적이 모든 차원의 벡터에 적용할 수 있는 것과 달리 ***외적은 3차원 공간의 벡터에서만 사용이 가능한 연산***이다.

3차원 벡터의 외적은 $\times$기호를 사용한다.    
두 3차원 벡터 $\vec{u}$와 $\vec{v}$의 외적 $\vec{u} \times \vec{v}$는 다음과 같다.

###### 식 9-1

$$\vec{u} = (u_x, u_y, u_z), \vec{v} = (v_x, v_y, v_z)$$

$$\vec{u} \times \vec{v} = (u_yv_z - v_yu_z, u_zv_x - v_zu_x, u_xv_y - v_xu_y)$$

외적은 회전의 순환 순서 $x \rightarrow y \rightarrow z \rightarrow x$에 맞춰 벡터를 순서대로 나열하는 형태이고, ***외적의 결과는 언제나 3차원 벡터가 된다***.     
이는 ***연산 결과가 항상 스칼라로 나오는 내적***과 대비된다.

외적 계산식의 패턴은 $x$ 성분의 결과를 만들기 위해 $x$와 관련없는 나머지 두 성분 $y$와 $z$를 결합해 만든다는 것이다.    
나머지 $y$와 $z$를 만들 때도 동일하다.  
이것도 항상 같은 성분만 사용하는 내적과 대비된다.   
두 연산에 사용되는 벡터의 요소를 비교하면 [그림 9-1](#그림-9-1-내적과-외적의-성질-비교)과 같다.

###### 그림 9-1 내적과 외적의 성질 비교
![내적과 외적의 성질 비교](/img/)

***외적은 교환법칙이 성립하지 않는다***.  
[식 9-1](#식-9-1)을 살펴보면 교환법칙이 성립하지 않는 뺄셈이 사용되고 있다.

$$\vec{u} \times \vec{v} \neq \vec{v} \times \vec{u}$$

뺄셈에서 두 수의 순서를 바꿔 계산하면 반대수가 나오는 것처럼 외적도 ***순서를 바꿔 연산하면 반대 방향의 벡터가 나온다***.     
외적의 특징을 수식으로 표현하면 다음과 같다.

$$a - b = -(b -a)$$

$$\vec{u} \times \vec{v} = -\vec{v} \times \vec{u}$$

***외적은 결합법칙도 성립하지 않는다***.

$$\vec{u} \times (\vec{v} \times \vec{w}) \neq (\vec{u} \times \vec{v}) \times \vec{w}$$

***덧셈에 대한 분배법칙은 성립한다***.

$$\vec{u} \times (\vec{v} + \vec{w}) = \vec{u} \times \vec{v} + \vec{u} \times \vec{w}$$

벡터의 내적과 외적의 차이를 정리하면 [표 9-1](#표-9-1-벡터의-내적과-외적의-차이1)과 같다.

###### 표 9-1 벡터의 내적과 외적의 차이(1)
||내적|외적|
|---|---|---|
|계산 결과|스칼라|벡터|
|교환법칙|성립함|성립하지 않음|
|결합법칙|성립하지 않음|성립하지 않음|
|분배법칙|성립함|성립함|
|연산 방법|같은 위치의 요소만 사용|다른 위치의 요소만 사용|

서로 대립되는 내적과 외적의 성질은 각 연산이 가지는 부족한 부분을 상호보완하는 기능으로 활용된다.

# 29.1. 평행성 판별
동일한 벡터끼리 내적하면 벡터 크기를 제곱한 값이 나오는데, ***동일한 벡터를 외적하면 그 결과는 항상 영벡터가 나온다***.

$$\vec{u} \times \vec{u} = (u_yu_z - u_yu_z, u_zu_x - u_zu_x, u_xu_y - u_xu_y) = (0, 0, 0)$$

이는 $\vec{u}$와 반대 방향의 벡터 $-\vec{u}$를 외적하는 경우에도 동일하다.  

$$\vec{u} \times -\vec{u} = (-u_yu_z + u_yu_z, -u_zu_x + u_zu_x, -u_xu_y + u_xu_y) = (0, 0, 0)$$

$\vec{u}$와 평행하지만 크기가 다른 $\vec{v}$라는 벡터를 서로 외적해도 0이 된다.

$$\vec{v} = k \cdot \vec{u}$$

$$\vec{u} \times \vec{v} = (ku_yu_z - ku_yu_z, ku_zu_x - ku_zu_x, ku_xu_y - ku_xu_y)$$

이로써 평행한 두 벡터를 외적하면 항상 영벡터가 됨을 알 수 있으며, 이러한 외적의 성질은 ***평행성을 판별하는 데 사용***된다.   
이는 ***두 벡터의 직교성을 판별하는 내적의 성질과 대립***된다.

외적의 성질을 자세히 알아보기 위해, [그림 9-2](#그림-9-2-벡터를-수평-성분과-수직-성분으로-분리하기)처럼 벡터 $\vec{u}$를 벡터 $\vec{v}$에 수평인 벡터 $\vec{u_\parallel}$과 수직인 벡터 $\vec{u_\perp}$로 분리한다.  
벡터 $\vec{u}$는 수평 성분과 수직 성분의 덧셈으로 분리된다.

###### 그림 9-2 벡터를 수평 성분과 수직 성분으로 분리하기
![벡터를 수평 성분과 수직 성분으로 분리하기](/img/)

외적은 덧셈의 분배법칙이 성립하므로 벡터 $\vec{u}$를 분리한 벡터 $\vec{u_\perp}$, $\vec{u_\parallel}$와 $\vec{v}$의 외적은 다음과 같이 전개된다.

$$\vec{v} \times \vec{u} = \vec{v} \times (\vec{u_\perp} + \vec{u_\parallel}) = \vec{v} \times \vec{u_\perp} + \vec{v} \times \vec{u_\parallel}$$

벡터 $\vec{v}$와 평행한 벡터 $\vec{u_\parallel}$와의 외적은 크기와 관계 없이 영벡터가 된다.     
따라서 위 식은 다음과 같이 간략하게 정리된다.

$$\vec{v} \times \vec{u} = \vec{v} \times \vec{u_\perp}$$

이로써 ***외적은 상대방에 직교하는 벡터 성분만 사용되는 성질이 있음***을 알 수 있다.  
두 벡터의 사잇각을 $\theta$라고 할 때 [그림 9-3](#그림-9-3-크기는-같지만-사잇각이-다른-두-벡터의-수직-성분의-크기-비교)을 살펴보면 두 벡터의 사잇각이 큰 (a)의 직교하는 성분 $\vec{u_\perp}$의 크기는 그보다 사잇각이 작은 (b)의 직교하는 성분 $\vec{u_\perp}$보다 크다.   
직교 성분 $\vec{u_\perp}$의 크기는 $\sin$ 함수에 비례하므로 외적의 크기도 $\sin$ 함수에 비례한다.

###### 그림 9-3 크기는 같지만, 사잇각이 다른 두 벡터의 수직 성분의 크기 비교
![크기는 같지만, 사잇각이 다른 두 벡터의 수직 성분의 크기 비교](/img/)

실제로 외적의 결과가 $\sin$ 함수에 비례하는지 수식으로 확인해보자.  
이를 위해 준비한 세 가지 연산 $|\vec{u} \times \vec{v}|^2$, $(|\vec{u}||\vec{v}|)^2$, $(\vec{u} \cdot \vec{v})^2$을 각각 전개한다.  
첫 번째 식 $|\vec{u} \times \vec{v}|^2$를 전개하면 다음과 같다.

$$
\begin{matrix}
|\vec{u} \times \vec{v}|^2 &=& (\vec{u} \times \vec{v}) \cdot (\vec{u} \times \vec{v}) \\
&=& (u_yv_z - u_zv_y)^2 + (u_zv_x - u_xv_z)^2 + (u_xv_y - u_yv_x)^2 \\
&=& u_y^2v_z^2 - 2u_yu_zv_yv_z + u_z^2v_y^2 + u_z^2v_x^2 - 2u_yu_zv_yv_z + u_x^2v_z^2 + u_x^2v_y^2 - 2u_xu_yv_xv_y + u_y^2v_x^2 \\
\end{matrix}
$$

두 번째 식 $(|\vec{u}||\vec{v}|)^2$를 전개하면 다음과 같다.

$$
\begin{matrix}
(|\vec{u}||\vec{v})^2 &=& (\sqrt{u_x^2 + u_y^2 + u_z^2} \sqrt{v_x^2 + v_y^2 + v_z^2})^2 \\
&=& (u_x^2 + u_y^2 + u_z^2)(v_x^2 + v_y^2 + v_z^2) \\
&=& u_x^2v_x^2 + u_x^2v_y^2 + u_x^2v_z^2 + u_y^2v_x^2 + u_y^2v_y^2 + u_y^2v_z^2 + u_z^2v_x^2 + u_z^2v_y^2 + u_z^2v_z^2 \\
\end{matrix}
$$

마지막 식 $(\vec{u} \cdot \vec{v})^2$를 전개하면 다음과 같다.

$$
\begin{matrix}
(\vec{u} \cdot \vec{v})^2 &=& (u_xv_x + u_yv_y + u_zv_z)^2 \\
&=& u_x^2v_x^2 + u_y^2v_y^2 + u_z^2v_z^2 + 2u_xu_yv_xv_y + 2u_xu_zv_xv_z + 2u_yu_zv_yv_z \\
\end{matrix}
$$

세 식의 결과를 비교하면 당므과 같은 관계를 가진다.

$$|\vec{u} \times \vec{v}|^2 = (|\vec{u}||\vec{v}|)^2 - (\vec{u} \cdot \vec{v})^2$$

위 식의 내적 $\vec{u} \cdot \vec{v}$를 코사인 공식으로 바꿔 전개하면 아래와 같다.

$$
\begin{matrix}
|\vec{u} \times \vec{v}|^2 &=& (|\vec{u}||\vec{v}|)^2 - (|\vec{u}||\vec{v}| \cos \theta)^2 \\
&=& (|\vec{u}||\vec{v}|)^2(1 - \cos^2 \theta) \\
&=& (|\vec{u}||\vec{v}|)^2 \sin^2 \theta \\
\end{matrix}
$$

이로써 벡터 외적의 크기는 $\sin$ 함수의 크기에 비례함을 알 수 있다.

$$|\vec{u} \times \vec{v}| = |\vec{u}||\vec{v}||\sin \theta|$$

***외적으로 생성된 벡터의 크기는*** [그림 9-4](#그림-9-4-두-벡터-u와-v가-만드는-평행사변형의-넓이)와 같이 ***두 벡터가 만드는 평행사변형의 넓이로 나타낼 수 있다***.    
이는 ***행렬식이 만들어내는 넓이와 동일***하다.

###### 그림 9-4 두 벡터 u와 v가 만드는 평행사변형의 넓이
![두 벡터 u와 v가 만드는 평행사변형의 넓이](/img/)

[표 9-1](#표-9-1-벡터의-내적과-외적의-차이1)에 이어 내적과 대비되는 외적의 성질을 정리하면 [표 9-2](#표-9-2-벡터의-내적과-외적의-차이2)와 같다.

###### 표 9-2 벡터의 내적과 외적의 차이(2)

||내적|외적|
|---|---|---|
|판별성|직교성|평행성|
|삼각함수|$\cos \theta$|$\sin \theta$|

# 29.2. 법선 벡터
벡터 외적이 가지는 또 하나의 중요한 성질은 ***두 벡터에 직교하는 벡터를 생성한다***는 것이다.     
임의의 두 벡터 $\vec{u} = (u_x, u_y, u_z)$와 $\vec{v} = (v_x, v_y, v_x)$의 외적을 계산해 확인해보자.

$$\vec{u} \times \vec{v} = (u_yv_z - v_yu_z, u_zv_x - v_zu_x, u_xv_y - v_xu_y)$$

$\vec{u}$와 $\vec{v}$의 외적 결과에 벡터 $\vec{u}$를 내적하면 결과는 항상 0이 된다.

$$\vec{u} \cdot (\vec{u} \times \vec{v}) = u_xu_yv_z - u_xv_yu_z + u_yu_zv_x - u_yv_zu_x + u_zu_xv_y - u_zv_xu_y = 0$$

동일한 방법으로 $\vec{u}$와 $\vec{v}$의 외적 결과에 벡터 $\vec{v}$를 내적해도 0이 나온다.

$$\vec{v} \cdot (\vec{u} \times \vec{v}) = v_xu_yv_z - v_xv_yu_z + v_yu_zv_x - v_yv_zu_x + v_zu_xv_y - v_zv_xu_y = 0$$

***외적의 결과는 두 벡터에 모두 직교함***을 알 수 있다.   
***선형 독립의 관계를 가지는 두 벡터의 선형 결합은 평면을 만든다***.   
두 벡터의 외적은 두 벡터가 만드는 평면에 직교하는, 다시 말하면 ***평면이 향하는 방향에 대한 벡터를 만들어내는 것으로 해석할 수 있다***.

[그림 9-5](#그림-9-5-법선-벡터를-생성하는-외적)와 같이 3개의 점 $P_1, P_2, P_3$를 결합해 만든 평면을 가정한다.   
점 $P_2$와 $P_3$에서 점 $P_1$을 뺀 두 벡터 $\vec{u}$와 $\vec{v}$를 생성한 후 둘을 외적하면 세 점이 만들어내는 평면에 직교하는 벡터가 생성된다.  
이는 평면이 향하는 방향을 나타내며 이 벡터를 ***법선 벡터(Normal vector)*** 또는 ***노멀 벡터***라고 한다.

###### 그림 9-5 법선 벡터를 생성하는 외적
![법선 벡터를 생성하는 외적](/img/)

외적은 교환법칙이 성립하지 않기 때문에, 연산의 순서를 바꾼 $\vec{v} \times \vec{u}$는 [그림 9-6](#그림-9-6-외적의-적용-순서에-따른-결과-비교)과 같이 $\vec{u} \times \vec{v}$의 반대 방향으로 향하는 법선 벡터가 생성된다.   
따라서 ***법선 벡터를 생성할 때에는 외적의 연산 순서에 신경 써야 한다***.

###### 그림 9-6 외적의 적용 순서에 따른 결과 비교
![외적의 적용 순서에 따른 결과 비교](/img/)

이렇게 두 개의 다른 벡터가 나오는 이유는 ***3차원 공간에서 평면은 앞면과 뒷면으로 구성***되어 있기 때문이다.  

# 29.3. 좌우 방향 판별
$\sin$ 함수와 관련 있는 외적의 성질은 게임 개발에서 유용하게 활용할 수 있다.    
대표적인 외적의 활용 방법은 ***왼쪽과 오른쪽의 판별***이다.   
[그림 9-7](#그림-9-7-좌우-방향-판별을-위한-예시-상황)은 월드 공간의 $y$축 $\vec{y} = (0, 1, 0)$에 직교하는 평면에 캐릭터와 물체가 놓여 있는 상황이다.      
이때 캐릭터의 정면을 향하는 시선 벡터 $\vec{f}$와 캐릭터에서 물체로 향하는 벡터 $\vec{v}$가 주어진 상황을 가정한다.

###### 그림 9-7 좌우 방향 판별을 위한 예시 상황
![좌우 방향 판별을 위한 예시 상황](/img/)

만일 물체가 시선 방향의 왼쪽에 있다면 시선 벡터 $\vec{f}$에서 물체로 향하는 벡터 $\vec{v}$로 외적한 결과는 오른손 법칙에 따라 평면의 위쪽인 $\vec{y}$로 향한다.     
반대로 물체가 시선 방향의 오른쪽에 있다면 외적의 결과는 평면의 아래쪽인 $-\vec{y}$로 향한다.    
왼쪽과 오른쪽에 따라 달라지는 외적 결과는 [그림 9-8](#그림-9-8-물체가-놓인-위치가-왼쪽-오른쪽에-따라-달라지는-외적의-결과)과 같다.

###### 그림 9-8 물체가 놓인 위치가 왼쪽, 오른쪽에 따라 달라지는 외적의 결과
![물체가 놓인 위치가 왼쪽, 오른쪽에 따라 달라지는 외적의 결과](/img/)

이러한 외적의 성질을 활용하면 ***시선 방향을 기준으로 물체가 왼쪽에 있는지 오른쪽에 있는지를 파악할 수 있다***.   
외적의 결과는 벡터이므로, 참 거짓을 파악할 수 있도록 스칼라로 변환해야 한다.    
이를 위해서는 외적의 결과에 내적을 추가로 활용해야 한다.    
외적 결과에 평면의 위쪽 방향을 나타내는 벡터 $\vec{y}$를 내적한다.  
두 벡터의 방향이 같다면 내적 값은 양수, 반대 방향이라면 음수가 된다.    
따라서 물체가 캐릭터의 시선 방향 왼쪽에 있다면 내적의 결과는 양수, 오른쪽에 있다면 음수가 된다.     
외적과 내적 연산을 조합해 파악할 수 있는 경우의 수를 [표 9-3](#표-9-3-물체의-좌우-방향-판별을-위한-수식)에 정리했다.

###### 표 9-3 물체의 좌우 방향 판별을 위한 수식

|물체의 위치|판별식의 값|
|---|---|
|물체가 시선 방향에서 왼쪽에 있는 경우|$(\vec{f} \times \vec{v}) \cdot \vec{y} > 0$|
|물체가 시선 방향에서 오른쪽에 있는 경우|$(\vec{f} \times \vec{v}) \cdot \vec{y} < 0$|
|물체가 정확히 시선 방향과 일치하는 경우|$(\vec{f} \times \vec{v}) = 0$|

이러한 좌우 방향 판별에 사용되는 외적의 응용은 $\sin$ 함수에 비례하는 외적의 성질에 기인한다.   
반면 내적은 $\cos$ 함수에 비례하기 때문에 앞뒤 방향 판별에 사용된다.    
[그림 9-9](#그림-9-9-삼각함수에-비례하는-내적a과-외적b이-가지는-부호-영역)의 (a)는 두 벡터의 사잇각이 $\cos$ 함수에 비례하는 내적의 부호 영역이고, (b)는 $\sin$ 함수에 비례하는 외적의 부호 영역이다.

###### 그림 9-9 삼각함수에 비례하는 내적(a)과 외적(b)이 가지는 부호 영역
![삼각함수에 비례하는 내적(a)과 외적(b)이 가지는 부호 영역](/img/)

[표 9-1](#표-9-1-벡터의-내적과-외적의-차이1)과 [표 9-2](#표-9-2-벡터의-내적과-외적의-차이2)에 이어 내적에 대비되는 외적의 성질은 [표 9-4](#표-9-4-벡터의-내적과-외적의-차이3)와 같다.

###### 표 9-4 벡터의 내적과 외적의 차이(3)

||내적|외적|
|---|---|---|
|방향 판별|앞, 뒤|왼쪽, 오른쪽|

# 30. 벡터로부터 회전행렬 생성
임의로 주어진 ***두 벡터에 직교하는 벡터를 생성하는 외적의 성질***은 ***카메라의 회전을 설정하는 데도 사용***된다.      
[그림 9-10](#그림-9-10-물체를-바라보는-카메라의-설정)과 같이 3차원 공간에서 좌우로 기울어지지 않은 카메라가 아래쪽에 위치한 물체를 바라보고 있는 상황을 설정한다.

###### 그림 9-10 물체를 바라보는 카메라의 설정
![물체를 바라보는 카메라의 설정](/img/)

오일러 각 방식을 사용해 카메라의 회전을 지정할 수 있지만, 외적을 사용하면 ***카메라의 시선 벡터 정보로부터 카메라의 세 가지 로컬 축을 구하고 이로부터 회전행렬까지 얻어낼 수 있다***.

[그림 9-11](#그림-9-11-카메라의-로컬-z축-구하기)처럼 물체의 위치에서 카메라 위치를 뺀 후 크기를 1로 정규화시킨 시선 벡터 $\vec{v}$를 생성한다.   
이 벡터는 카메라 트랜스폼의 로컬 $z$축이 된다.

###### 그림 9-11 카메라의 로컬 z축 구하기
![카메라의 로컬 z축 구하기](/img/)
 
카메라의 로컬 $x$축은 [그림 9-12](#그림-9-12-카메라의-로컬-x축-구하기)에 보이는 것처럼 ***업벡터(Up vector)*** 라고도 불리는 월드 공간의 $y$축과 카메라의 로컬 $z$축을 외적하면 얻을 수 있다.

월드 공간의 $y$축을 벡터 $\vec{u}$로 표시하고 이를 카메라의 로컬 $z$축과 외적한 후 이를 정규화시키면 카메라의 로컬 $x$축이 구해진다.

###### 그림 9-12 카메라의 로컬 x축 구하기
![카메라의 로컬 x축 구하기](/img/)

로컬 $z$축과 로컬 $x$축을 외적하면 [그림 9-13](#그림-9-13-뷰-공간의-최종-y축-기저벡터)과 같이 마지막 남은 로컬 $y$축을 구할 수 있다.     
이때는 ***두 벡터가 단위 벡터이므로 외적의 결과도 단위 벡터가 된다***.

###### 그림 9-13 뷰 공간의 최종 y축 기저벡터
![뷰 공간의 최종 y축 기저벡터](/img/)

정리하면 카메라가 바라보는 시선 벡터 $\vec{v}$와 주어지는 업벡터 $\vec{u}$로부터 로컬 공간을 구성하는 세 기저벡터 $\vec{x}$, $\vec{y}$, $\vec{z}$를 다음과 같이 구할 수 있다.

$$\vec{x} = \frac{\vec{u} \times \vec{z}}{|\vec{u} \times \vec{z}|}$$

$$\vec{y} = \vec{z} \times \vec{x}$$

$$\vec{z} = \frac{\vec{v}}{|\vec{v}|}$$

카메라 트랜스폼의 회전행렬 $R$은 로컬 벡터를 열벡터로 지정해 다음과 같이 생성할 수 있다.

$$R = 
\begin{bmatrix}
x_x & y_x & z_x & 0 \\
x_y & y_y & z_y & 0 \\
x_z & y_z & z_z & 0 \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
$$

시선 벡터로부터 카메라의 로컬 축을 계산하는 데 있어 추가로 고려해야 할 예외 상황이 있다.    
그 중 하나는 카메라의 위쪽 방향이다.    
앞서 살펴본 방법은 카메라의 위쪽 방향이 월드 공간의 $y$축을 향한다고 가정한다.  
하지만 [그림 9-14](#그림-9-14-거꾸로-뒤집힌-카메라의-뷰-공간)와 같이 카메라가 거꾸로 뒤집혀 있는 상황이라면, 로컬 $x$축을 구하기 위한 업벡터로 월드 공간 $y$축의 반대 방향인 $(0, -1, 0)$을 사용해야 한다.

###### 그림 9-14 거꾸로 뒤집힌 카메라의 뷰 공간
![거꾸로 뒤집힌 카메라의 뷰 공간](/img/)

일반적인 상황에서는 카메라가 위를 향해 세워져 있겠지만, 그렇지 않은 경우도 간혹 발생할 수 있으니 외적에 사용될 업벡터의 값을 입력받도록 설계하는 것이 안전하다.

그다음 고려할 예외 상황으로는 [그림 9-14](#그림-9-14-거꾸로-뒤집힌-카메라의-뷰-공간)와 같이 로컬 $z$축이 업벡터와 평행한 때다.     
두 벡터가 평행하면 외적 결과가 영벡터가 되어 더 이상 계산을 진행할 수가 없다.   
이 경우에는 외적을 계산하는 대신, 로컬 $z$축에 직교하는 로컬 $x$축의 값을 수동으로 지정해야 한다.

###### 그림 9-15 카메라의 시선 방향이 월드 공간 y축과 평행한 경우
![카메라의 시선 방향이 월드 공간 y축과 평행한 경우](/img/)

# 31. 렌더링 계산량을 줄여주는 백페이스 컬링
게임은 실시간으로 빠르게 렌더링을 처리해야 하기 때문에 시선에 감지되지 않는 ***메시(Mesh)*** 의 ***뒷면(Backface)*** 은 그리지 않고 건너뛰는 것이 효과적이다.     
이렇게 카메라와 마주보지 않는 뒷면을 생략하는 기법을 ***백페이스 컬링(Backface culling)*** 이라고 한다.    
백페이스 컬링은 메시의 삼각형을 구성하는 세 정점의 외적을 활용해 구현할 수 있다.    
[그림 9-16](#그림-9-16-정점-버퍼와-인덱스-버퍼)과 같이 삼각형을 구성하는 메시 데이터가 설정된 상황을 설정한다.

###### 그림 9-16 정점 버퍼와 인덱스 버퍼
![정점 버퍼와 인덱스 버퍼](/img/)

삼각형의 세 점을 지정하는 인덱스 버퍼에는 점의 순서가 나열되어 있다.    
이를 활용한다면 삼각형의 방향을 지정하지 않아도 외적을 사용해 삼각형이 향하는 방향을 파악할 수 있다.    
[그림 9-17](#그림-9-17-점의-순서에-따른-면의-방향의-결정)는 인덱스 버퍼의 순서에 따라 삼각형의 방향이 어떻게 결정되는지를 정리한다.   
(a)는 ***시계 방향으로 정점이 나열되어 있으므로 삼각형이 향하는 방향은 지면의 뒤편***을 향하게 되고, (b)는 ***반시계 방향으로 정점이 나열되어 있어서 지면***을 향한다.

###### 그림 9-17 점의 순서에 따른 면의 방향의 결정
![점의 순서에 따른 면의 방향의 결정](/img/)

이렇게 정한 삼각형의 방향과 카메라의 시선 방향을 대조해 ***서로 마주보면 삼각형을 그리고, 같은 방향을 바라보면 그리기를 생략하는 것이 백페이스 컬링의 알고리즘***이다.    
(a)는 삼각형의 방향과 카메라의 시선 방향이 같은 방향을 향하고 있다.     
따라서 해당 삼각형은 그리기를 생략해 렌더링 계산량을 줄일 수 있다.      
(b)는 삼각형의 방향과 카메라의 시선 방향이 마주보고 있다.   
따라서 해당 삼각형은 그려준다.

###### 그림 9-18 백페이스 컬링의 원리
![백페이스 컬링의 원리](/img/)

# 32. 오일러 각의 문제를 해결하는 로드리게스 회전 공식
3차원 회전을 관리하기 위해 오일러 각을 사용하고 있지만, ***오일러 각은 짐벌락 현상이 발생하고, 회전 보간이 어렵다***는 문제가 있다.   
오일러 각의 문제는 임의의 축에 대한 평면의 회전 방식을 사용하면 해결이 가능하다.    
이 방식을 ***각-축 회전(Axis-Angle rotation)*** 이라 부르는데, [그림 9-19](#그림-9-19-임의의-축에-대한-회전의-개요)과 같이 3차원 공간에서 지정된 임의의 축에 직교하는 평면에서 회전이 진행되는 형태를 띤다.

###### 그림 9-19 임의의 축에 대한 회전의 개요
![임의의 축에 대한 회전의 개요](/img/)

축-각 회전을 수행하는 회전 공식을 내적과 외적을 사용해 직접 유도한다.   
이를 위해 [그림 9-20](#그림-9-20-회전-평면의-설정)과 같이 관련된 점과 벡터에 각각 기호를 붙인다.     
***회전축은 회전이 발생하는 평면에 직교하는 법선 벡터다***.   
이를 벡터 $\vec{n}$으로 지정하고 편의를 위해 크기를 1로 정규화시킨다.   
회전시킬 점을 $P$, 점 $P$가 각 $\theta$만큼 회전한 최종 점을 $P'$으로 표기하고, 월드 공간의 원점을 $O$로, 회전 평면의 중심점을 $O'$으로 지정한다.    
이때 점 $P$의 좌표는 다음과 같이 설정한다.

###### 그림 9-20 회전 평면의 설정
![회전 평면의 설정](/img/)

원점 $O$에서부터 회전시킬 점 $P$까지의 벡터를 $\vec{u}$로 지정한다.     
점 $P$와 벡터 $\vec{u}$의 값은 마지막 차원의 값만 다를 뿐 $(x, y, z)$의 값은 동일하다.  
따라서 구해야할 점 $P'$의 좌표는 벡터 $\vec{u}$를 구해서 얻을 수 있다.

$$\vec{u} = P - O = (x, y, z, 0)$$

임의의 축 $\hat{n}$에 대해 벡터 $\vec{u}$를 각 $\theta$만큼 회전시켜 벡터 $\vec{u'}$을 계산하는 축-각 회전의 공식은 다음과 같다.

###### 식 9-2

$$\vec{u'} = \cos \theta \cdot \vec{u} + (1 - \cos \theta) \cdot (\vec{u} \cdot \hat{n}) \cdot \hat{n} + \sin \theta \cdot (\hat{n} \times \vec{u})$$

원점에서 회전시킬 점으로 향하는 벡터 $\vec{u}$를 평면의 회전축에 해당하는 법선 벡터 $\hat{n}$에 투영한다.   
벡터 $\vec{u}$가 투영할 벡터 $\hat{n}$의 크기가 1이므로 투영 공식에 의해 벡터 $\vec{OO'}$의 값은 $(\vec{u} \cdot \hat{n}) \cdot \hat{n}$이 된다.    
[그림 9-21](#그림-9-21-벡터-내적의-투영-공식으로-구한-벡터-v)에서 보여지는 공간의 원점에서 회전 평면의 원점으로 향하는 벡터 $\vec{v}$는 다음과 같이 계산된다.

$$\vec{OO'} = \vec{v} = (\vec{u} \cdot \hat{n}) \cdot \hat{n}$$

###### 그림 9-21 벡터 내적의 투영 공식으로 구한 벡터 v
![벡터 내적의 투영 공식으로 구한 벡터 v](/img/)

회전 평면의 중점 $O'$에서 점 $P$으로 향하는 벡터 $\vec{O'P}$는 두 벡터의 차가 되므로 $\vec{u} - \vec{v}$가 된다.

$$\vec{O'P} = \vec{u} - \vec{v}$$

위에서 내려다본 회전 평면의 모습은 [그림 9-22](#그림-9-22-회전-평면에서의-회전)와 같다.  
이 평면의 벡터 $\vec{O'P}$를 각 $\theta$만큼 회전 시킨 벡터 $\vec{O'P'}$를 구해야 한다.

###### 그림 9-22 회전 평면에서의 회전
![회전 평면에서의 회전](/img/)

벡터 $\vec{O'P'}$를 가로 성분과 세로 성분으로 분리하면, 가로 성분에 해당하는 벡터는 [그림 9-23](#그림-9-23-회전한-점-p를-구하기-위한-가로-벡터의-계산)과 같이 벡터 $\vec{O'P}$에 $\cos \theta$를 곱해 얻을 수 있다.

###### 그림 9-23 회전한 점 P'를 구하기 위한 가로 벡터의 계산
![회전한 점 P'를 구하기 위한 가로 벡터의 계산](/img/)

세로 성분에 해당하는 벡터를 구하려면 같은 방향을 향하는 벡터가 필요한데 이는 [그림 9-24](#그림-9-24-벡터-op에-직교하는-벡터-oq)와 같이 법선 벡터 $\hat{n}$과 벡터 $\vec{O'P}$를 외적해 얻을 수 있다.   
이를 벡터 $\vec{O'Q}$로 지정한다면 벡터 $\vec{O'Q}$는 다음과 같이 구할 수 있다.

$$\vec{O'Q} = \hat{n} \times (\vec{u} - \vec{v})$$

###### 그림 9-24 벡터 O'P에 직교하는 벡터 O'Q
![벡터 O'P에 직교하는 벡터 O'Q](/img/)

벡터 $\vec{O'Q}$에 $\sin \theta$를 곱하면 세로 성분에 해당하는 벡터를 얻을 수 있다.     
두 벡터를 모두 얻었으니 다음의 수식으로 벡터 $\vec{O'P}$를 각 $\theta$만큼 회전한 벡터 $\vec{O'P'}$의 값을 얻게 된다.

$$\vec{O'P'} = \cos \theta \cdot \vec{O'P} + \sin \theta \cdot \vec{O'Q}$$

위 식을 벡터 $\hat{n}$, $\vec{u}$와 $\vec{v}$를 사용해 전개하면 다음과 같다.

$$\vec{O'P'}  = \cos \theta \cdot (\vec{u} - \vec{v}) + \sin \theta \cdot (\hat{n} \times (\vec{u} - \vec{v}))$$

분배 법칙을 적용해 이를 풀어 전개하면 다음과 같다.

$$\vec{O'P'} = \cos \theta \cdot (\vec{u} - \vec{v}) + \sin \theta \cdot (\hat{n} \times \vec{u} - \hat{n} \times \vec{v})$$

벡터 $\hat{n}$과 $\vec{v}$는 평행하므로 우변의 끝에 위치한 외적 $\hat{n} \times \vec{v}$의 값은 항상 영벡터가 된다.     
따라서 이 식은 다음과 같이 정리된다.

$$\vec{O'P'} = \cos \theta \cdot (\vec{u} - \vec{v}) + \sin \theta \cdot (\hat{n} \times \vec{u})$$

마지막으로 구해야할 최종 벡터 $\vec{OP'}$는 [그림 9-25](#그림-9-25-최종-벡터-op의-계산)와 같이 선분 $\vec{O'P'}$에 벡터 $\vec{v}$를 더해 얻을 수 있다.

###### 그림 9-25 최종 벡터 OP'의 계산
![최종 벡터 OP'의 계산](/img/)

이를 식으로 나타내면 다음과 같다.

$$\vec{OP'} = \vec{v} + \cos \theta \cdot (\vec{u} - \vec{v}) + \sin \theta \cdot (\hat{n} \times \vec{u})$$

이제 벡터 $\vec{v}$를 $(\vec{u} \cdot \hat{n}) \cdot \hat{n}$로 치환하면 [식 9-2](#식-9-2)의 최종 수식이 유도된다.

$$\vec{u'} = \cos \theta \cdot \vec{u} + (1 - \cos \theta)(\vec{u} \cdot \hat{n}) \cdot \hat{n} + \sin \theta \cdot (\hat{n} \times \vec{u})$$

위 공식은 1840년에 프랑스 수학자 로드리게스(Olinde Rodrigues)가 발표했으며, 그의 이름을 인용해 ***로드리게스 회전 공식(Rodrigues' rotation formula)*** 이라고 한다.

# 33. 삼중곱
벡터의 외적과 내적을 두 번 연속 사용하는 연산을 ***삼중곱(Triple product)*** 이라고 한다.  
두 연산이 연속으로 사용되는 삼중곱의 식을 세우려면 세 개의 벡터 $\vec{u}$, $\vec{v}$, $\vec{w}$가 필요하며, 내적과 외적의 순서에 따라 다음과 같은 경우의 수가 발생한다.

1. $\vec{u} \cdot (\vec{v} \cdot \vec{w})$
2. $\vec{u} \cdot (\vec{v} \times \vec{w})$
3. $\vec{u} \times (\vec{v} \cdot \vec{w})$
4. $\vec{u} \times (\vec{v} \times \vec{w})$

1번 연산에서 괄호 안의 벡터 내적의 결괏값은 스칼라가 되므로 해당 삼중곱은 벡터를 세 번 곱했다고 보기 어렵다.    
3번 연산의 경우 벡터와 스칼라는 외적할 수 없으므로 연산이 불가능하다.   
이 두 경우는 제외되므로 2번과 4번만이 유효한 삼중곱 연산이 된다.

# 33.1. 스칼라 삼중곱
2번 삼중곱 연산($\vec{u} \cdot (\vec{v} \times \vec{w})$)은 4번 삼중곱 연산($\vec{u} \times (\vec{v} \times \vec{w})$)과 구분하기 위해 별도로 ***스칼라 삼중곱(Scalar triple product)*** 이라고 부른다.    
***왼쪽과 오른쪽의 판별 방법과 백페이스 컬링에 사용한 공식이 모두 스칼라 삼중곱이다***.

$$\hat{y} \cdot (\vec{f} \times \vec{v})$$

$$-\hat{z} \cdot (\vec{P_0P_1} \times \vec{P_0P_2})$$

외적으로 만든 벡터의 크기는 두 벡터가 이루는 평행사변형의 크기임과 동시에 외적으로 만들어진 법선 벡터의 크기다.     
이를 표현하면 [그림 9-26](#그림-9-26-외적의-크기)과 같다.

###### 그림 9-26 외적의 크기
![외적의 크기](/img/)

이 상황에서 임의의 벡터 $\vec{u}$의 크기를 법선 벡터 $\vec{v} \times \vec{w}$에 수직으로 투영한 벡터의 높이는 [그림 9-27](#그림-9-27-법선-벡터에-투영한-벡터의-크기)처럼 $\cos$ 함수에 비례한다.

###### 그림 9-27 법선 벡터에 투영한 벡터의 크기
![법선 벡터에 투영한 벡터의 크기](/img/)

높이 $|\vec{u}|\cos \theta$에 평행사변형의 넓이 $|\vec{v} \times \vec{w}|$를 곱하면 [그림 9-28](#그림-9-28-육면체의-부피)에서 볼 수 있는 육면체의 부피가 나온다.

###### 그림 9-28 육면체의 부피
![육면체의 부피](/img/)

이는 ***스칼라 삼중곱이 만들어내는 값의 절댓값과 동일***하다.

$$|\vec{u}||\vec{v} \times \vec{w}|\cos\theta = |\vec{u} \cdot (\vec{v} \times \vec{w})|$$

따라서 스칼라 삼중곱의 절댓값은 세 벡터 $\vec{u}$, $\vec{v}$, $\vec{w}$가 만드는 ***평행육면체(Parallelepiped)*** 의 부피를 의미하며, 이러한 평행육면체는 [그림 9-29](#그림-9-29-세-벡터로-구성된-평행육면체)의 형태를 이룬다.

###### 그림 9-29 세 벡터로 구성된 평행육면체
![세 벡터로 구성된 평행육면체](/img/)

위 세 벡터에서 ***바닥에 해당하는 두 벡터를 다른 벡터로 변경해도 최종 육면체의 부피 값은 변하지 않으므로 삼중곱의 결과는 동일***하다.     
이는 [그림 9-30](#그림-9-30-순서를-바꿔도-결과는-같은-스칼라-삼중곱의-예시)과 같이 표현할 수 있다.

###### 그림 9-30 순서를 바꿔도 결과는 같은 스칼라 삼중곱의 예시
![순서를 바꿔도 결과는 같은 스칼라 삼중곱의 예시](/img/)

부호에 유의해 벡터 $\vec{u}$, $\vec{v}$, $\vec{w}$가 만들어내는 스칼라 삼중곱은 다음과 같은 성질을 가진다.

$$\vec{u} \cdot (\vec{v} \times \vec{w}) = \vec{v} \cdot (\vec{w} \times \vec{u}) = \vec{w} \cdot (\vec{u} \times \vec{v})$$

이러한 성질을 가진 ***스칼라 삼중곱은 세 벡터의 선형 관계를 파악하는 데 사용***된다.

***외적으로 생성된 벡터의 크기는 두 벡터가 만드는 평행 사변형의 넓이와 동일함***을 알 수 있고, 이는 ***행렬식의 절댓값과 동일***하다.   
***행렬식은 평면에서 평행사변형을 이루는 두 벡터가 서로 선형 독립의 관계를 가지는지 판단하는 수식***이다.     
이와 동일한 관점에서 ***스칼라 삼중곱은 3차원 공간의 세 벡터가 모두 선형 독립의 관계를 가지는지 판단하는 판별식***으로 생각할 수 있다.    
삼중곱의 값이 0이 나오는 경우는 (a)와 같이 평면을 이루는 두 벡터 $\vec{v}$와 $\vec{w}$가 평행이거나, (b)와 같이 두 벡터 $\vec{v}$와 $\vec{w}$가 만드는 평면에 벡터 $\vec{u}$가 속하는 경우다.

###### 그림 9-31 세 벡터가 모두 선형 독립이 아닌 경우
![세 벡터가 모두 선형 독립이 아닌 경우](/img/)

(a)의 경우 외적의 결과가 영벡터가 되므로 스칼라 삼중곱의 값은 0이 된다.     
(b)의 경우 외적의 결과로 만들어진 법선 벡터에 벡터 $\vec{u}$는 직교하므로 이의 내적은 0이 된다.     
따라서 ***스칼라 삼중곱이 0이 아니면 세 벡터는 모두 선형 독립의 관계를 가짐***을 알 수 있다.

# 33.2. 벡터 삼중곱
세 벡터의 외적으로 구성된 삼중곱 $\vec{u} \times (\vec{v} \times \vec{w})$을 ***벡터 삼중곱(Vector triple product)*** 이라고 한다.     
벡터 삼중곱은 다음과 같은 성질을 지닌다.

###### 식 9-3

$$\vec{u} \times (\vec{v} \times \vec{w}) = (\vec{u} \cdot \vec{w}) \cdot \vec{v} - (\vec{u} \cdot \vec{v}) \cdot \vec{w}$$

이를 ***삼중곱 전개(Triple product expansion)*** 또는 ***라그랑주 공식(Largrange's formula)*** 이라고 한다.      
좌변의 식 $\vec{u} \times (\vec{v} \times \vec{w})$의 최종 연산은 외적이므로 이의 결과는 벡터로 나옴을 알 수 있다.      
이때 최종 벡터의 $x$ 성분만 먼저 전개한다.      
먼저 $\vec{v} \times \vec{w}$의 외적을 계산하는 식은 다음과 같다.

$$\vec{v} \times \vec{w} = (v_yw_z - w_yv_z, v_zw_x - w_zv_x, v_xw_y - w_xv_y)$$

여기서 외적의 $x$ 요소에는 $\vec{u}$ 벡터와 $(\vec{v} \times \vec{w})$ 벡터의 $y$ 성분과 $z$ 성분만 사용된다.   
$\vec{u} \times (\vec{v} \times \vec{w})$로 만들어지는 $x$ 성분을 전개한다.     
이는 $v_x(\vec{u} \cdot \vec{w}) - w_x(\vec{u} \cdot \vec{v})$의 내적식으로 간단하게 정리된다.

$$
\begin{matrix}
(\vec{u} \times (\vec{v} \times \vec{w}))_x &=& u_y(v_xw_y - w_xv_y) - (v_zw_x - w_zv_x)u_z \\
&=& v_x(u_yw_y + u_zw_z) - w_x(u_yv_y + u_zv_z) \\
&=& v_x(u_yw_y + u_zw_z) - w_x(u_yv_y + u_zv_z) + v_xu_xw_x - v_xu_xw_x \\
&=& v_x(u_xw_x + u_yw_y + u_zw_z) - w_x(u_xv_x + u_yv_y + u_zv_z) \\
&=& v_x(\vec{u} \cdot \vec{w}) - w_x(\vec{u} \cdot \vec{v}) \\
\end{matrix}
$$

0의 값을 가지는 수식 $+ v_xu_xw_x - v_xu_xw_x$을 추가한다.

나머지 두 개의 성분도 동일한 방식으로 전개할 수 있으며, 이 결과를 정리하면 다음과 같다.

$$(\vec{u} \times (\vec{v} \times \vec{w}))_y = v_y(\vec{u} \cdot \vec{w}) - w_y(\vec{u} \cdot \vec{v})$$

$$(\vec{u} \times (\vec{v} \times \vec{w}))_z = v_z(\vec{u} \cdot \vec{w}) - w_z(\vec{u} \cdot \vec{v})$$

위 결과를 종합하면 [식 9-3](#식-9-3)이 유도됨을 확인할 수 있다.     
***벡터 삼중곱은 다소 복잡한 외적을 두 개의 내적 연산으로 변환한다***는 특징을 지닌다.    
이 식의 우변은 결국 $a\vec{v} + b\vec{w}$ 형태의 ***선형 결합식***이므로 ***벡터 삼중곱으로 만들어지는 벡터***는 두 벡터 $\vec{v}$와 $\vec{w}$가 만드는 ***평면에 속함***을 알 수 있다.

###### 그림 9-32 벡터 삼중곱으로 만들어진 벡터의 결과
![벡터 삼중곱으로 만들어진 벡터의 결과](/img/)

> 참고  
3차원 공간의 연산 외적이 사용되는 벡터 삼중곱은 2차원 공간의 문제를 푸는 데도 유용하게 활용할 수 있다.      
2차원 평면의 벡터 $\vec{u}$와 동일한 평면에 위치한 임의의 벡터 $\vec{v}$가 주어졌을 때, 동일 평면에서 벡터 $\vec{u}$와 직교하는 벡터는 $(\vec{u} \times \vec{v}) \times \vec{u}$의 벡터 삼중곱을 사용해 구할 수 있다.
>
> ###### 그림 9-33 2차원 평면 위의 직교 벡터를 생성해주는 벡터 삼중곱 연산
> ![2차원 평면 위의 직교 벡터를 생성해주는 벡터 삼중곱 연산](/img/)

# 34. 원근 투영 변환의 원리
원근 기법은 르네상스 시대의 화가들에 의해 창안되었다.   
당시 르네상스 화가들은 눈에 보이는 상을 그대로 화폭에 담기 위해 [그림 10-1](#그림-10-1-알브레히트-뒤러의-틀과-실을-이용하여-단축법의-원리를-연구하는-화가)과 같이 시선을 한 점에 고정시키고, 고정된 점으로부터 화폭까지 곧게 뻗은 실을 활용해 그림을 그렸다.   
이러한 화법을 ***투시 원근법(Perpective projection drawing)*** 이라고 한다.

###### 그림 10-1 알브레히트 뒤러의 <틀과 실을 이용하여 단축법의 원리를 연구하는 화가>
![알브레히트 뒤러의 <틀과 실을 이용하여 단축법의 원리를 연구하는 화가>](/img/)

3차원 공간에 투시 원근법의 원리를 적용하기 위해서는, [그림 10-1](#그림-10-1-알브레히트-뒤러의-틀과-실을-이용하여-단축법의-원리를-연구하는-화가)과 같은 원리로 ***공간의 모든 점이 한 점을 향해 모이는 형태***로 변경해야 한다.    
이러한 변환을 ***원근 투영 변환(Perpective projection transformation)*** 이라고 부른다.

원근 투영 변환이란 사람의 눈이 바라보는 방식으로 가상 공간을 변환하는 것이다.   
가상 공간에서 눈에 대응하는 물체는 카메라다.    
원근 투영 변환을 설계하기 위해서는 ***눈에 보이는 범위*** 를 카메라에도 설정해야 하는데, 이를 ***화각(Field of view)*** 라고 한다.    
카메라에 화각을 설정하면 [그림 10-2](#그림-10-2-카메라-화각에-따라-변화된-공간의-모습)와 같이 ***좌우와 위아래가 균등한 사각뿔 영역***이 만들어진다.

###### 그림 10-2 카메라 화각에 따라 변화된 공간의 모습
![카메라 화각에 따라 변화된 공간의 모습](/img/)

원근 투영 변환은 $x$, $y$, $z$축이 모두 직교하는 ***정육면체 형태를 가진 뷰 공간***을 ***카메라의 한 점으로 모이는 사각뿔 형태를 가진 공간으로 변환하는 작업***이라고 할 수 있다.       
3차원 공간을 변환한 후에는 공간의 물체를 투영해 2차원의 모니터 평면에 담아내야 한다.    
이를 위해서 ***모든 물체의 상이 맺히는 가상의 평면***을 생성해야 하는데, 이를 ***투영 평면(Projection plane)*** 이라고 부른다.   
투영 평면의 개념은 [그림 10-3](#그림-10-3-투영-평면과-초점-거리)과 같으며 ***투영 평면의 위치가 카메라로부터 멀어질수록 투영 평면은 더 커진다***.   
투영 평면의 위치를 지정하기 위해 설정한 ***카메라로부터 투영 평면까지의 거리***를 ***초점 거리(Focal length)*** 라고 한다.

###### 그림 10-3 투영 평면과 초점 거리
![투영 평면과 초점 거리](/img/)

[그림 10-4](#그림-10-4-오른쪽에서-바라본-투영-공간과-투영-평면)에 투영 공간을 오른쪽에서 바라본 2차원 단면도로 정리하고 화각을 $\theta$, 초점 거리를 $d$로 표시했다.

###### 그림 10-4 오른쪽에서 바라본 투영 공간과 투영 평면
![오른쪽에서 바라본 투영 공간과 투영 평면](/img/)

원근 투영을 구현하기 위해서는 우선 투영 평면의 위치를 지정해야 한다.    
일반적으로 투영 평면의 위치는 계산의 편의를 위해 위 아래의 크기가 각각 1이 되는 지점으로 결정한다.      
좌우와 상하의 화각이 동일하므로 투영 평면은 [그림 10-5](#그림-10-5-투영-평면으로-생성되는-ndc-영역)와 같이 좌우와 상하가 되는 각각 $|-1, 1|$의 범위를 가지는 정사각형의 모습을 띠며 이 평면에 물체의 상이 맺힌다.   
투영 평면에 대응하는 정사각형 영역은 2차원 평면의 좌표시스템을 가지는데 이를 ***NDC(Normalized device coordinate)*** 라고 부르는데, ***NDC는 가운데 중점을 원점으로 설정한다***.

###### 그림 10-5 투영 평면으로 생성되는 NDC 영역
![투영 평면으로 생성되는 NDC 영역](/img/)

투영 평면에 대응하는 NDC가 언제나 일정한 값을 가져야 한다면, 카메라에 설정된 화각이 변할 때, 초점 거리는 달라질 수밖에 없다.    
***화각이 커질수록 초점 거리는 가까워지고 화각이 작아질수록 초점 거리는 멀어진다***.      
화각과 초점 거리의 관계는 [그림 10-6](#그림-10-6-화각과-초점거리의-관계)에 보이는 직각삼각형의 $\tan$ 함수로 설정된다.

$$\tan(\frac{\theta}{2}) = \frac{1}{d}$$

###### 그림 10-6 화각과 초점거리의 관계
![화각과 초점거리의 관계](/img/)

따라서 주어진 화각 $\theta$에 따른 초점 거리 $d$는 다음 식으로 계산할 수 있다.

###### 식 10-1

$$d = \frac{1}{\tan(\frac{\theta}{2})}$$

$\tan$ 함수를 사용해 초점 거리를 구했다면, ***뷰 공간의 점을 투영 평면 위의 점으로 대응시키는 원근 투영 변환***을 설계한다.  
행렬로 설계할 수 있다면 행렬 곱의 장점을 활용해 로컬 공간의 점을 투영 평면의 점으로 한 번에 변환해주는 파이프라인을 만들 수 있다.

***세 축이 모두 직교하는 공간***을 ***유클리드 공간(Euclidean space)*** 이라고 한다.     
***로컬 공간, 월드 공간, 뷰 공간***은 모두 유클리드 공간의 형태다.    
정육면체 형태의 유클리드 공간은 원근 투영 변환에 의해 [그림 10-2](#그림-10-2-카메라-화각에-따라-변화된-공간의-모습)와 같은 사각뿔 형태로 바뀌게 된다.   
이를 ***사영 공간(Projective space)*** 이라고 한다.

사영 공간의 $x$축과 $y$축은 여전히 직교하기 때문에 사영 공간의 $x$축과 $y$축은 유클리드 공간과 동일한 성질을 가진다.    
하지만 사영 공간의 $z$축은 독립적으로 행동하지 않고 $x$축과 $y$축에 모두 영향을 준다.   
이는 초점 거리에 따라 $x$축과 $y$축이 만들어내는 투영 평면의 면적이 달라지는 이유이기도 하다.

유클리드 공간이 사영 공간으로 변환되면서 $x$, $y$, $z$축이 모두 직교하는 체계가 달라지기 때문에 ***원근 투영 변환에 대응하는 행렬은 지금까지 사용한 표준기저벡터의 변화를 관찰하는 방법으로는 생성할 수 없다***.      
문제를 단순화시키기 위해 $x$축을 배제한 $y$축과 $z$축으로 공간을 설정하고 투영 평면에 상이 맺히는 과정을 생각해보면, 뷰 공간의 점 $P_{view}$가 투영 평면에 투영된 점을 $P_{ndc}$라고 할 때 투영 과정은 [그림 10-7](#그림-10-7-투영의-진행-과정)과 같이 진행된다.

###### 그림 10-7 투영의 진행 과정
![투영의 진행 과정](/img/)

뷰 공간의 점 $P_{view}$로부터 투영된 점 $P_{ndc}$의 좌표를 구해야 한다.     
$x$값을 0으로 고정한 상태이므로, 둘의 좌표는 다음과 같다.

$$P_{view} = (0, v_y, v_z)$$

$$P_{ndc} = (0, n_y)$$

두 점의 관계를 파악하기 위해 [그림 10-8](#그림-10-8-두-개의-닮은꼴-삼각형)과 같이 닮은꼴 삼각형 두 개를 그린다.   
뷰 공간에서 카메라 앞에 위치한 점의 $z$값은 항상 음수이므로 큰 삼각형의 밑변의 길이는 $-v_z$가 된다.

###### 그림 10-8 두 개의 닮은꼴 삼각형
![두 개의 닮은꼴 삼각형](/img/)

두 삼각형의 닮은꼴 성질로부터 다음의 비가 성립된다.

$$n_y:d = v_y:-v_z$$

이로써 투영 평면의 $y$값 $n_y$은 다음 식으로 얻을 수 있다.

$$n_y = \frac{d \cdot v_y}{-v_z}$$

카메라의 좌우와 상하의 시야각은 동일하므로 $NDC$의 $x$값 또한 $y$값을 0으로 고정한 후 $x$축과 $z$축의 평면을 사용하는 방식으로 구할 수 있다.

$$n_x = \frac{d \cdot v_x}{-v_z}$$

따라서 초점거리와 뷰 좌표로부터 $P_{ndc}$는 다음과 같이 구할 수 있다.

$$P_{ndc} = (n_x, n_y) = (\frac{d \cdot v_x}{-v_z}, \frac{d \cdot v_y}{-v_z}) = -\frac{d}{v_z}(v_x, v_y)$$

NDC 좌표를 계산했다면 모니터의 최종 화면을 구성하는 작업이 남았다.    
[그림 10-9](#그림-10-9-ndc에서-화면-공간으로의-변환)와 같이 NDC 좌표를 화면 해상도만큼 가로와 세로를 늘려주면 최종 스크린 좌표가 완성된다.   

###### 그림 10-9 NDC에서 화면 공간으로의 변환
![NDC에서 화면 공간으로의 변환](/img/)

[그림 10-9](#그림-10-9-ndc에서-화면-공간으로의-변환)와 같은 방법으로 가로와 세로를 늘리면 물체가 찌그러지는 문제가 발생한다.     
대부분의 경우 최종 화면의 크기 비율이 1:1로 균등하지 않기 때문이다.     
예를 들어 [그림 10-10](#그림-10-10-종횡비를-고려하지-않고-확대하는-경우-발생하는-문제)과 같이 NDC 영역에 원의 상이 투영됐는데, 화면 해상도에 따라 가로와 세로를 다른 비율로 늘리면 사용자가 보는 최종 화면에서는 찌그러진 타원이 보이게 된다.

###### 그림 10-10 종횡비를 고려하지 않고 확대하는 경우 발생하는 문제
![종횡비를 고려하지 않고 확대하는 경우 발생하는 문제](/img/)

문제의 원인이 되는 ***화면의 가로 세로 비***를 ***종횡비(Aspect ratio)*** 라고 한다.     
모니터 화면은 보통 16:10이나 4:3처럼 가로 세로 비율이 다르다.

이 문제를 해결하는 방법은 화면의 종횡비를 미리 파악해, NDC 영역에서 미리 찌그러트린 후에 펼치는 것이다.     
[그림 10-11](#그림-10-11-종횡비를-고려해-처리하는-방법의-예시)의 (a)와 같이 NDC에 원을 투영할 때 종횡비를 거꾸로 뒤집은 비율을 적용해 먼저 찌그러트린다.      
그러면 (b)와 같이 사용자 화면에 펼칠 때 원이 올바르게 보인다.

###### 그림 10-11 종횡비를 고려해 처리하는 방법의 예시
![종횡비를 고려해 처리하는 방법의 예시](/img/)

종횡비는 보통 하나의 축을 1의 크기로 지정하고 다른 축의 크기를 상대적으로 측정해 나타낸다.      

NDC의 투영 결과를 찌그러트린다.     
좌우로 찌그러트리려면 $x$축 값을 변경해야 하는데, 이는 종횡비의 역수$\frac{1}{a}$을 곱하면 된다.    
따라서 NDC 좌표 $P_{ndc}$를 계산하는 공식은 다음과 같이 수정된다.

$$P_{ndc} = -\frac{d}{v_z}(\frac{v_x}{a}, v_y)$$

따라서 최종 NDC 값을 계산하는 원근 투영 행렬 $P$는 다음과 같이 설계할 수 있다.      
뷰 공간의 점 $P_{view}$의 $x$값과 $y$값으로 만든 벡터를 $\vec{v} = (v_x, v_y)$로 지정하면 $P_{ndc}$의 두 점의 좌표는 다음과 같이 계산할 수 있다.

$$P_{ndc} = P \cdot \vec{v} = 
\begin{bmatrix}
\frac{1}{a} \cdot \frac{d}{-v_z} & 0 \\
0 & \frac{d}{-v_z} \\
\end{bmatrix} \cdot 
\begin{bmatrix}
v_x \\
v_y \\
\end{bmatrix}
$$

이렇게 만들어진 원근 투영 행렬을 사용한다고 할 때, 변환할 점의 $z$값이 행렬에 사용되다 보니 ***변환할 점마다 항상 행렬을 새롭게 생성***해야 한다.

***행렬의 가장 큰 장점은 모든 변환의 행렬을 미리 곱해둔 행렬을 적용함으로써 반복되는 연산량을 줄이는 것이다***.   
하지만 이렇게 원근 투영 행렬에 변환할 점의 값이 사용되면 행렬을 사용하는 장점이 사라진다.   
따라서 원근 투영 행렬을 구성할 때 점의 값을 사용하지 않고 카메라 설정만으로 행렬을 만들 수 있어야 한다.

유도한 투영 행렬을 살펴보면, 행렬의 구성 요소는 모두 $-v_z$값을 분모로 한다.    
행렬에서 $-v_z$값을 제거하고, 대신 행렬의 결괏값에서 $-v_z$를 나누어줄 수 있다.

NDC값을 만들어내는 과정을 두 단계로 분리한다.   
첫 번째로는 앞서 설계한 원근 투영 행렬 $P$를 다음과 같이 변경하고 행렬에 곱하는 벡터의 값을 $\vec{v} = (v_x, v_y, v_z)$로 지정한다.     
벡터 $\vec{v}$는 뷰 좌표계의 점과 동일한 값을 가진다.

$$P \cdot \vec{v} = 
\begin{bmatrix}
\frac{d}{a} & 0 & 0 \\
0 & d & 0 \\
0 & 0 & 1 \\
\end{bmatrix}
\begin{bmatrix}
v_x \\
v_y \\
v_z \\
\end{bmatrix} = 
\begin{bmatrix}
\frac{d}{a} \cdot v_x \\
d \cdot v_y \\
-v_z \\
\end{bmatrix}
$$

이 행렬 곱에서 생성된 벡터는 얻어야 할 NDC 좌표와는 다르지만 원근 투영 행렬 $P$는 점과 무관하게 카메라 설정 값으로만 구성된다.      
그렇다면 모든 점에 대해서 보편적으로 설계된 원근 투영 행렬 $P$를 사용할 수 있다.    
이렇게 원근 투영 행렬 $P$로 변환되는 좌표계를 ***클립 좌표(Clip coordinate)*** 라고 부르며 클립 좌표의 점 $P_{clip}$은 다음과 같이 계산된다.

$$P_{clip} = (\frac{d \cdot v_x}{a}, d \cdot v_y, -v_z)$$

두 번째로는 클립 좌표의 점 $P_{clip}$의 각 요소를 $P_{clip}$의 세 번째 값인 $-v_z$로 나눈다.    
그러면 NDC의 좌표를 얻을 수 있다.

$$P_{ndc} = (\frac{d \cdot v_x}{-v_z \cdot a}, \frac{d \cdot v_y}{-v_z}, 1)$$

# 35. 동차 좌표계
***NDC는 2차원 평면의 좌표***지만, ***모든 점에 사용 가능한 원근 투영 행렬을 사용***하도록 ***계산 과정을 두 단계로 구분***하고, ***사용하는 벡터의 값도 한 차원 높다***.    
이렇게 한 차원 높인 벡터를 사용하는 것을 게임 제작에서는 보통 ***동차 좌표계(Homogenous coordinate system)*** 를 사용한다고 표현한다.      
***동차 좌표계의 동차는 모든 항의 차수가 같음의 의미***하는 수학 용어다.  

[그림 10-12](#그림-10-12-사영-공간에서-점이-평행-이동할-때-투영된-점의-변화)와 같이 형성된 3차원의 사영 공간에서 평행하게 점을 이동시키면서 평면에 투영된 좌푯값이 어떻게 바뀌는지 관찰할 수 있다.    
사영 공간의 점과 투영된 점의 좌표는 카메라로부터 멀어질수록 원점에 가까워지고, 카메라에 가까워질수록 커지는 ***반비례 관계***를 가진다.

###### 그림 10-12 사영 공간에서 점이 평행 이동할 때 투영된 점의 변화
![사영 공간에서 점이 평행 이동할 때 투영된 점의 변화](/img/)

3차원 사영 공간의 점을 $(x', y', z')$로 표기하고 해당 점이 투영된 NDC 좌표를 $(x, y)$로 표기한다.   
NDC 좌푯값은 사영 공간의 마지막 차원 값 $z'$에 반비례로 영향을 받으므로 다음과 같은 관계가 성립한다.

###### 식 10-2

$$x = \frac{x'}{z'} \quad y = \frac{y'}{z'}$$

NDC 공간에서 [그림 10-13](#그림-10-13-ndc-좌표에서의-직선-방정식)과 같은 직선의 방정식 $y = ax + b$를 생각해보며, 화면에 보이는 NDC 공간의 직선이 사영 공간의 점들이 투영되어 만들어졌다고 가정한다.

###### 그림 10-13 NDC 좌표에서의 직선 방정식
![NDC 좌표에서의 직선 방정식](/img/)

직선의 방정식을 사영 공간의 좌표로 표현한다.    
[식 10-2](#식-10-2)를 참고해 $x$와 $y$를 치환하면 사영 공간의 좌표로 표기한 직선의 방정식은 다음과 같다.

$$\frac{y'}{z'} = a\frac{x'}{z'} + b$$

이 식의 양번에 $z'$를 곱하면 상수가 사라지고 세 미지수의 차수가 모두 1차식으로 동일한 수식이 구성된다.

$$y' = ax' + bz'$$

이렇게 ***미지수에 대한 차수가 모두 동일한 방정식***을 ***동차 방정식***이라고 부르며, 이런 이유로 ***사영 공간이 사용하는 좌표계를 동차좌표계라고도 부른다***.   
원근 투영 행렬 $P$를 설계하기 위해 계산 과정을 두 단계로 나눠 진행했는데, 첫 번째 단계로 구한 좌표를 클립 좌표라고 부르며 이는 투영 되기 전의 사영 공간의 좌표를 의미한다.      
따라서 원근 투영 변환에서 등장한 ***사영 공간, 클립 공간, 동차 공간은 모두 동일한 공간***을 가리키고, 클립 좌표, 동차 좌표 역시 동일한 좌표계를 가리킨다.

[그림 10-12](#그림-10-12-사영-공간에서-점이-평행-이동할-때-투영된-점의-변화)를 다시 살펴보면, 사영 공간의 점이 카메라로부터 멀어질수록 투영된 NDC 좌푯값은 원점 $(0, 0)$에 가까워진다.      
NDC의 원점은 회화의 투시 원근 기법에서 이야기하는 ***소실점(Vanishing point)*** 에 해당한다.   

###### 그림 10-14 마인데르트 호베마의 <미델 하르니스의 가로수길>
![마인데르트 호베마의 <미델 하르니스의 가로수길>](/img/)

# 36. 깊이 값
원근 투영 행렬을 활용해 3차원의 물체를 원근감 있게 표현할 수 있다.  
그러나 물체에 텍스쳐를 입힌다면 추가로 고려할 사항이 발생한다.  
사용자에게 보이는 화면은 결국 2차원 평면이므로 나중에 그린 물체가 앞에 보일 수밖에 없다.    

이 문제를 해결하는 방법은, 물체가 카메라로부터 얼마나 떨어져 있는지에 대한 정보를 기록해 앞에 있는 물체를 나중에 그리도록 설정하는 것이다.  
이를 위해서는 ***카메라로부터 물체가 얼마나 떨어졌는지 파악할 수 있는 데이터***가 필요한데 이를 ***깊이(Depth)*** 값이라고 한다.    
2차원 평면이었던 NDC 영역에 깊이 값을 추가하면 [그림 10-15](#그림-10-15-3차원으로-확장된-ndc-영역)과 같은 3차원으로 NDC 영역이 확장된다.   
깊이 값의 범위는 동일하게 $|-1, 1|$로 설정했다.

###### 그림 10-15 3차원으로 확장된 NDC 영역
![3차원으로 확장된 NDC 영역](/img/)

***카메라에 부여한 시야각은 깊이와 무관***하기 때문에 카메라에 추가 속성을 부여해야 한다.     
이를 각각 ***근평면(Near plane)*** 과 ***원평면(Far plane)*** 이라고 한다.

카메라 시야를 구성하는 사영 공간을 근평면과 원평면으로 잘라주면 [그림 10-16](#그림-10-16-카메라에-설정한-절두체)과 같이 사각뿔에서 뾰족한 부분이 잘린 형태가 나오는데 이를 ***절두체(Frustum)*** 라고 한다.

###### 그림 10-16 카메라에 설정한 절두체
![카메라에 설정한 절두체](/img/)

절두체로 생성되는 3차원 NDC 영역의 범위는 [그림 10-17](#그림-10-17-3차원으로-확장한-ndc의-범위)과 같이 구성된다.     
NDC의 깊이 값은 멀어질수록 증가하기 때문에 ***3차원 NDC 공간은 왼손 좌표계를 형성***한다.

###### 그림 10-17 3차원으로 확장한 NDC의 범위
![3차원으로 확장한 NDC의 범위](/img/)

원근 투영 행렬은 다른 행렬과의 곱을 위해 $3 \times 3$ 크기의 행렬을 인위적으로 $4 \times 4$ 크기로 늘렸는데, 이제는 깊이 값을 계산할 수 있도록 모든 행렬을 알차게 활용할 수 있게 되었다.

기존 원근 투영 행렬의 3행을 4행으로 옮기고 3행은 깊이 값을 구하는 용도로 변경한다.  
뷰 공간의 점을 나타내는 $\vec{v}$의 값을 $(v_x, v_y, v_z, 1)$로 지정하면 원근 투영 행렬 $P$는 다음과 같이 구성된다.

$$P \cdot \vec{v} = 
\begin{bmatrix}
\frac{d}{a} & 0 & 0 & 0 \\
0 & d & 0 & 0 \\
i & j & k & l \\
0 & 0 & -1 & 0 \\
\end{bmatrix}
\begin{bmatrix}
v_x \\
v_y \\
v_z \\
1 \\
\end{bmatrix} =
\begin{bmatrix}
\frac{d}{a} \cdot v_x \\
d \cdot v_y \\
? \\
-v_z \\
\end{bmatrix}
$$

깊이 값을 계산하는 데 사용하는 3행은 네 개의 미지수 $i, j, k, l$로 지정한다.    
깊이 값은 뷰 좌표계의 $x$축과 $y$축에 각각 직교하므로 영향을 받지 않는다.   
그러므로 앞의 두 요소 $i$와 $j$값은 0으로 설정해야 한다.    
이제 3행에는 두 개의 미지수 $k$와 $l$이 남는데, 이를 구하기 위해서는 두 개의 샘플 데이터가 필요하다.

$$P \cdot \vec{v} =
\begin{bmatrix}
\frac{d}{a} & 0 & 0 & 0 \\
0 & d & 0 & 0 \\
0 & 0 & k & l \\
0 & 0 & -1 & 0 \\
\end{bmatrix}
\begin{bmatrix}
v_x \\
v_y \\
v_z \\
1 \\
\end{bmatrix} = 
\begin{bmatrix}
\frac{d}{a} \cdot v_x \\
d \cdot v_y \\
? \\
-v_z \\
\end{bmatrix}
$$

두 미지수를 얻기 위해 카메라에 설정된 근평면과 원평면의 값을 사용한다.      
카메라로부터 근평면까지의 거리를 $n$, 원평면까지의 거리를 $f$로 설정한다.   
카메라의 중심으로부터 시선 방향으로 $n$만큼 이동한 근평면 상에 위치한 점을 생각해보면, 뷰 공간에서 카메라 시선 방향은 $-z$축이므로 뷰 공간에서 이 점의 좌표는 $(0, 0, -n, 1)$이 된다.   
이는 깊이 값의 시작 지점이기 때문에 NDC 좌표 $(0, 0, -1)$에 대응한다.   
동일하게 뷰 공간의 원 평면상의 좌표는 $(0, 0, -f, 1)$인데, 이는 깊이 값의 끝지점이기 때문에 NDC 좌표 $(0, 0, 1)$에 대응한다.

***원근 투영 행렬에 뷰 공간의 점을 곱한 결과는 클립 좌표가 된다***.   
근평면의 점을 $P_1,$ 원평면의 점을 $P_2$라고 할 때 이들은 다음과 같이 계산된다.

$$P_1 = 
\begin{bmatrix}
\frac{d}{a} & 0 & 0 & 0 \\
0 & d & 0 & 0 \\
0 & 0 & k & l \\
0 & 0 & -1 & 0 \\
\end{bmatrix}
\begin{bmatrix}
0 \\
0 \\
-n \\
1 \\
\end{bmatrix} = 
\begin{bmatrix}
0 \\
0 \\
? \\
n \\
\end{bmatrix}
$$

$$P_2 = 
\begin{bmatrix}
\frac{d}{a} & 0 & 0 & 0 \\
0 & d & 0 & 0 \\
0 & 0 & k & l \\
0 & 0 & -1 & 0 \\
\end{bmatrix}
\begin{bmatrix}
0 \\
0 \\
-f \\
1 \\
\end{bmatrix} = 
\begin{bmatrix}
0 \\
0 \\
? \\
f \\
\end{bmatrix}
$$

원근 투영 행렬의 $k$와 $l$을 모르기 때문에 클립 좌표의 세 번째 요소를 계산할 수 없다.   
하지만 클립 좌표의 네 번째 요소로 모든 요소를 나눈 값은 NDC 좌표를 가리키고, NDC 좌표의 $z$값은 각각 -1과 1임을 알고 있다.  
따라서 근평면의 클립 좌표는 $(0, 0, -n, n)$이 되고, 원평면의 클립 좌표는 $(0, 0, f, f)$이 되어야 한다.  
[그림 10-18](#그림-10-18-뷰-공간의-좌표와-ndc-값의-비교)은 근평면과 원평면의 위치를 세 가지 좌표로 표현한 예시다.

###### 그림 10-18 뷰 공간의 좌표와 NDC 값의 비교
![뷰 공간의 좌표와 NDC 값의 비교](/img/)

따라서 다음 식을 얻을 수 있다.

$$P_1 = 
\begin{bmatrix}
\frac{d}{a} & 0 & 0 & 0 \\
0 & d & 0 & 0 \\
0 & 0 & k & l \\
0 & 0 & -1 & 0 \\
\end{bmatrix}
\begin{bmatrix}
0 \\
0 \\
-n \\
1 \\
\end{bmatrix} = 
\begin{bmatrix}
0 \\
0 \\
-n \\
n \\
\end{bmatrix}
$$

$$P_2 = 
\begin{bmatrix}
\frac{d}{a} & 0 & 0 & 0 \\
0 & d & 0 & 0 \\
0 & 0 & k & l \\
0 & 0 & -1 & 0 \\
\end{bmatrix}
\begin{bmatrix}
0 \\
0 \\
-f \\
1 \\
\end{bmatrix} = 
\begin{bmatrix}
0 \\
0 \\
f \\
f \\
\end{bmatrix}$$

두 행렬의 3행과 뷰 공간의 점을 내적하면 다음 두 식을 얻을 수 있다.

$$-kn + l = -n$$

$$-kf + l = f$$

$n$과 $f$는 카메라에 설정된 상수이므로 두 식을 서로 빼, $l$을 소거한 후 $k$값을 구하면 다음과 같다.

$$k = \frac{-(n + f)}{(-n + f)} = \frac{n + f}{n - f}$$

여기서 구한 $k$를 대입해 $l$을 계산한 결과는 다음과 같다.

$$l = \frac{2nf}{(n - f)}$$

깊이 값까지 산출해주는 최종 원근 투영 행렬 $P$는 다음과 같다.

$$P = 
\begin{bmatrix}
\frac{d}{a} & 0 & 0 & 0 \\
0 & d & 0 & 0 \\
0 & 0 & \frac{n + f}{n - f} & \frac{2nf}{n - f} \\
0 & 0 & -1 & 0 \\
\end{bmatrix}
$$

이렇게 유도된 원근 투영 행렬은 ***모든 구성 요소가 카메라의 설정 값만 사용***하기 때문에 ***모든 점에 사용되는 렌더링 파이프라인의 행렬로 활용***할 수 있다.

# 37. 원근 보정 매핑
기존의 방식으로 각 픽셀의 무게중심좌표를 구한 후, 이로부터 UV 값을 계산하고 이에 대응하는 텍스처의 색상을 가져와 텍스처 매핑을 구현할 경우, 평행하게 그려져야 할 텍스처가 처지거나 올라가는 문제가 발생한다.

[그림 10-19](#그림-10-19-시야각에-걸쳐-있는-두-점과-이를-투영한-결과)는 투영 전과 투영 후의 과정을 보여준다.     
투영하기 전 사영 공간의 두 점 $P_1$과 $P_2$가 카메라 시야각에 걸쳐 있다고 가정한다.     
이를 투영 평면에 투영한 점 $N_1$과 $N_2$의 NDC 좌표의 $x$값은 각각 -1과 1이 된다.   
카메라 정면에 위치한 사영 공간의 점 $P_3$를 투영한 NDC 좌표의 점 $N_3$는 투영 평면의 정 중앙에 위치한다.

###### 그림 10-19 시야각에 걸쳐 있는 두 점과 이를 투영한 결과
![시야각에 걸쳐 있는 두 점과 이를 투영한 결과](/img/)

NDC 공간에서 점 $N_1$과 $N_2$를 이어 선분을 생성했을 때 선분의 중앙에 위치한 중점 $N_3$의 무게중심좌표는 0.5가 된다.

[그림 10-20](#그림-10-20-뷰-공간의-선을-수평으로-조정해-측정한-결과)과 같이 사영 공간의 선분 $\overline{P_1P_2}$ 내에 위치한 점 $P_3$의 무게중심좌표를 구하면 이는 0.5보다 작은 값임을 알 수 있다.

###### 그림 10-20 뷰 공간의 선을 수평으로 조정해 측정한 결과
![뷰 공간의 선을 수평으로 조정해 측정한 결과](/img/)

***사영 공간의 무게중심좌표와 NDC에서의 무게중심좌표는 서로 다르다***는 사실을 확인할 수 있다.    
이로 인해 ***텍스처가 처지거나 올라가 붙게 된다***.   
사영 공간의 무게중심좌표와 NDC에서의 무게중심좌표가 서로 차이 나는 이유는 NDC 공간으로의 변환 과정에서 사영 공간의 마지막 요소 $w$의 값 $-v_z$를 나눴기 때문이다.   
이는 ***사영 공간과 NDC 공간 사이에 형성된 반비례 관계로부터 기인***한다.

***NDC에서의 변경된 무게중심좌표를 사용하는 대신 투영되기 전 사영 공간에서의 무게중심좌표를 사용해야 한다***.     
따라서 ***투영 과정을 거꾸로 추적해 NDC에서 구한 무게중심좌표로부터 사영 공간의 무게중심좌표를 계산해야 한다***.  
이렇게 투영 전의 무게중심좌표 값을 계산해 텍스처를 매핑하는 것을 ***투영 보정 보간(Perspective correction interpolation)*** 이라고 한다.

NDC의 무게중심좌표를 사영 공간의 무게중심좌표로 돌려주는 투영 보정 보간의 계산식을 유도하기 위해서는 [그림 10-21](#그림-10-21-y---1x의-그래프)에 보이는 반비례 함수 $y = -\frac{1}{x}$이 가진 성질을 활용할 수 있다.

###### 그림 10-21 y = -1/x의 그래프
![y = -1/x의 그래프](/img/)

$y = -\frac{1}{x}$ 함수에서 $x$축에 위치한 세 수 2, 4, 6이 대응된 $y$값은 각각 $-\frac{1}{2}$, $-\frac{1}{4}$, $-\frac{1}{6}$이다.  
$x$축에 위치한 세 수 중에서 가운데 위치한 4의 무게중심좌표 $a$는 다음 식에 의해 0.5가 된다.

$$4 = a \cdot 2 + (1 - a) \cdot 6$$

4에 대응하는 $y$값 $-\frac{1}{4}$의 무게중심좌표를 구한다.  
다음 식에 의해 해당 값의 무게중심좌표는 0.25다.

$$-\frac{1}{4} = a \cdot -\frac{1}{2} + (1 - a) \cdot -\frac{1}{6}$$

$y$축의 무게중심좌표 0.25로부터 $x$축의 무게중심좌표 0.5를 계산해주는 식을 찾을 수 있다면, 이를 응용해 사영 공간에서의 무게중심값을 계산할 수 있다.

$y$축에서의 무게중심좌표를 $q_1$과 $q_2$로 지정하고 이를 사용해 $y$축의 두 점 $y_1$과 $y_2$ 사이의 점 $y'$를 구하는 수식을 다음과 같이 정리한다.    
무게중심좌표의 정의에서 두 무게중심좌표의 함 $q_1 + q_2$의 값은 1이다.

###### 식 10-3

$$y' = q_1 \cdot y_1 + q_2 \cdot y_2$$

반비례가 적용되기 전 $x$축의 수식을 정리한다.   
$x$축에서의 무게중심좌표를 $t_1$과 $t_2$로 지정하고 이를 사용해 $x$축의 두 점 $x_1$과 $x_2$ 사이의 점 $x'$을 구하는 수식은 다음과 같다.     
이 수식에서도 두 무게중심좌표의 합 $t_1 + t_2$의 값은 1이다.

$$x' = t_1 \cdot x_1 + t_2 \cdot x_2$$

두 값 $x'$와 $y'$는 서로 반비례 관계이므로 [식 10-3](#식-10-3)의 각 $y$값을 $x$값으로 표현하면 다음 식이 성립한다.

$$\frac{1}{x'} = q_1 \cdot \frac{1}{x_1} + q_2 \cdot \frac{1}{x_2}$$

주어진 두 점 $y_1$과 $y_2$의 값과 둘의 무게중심좌표 $q_1$과 $q_2$를 사용해 $x'$값을 계산할 수 있다.

$$x' = \frac{1}{(q_1 \cdot \frac{1}{x_1} + q_2 \cdot \frac{1}{x_2})}$$

양변에 분모를 곱하면 다음 식이 성립된다.

$$x' \cdot (q_1 \cdot \frac{1}{x_1} + q_2 \cdot \frac{1}{x_2}) = 1$$

$$q_1 \cdot \frac{x'}{x_1} + q_2 \cdot \frac{x'}{x_2} = 1$$

두 무게중심좌표의 합은 1임을 이용해 위 식을 다음과 같이 변환한다.

$$q_1 \cdot \frac{x'}{x_1} + q_2 \cdot \frac{x'}{x_2} = t_1 + t_2$$

양변의 덧셈항을 분리하면 다음의 관계를 얻을 수 있다.

###### 식 10-4

$$t_1 = \frac{x'}{x_1}q_1,\ t_2 = \frac{x'}{x_2}q_2$$

앞선 예에서 $y$축에서의 무게중심좌표는 각각 0.25와 0.75였다.

$$q_1 = \frac{1}{4},\ q_2 = \frac{3}{4}$$

[식 10-4](#식-10-4)를 적용하면 다음과 같이 $x$축에서의 무게중심좌표 0.5가 잘 계산됨을 확인할 수 있다.

$$t_1 = \frac{x'}{x_1}q_1 = \frac{4}{2} \cdot \frac{1}{4} = 0.5$$

$$t_2 = \frac{x'}{x_2}q_2 = \frac{4}{6} \cdot \frac{3}{4} = 0.5$$

두 점의 조합에 대한 무게중심좌표를 확장해 삼각형을 구성하는 세 점의 조합에도 동일하게 적용할 수 있다.       
두 점으로 구성된 [식 10-4](#식-10-4)를 세 점으로 확장한 수식은 다음과 같다.

$$x' = \frac{1}{(q_1 \cdot \frac{1}{x_1} + q_2 \cdot \frac{1}{x_2} + q_3 \cdot \frac{1}{x_3})}$$

$$t_1 = \frac{x'}{x_1}q_1,\ t_2 = \frac{x'}{x_2}q_2,\ t_3 = \frac{x'}{x_3}q_3$$

[식 10-5](#식-10-5)를 사용해 NDC에서 구한 무게중심좌표를 사영 공간의 무게중심좌표로 변환한다.     
사영 공간에서 NDC로 변환될 때 나누느 값은 뷰 공간의 $z$값이므로, 위 식에서 $x$를 $-z$로 치환하면 최종 투영 보정 보간의 식을 얻을 수 있다.

###### 식 10-5

$$z' = \frac{1}{(q_1 \cdot \frac{1}{z_1} + q_2 \cdot \frac{1}{z_2} + q_3 \cdot \frac{1}{z_3})}$$

$$t_1 = \frac{z'}{z_1}q_1,\ t_2 = \frac{z'}{z_2}q_2,\ t_3 = \frac{z'}{z_3}q_3$$

투영 보정 보간의 수식을 활용해 찌그러진 텍스처를 똑바로 펴줄 수 있다.   
이를 ***원근 보정 매핑(Perspective correction mapping)*** 이라고 한다.

# 38. 깊이 버퍼
다수의 게임 오브젝트를 그리는 경우 카메라로부터 멀리 떨어진 게임 오브젝트를 먼저 그리고 가까운 오브젝트를 다음에 그리도록 순서를 조절해야 원근감이 올바르게 표현된다.   
하지만 같은 거리에 있는 두 게임 오브젝트가 서로 겹쳐 있다면, 물체 단위로 그리는 순서를 조절하는 것으로는 문제를 해결할 수 없다.     
근본적인 해결 방법은 ***게임 오브젝트의 단위가 아닌 삼각형의 픽셀 단위로 깊이를 비교하고 가까운 곳에 있는 픽셀만 그리는 것***이다.    
이를 구현하기 위해 ***화면의 픽셀마다 현재의 깊이 값을 보관해주는 별도의 저장 공간***이 필요한데, 이를 ***깊이 버퍼(Depth buffer)*** 라고 한다.

최종 픽셀을 찍는 과정에서 ***현재 깊이 값을 깊이 버퍼에 저장된 값과 비교해 현재 깊이 값이 작은 경우에만 픽셀을 찍도록 로직을 구성***하면 그리기 순서 문제를 해결하면서 물체에 가려져 그리지 않아도 되는 픽셀을 파악해 그리기를 건너뛸 수 있다.    
이 작업을 ***깊이 테스팅(Depth testing)*** 이라고 한다.

* * *

[다음 페이지](/README-ORIGIN3.md/#39-절두체-컬링)