# 게임 수학 정리 문서
게임 개발에 필요한 수학 개념에 대해 정리한 문서입니다.

# 목차
* [1. 수와 집합](#1-수와-집합)
    * [1.1. 연산과 수의 구조](#11-연산과-수의-구조)
    * [1.2. 수의 구조](#12-수의-구조)
    * [1.3. 수의 표현](#13-수의-표현)
* [2. 함수](#2-함수)
    * [2.1. 함수의 개념과 종류](#21-함수의-개념과-종류)
    * [2.2. 합성함수](#22-합성함수)
    * [2.3. 항등함수와 역함수](#23-항등함수와-역함수)
    * [2.4. 곱집합을 활용한 좌표 평면으로의 확장](#24-곱집합을-활용한-좌표-평면으로의-확장)
* [3. 데카르트 좌표계](#3-데카르트-좌표계)
* [4. 벡터 공간과 벡터](#4-벡터-공간과-벡터)
    * [4.1. 스칼라와 벡터](#41-스칼라와-벡터)
    * [4.2. 벡터 공간의 연산](#42-벡터-공간의-연산)
    * [4.3. 벡터의 크기와 이동](#43-벡터의-크기와-이동)
* [5. 벡터의 결합과 생성](#5-벡터의-결합과-생성)
* [6. 삼각함수](#6-삼각함수)
    * [6.1. 삼각함수의 성질](#61-삼각함수의-성질)
    * [6.2. 각의 측정법](#62-각의-측정법)
* [7. 삼각함수를 활용한 물체의 회전](#7-삼각함수를-활용한-물체의-회전)
* [8. 삼각함수의 역함수](#8-삼각함수의-역함수)
* [9. 극좌표계](#9-극좌표계)
* [10. 선형성: 예측 가능한 비례 관계](#10-선형성-예측-가능한-비례-관계)
    * [10.1. 선형 함수](#101-선형-함수)
    * [10.2. 벡터 공간의 선형 변환](#102-벡터-공간의-선형-변환)
* [11. 행렬](#11-행렬)
    * [11.1. 행렬의 기본 연산](#111-행렬의-기본-연산)
    * [11.2. 행렬의 곱셈](#112-행렬의-곱셈)
    * [11.3. 정방행렬의 곱셈](#113-정방행렬의-곱셈)
* [12. 행렬의 설계](#12-행렬의-설계)
    * [12.1. 크기 변환행렬](#121-크기-변환행렬)
    * [12.2. 회전 변환행렬](#122-회전-변환행렬)
    * [12.3. 전단 변환행렬](#123-전단-변환행렬)
    * [12.4. 삼각함수의 덧셈 정리](#124-삼각함수의-덧셈-정리)
* [13. 역행렬](#13-역행렬)
    * [13.1. 역행렬의 존재를 판별하는 행렬식](#131-역행렬의-존재를-판별하는-행렬식)
    * [13.2. 크기 변환행렬의 역행렬](#132-크기-변환행렬의-역행렬)
    * [13.3. 전단 변환행렬의 역행렬](#133-전단-변환행렬의-역행렬)
    * [13.4. 회전 변환행렬의 역행렬](#134-회전-변환행렬의-역행렬)
    * [13.5. 행렬 곱의 역행렬](#135-행렬-곱의-역행렬)
* [14. 이동 변환을 위한 아핀 공간](#14-이동-변환을-위한-아핀-공간)
* [15. 아핀 공간의 구성 요소](#15-아핀-공간의-구성-요소)
    * [15.1. 점](#151-점)
    * [15.2. 이동 벡터](#152-이동-벡터)
    * [15.3. 아핀 공간의 성질](#153-아핀-공간의-성질)
* [16. 아핀 결합](#16-아핀-결합)
    * [16.1. 두 점의 결합](#161-두-점의-결합)
* [17. 벡터의 내적](#17-벡터의-내적)
    * [17.1. 내적의 성질](#171-내적의-성질)
    * [17.2. 내적과 삼각함수의 관계](#172-내적과-삼각함수의-관계)
    * [17.3. 행렬의 곱셈을 내적으로 표현하기](#173-행렬의-곱셈을-내적으로-표현하기)
* [18. 시야 판별](#18-시야-판별)
    * [18.1. 앞뒤 판별](#181-앞뒤-판별)
    * [18.2. 시야 판별](#182-시야-판별)

# 1. 수와 집합
게임을 구성하는 가상 세계를 이해하기 위한 첫걸음은 ***집합(Set)*** 이라는 개념으로 수를 이해하는 것이다.   
의무교육에서 배운 집한은 서로 구분되는 ***원소(Element)*** 로 구성된 묶음을 의미한다.  
이러한 집합론을 ***소박한 집합론(Native set theory)*** 이라고 한다.

소박한 집한론의 관점에서는 용도에 따라 수집합을 정의하여 구분하는데, 대표적으로는 자연수, 정수, 유리수, 실수, 복소수, 사원수 등이 있다.     
각 수집합은 [표 1-1](#표-1-1-다양한-수집합에-대응하는-기호)와 같이 인간의 언어를 통해 대상 집합을 구분할 수 있게 정의하고, 각 집합마다 고유한 기호를 사용한다.

###### 표 1-1 다양한 수집합에 대응하는 기호
|분류|정의|기호|
|---|---|---|
|자연수|물건을 세거나 순서를 지정하기 위해 사용하는 수의 집합|N|
|정수|자연수와 자연수의 음수 0을 포함하는 수의 집합|Z|
|유리수|분모가 0이 아닌 두 정수의 비율 혹은 분수로 나타낼 수 있는 집합|Q|
|무리수|두 정수 비 혹은 분수로 나타낼 수 있는 수의 집합|I|
|실수|유리수와 무리수를 포함하는 수의 집합|R|
|복소수|실수와 제곱하면 -1이 되는 허수 단위 $i$를 조합해 $a + bi$ ($a, b$는 실수) 형태로 표현하는 수의 집합|C|
|사원수|실수와 제곱하면 -1이 되는 세 허수 단위 $i, j, k$를 조합해 $a + bi + cj + dk$ ($a, b, c, d$는 실수) 형태로 표현하는 수의 집합|H|

이렇게 소박한 집합론으로 정의한 수집합의 관계는 다음 [그림 1-1](#그림-1-1-집합과-원소의-관계)과 같이 벤 다이어그램으로 도식화할 수 있다.

###### 그림 1-1 집합과 원소의 관계
![집합과 원소의 관계](/img/집합과원소의관계.jpg)

소박한 집합론은 인간의 언어로 집합을 정의하기 때문에, ***보편적인 관념에 의존할 수밖에 없다***.   
예를 들어 자연수를 사용해 일상 생활에서 물건을 세는 데 우리는 아무 불편함이 없지만, 자연수의 체계는 어떻게 구성되어 있고 집합의 특징이 무엇인지 분석하고 싶다면 물건을 센다는 개념부터 명확하게 정의해야 한다.  
수가 가지는 특징을 분석하고 이를 확장해 가상 공간이라는 고차원의 체계를 만들 수 있다.

이러한 작업을 위해서는 집합의 성질을 참과 거짓으로 명확하게 구분해 줄 수 있는 ***명제***가 필요하다.  
명제 중에서 ***증명할 필요가 없는 기본 명제***를 ***공리(Axiom)*** 라고 하는데, ***공리를 기반으로 대상을 구분하는 집합론***을 ***공리적 집합론(Axiomatic settheory)*** 이라고 한다.  
공리적 집합론에서는 ***수가 가지는 연산에 대한 공리를 기반으로 수를 분류한다***.  

# 1.1. 연산과 수의 구조
***수집합의 고유한 특징***은 ***원소를 이용해 연산***을 한다는 점이다.  
대표적인 연산으로는 덧셈, 뺄셈, 곱셈, 나눗셈의 사칙연산이 있으며, 이들은 두 개의 원소를 사용해 새로운 원소를 만들어내기 때문에 ***이항연산(Binary operation)*** 이라고도 한다.   
이항연산의 개념은 [그림 1-2](#그림-1-2-이항연산의-개념)과 같이 표현할 수 있다.

###### 그림 1-2 이항연산의 개념
![이항연산의 개념](/img/)

같은 집합에 속한 두 수를 투입한 이항연산의 결과가 항상 투입한 집합에 속한다면, 그 이항연산은 해당 ***집합에 대해 닫혀 있다(Closure)*** 고 한다.  
그리고 이항연산은 ***교환법칙(Commutative law)*** , ***결합법칙(Associative law)*** , ***분배법칙(Distributive law)*** 이라는 3가지 성질을 지닌다.

첫 번째로 교환법칙은 임의의 두 수 $a$와 $b$를 연산할 때 ***순서에 관계없이 항상 동일한 결과가 나오는 성질***을 말한다.
$$a + b = b + a$$

$$a \cdot b = b \cdot a$$

두 번째로 결합법칙은 ***연산이 두 번 이상 연속될 때, 앞의 연산을 먼저 계산한 결과와 뒤의 연산을 계산한 결과가 같은 성질***을 의미한다.
$$(a + b) + c = a + (b + c)$$

$$(a \cdot b) \cdot c = a \cdot (b \cdot c)$$

세 번째로 분배법칙은 ***서로 다른 2가지 연산***에 대해 다음의 규칙이 성립되는 것이다.
$$a \cdot (b + c) = a \cdot b + a \cdot c$$

$$(b + c) \cdot a = b \cdot a + c \cdot a$$

여기서 1번 식은 ***좌분배법칙***, 2번 식은 ***우분배법칙***이라고 하는데, 이 두 가지를 모두 만족하면 분배법칙을 만족한다고 한다.

닫혀 있다는 개념과 세 가지 연산의 성질에 이어, 이항연산이 가지는 특징은 ***항등원(Identity)*** 과 ***역원(Inverse)*** 이다.   
항등원이란 ***임의의 수와의 연산 결과를 항상 동일한 수로 만들어주는 특별한 수다***.     
[그림 1-3](#그림-1-3-항등원의-개념)에서 원소 $b$는 항등원이다.

###### 그림 1-3 항등원의 개념
![항등원의 개념](/img/)

실수 집합 R에서의 덧셈 연산을 예로 들어보자.    
실수 집합에서 덧셈의 항등원이란 다음 식 1과 같이 미지수 $a$에 항등원 $b$를 더했을 때 결괏값이 $a$ 그대로 나오는 수를 의미하므로, ***덧셈의 항등원은 0***이 된다.  
그렇다면 실수 집합에서 ***곱셈의 항등원은 1***이 되는 것도 유추할 수 있다.
$$a + 0 = a$$

$$a \cdot 1 = a$$

역원이란 ***임의의 수와의 연산 결과를 항상 항등원으로 만들어주는 특별한 수다***.    
항등원과 역원의 개념을 비교하면 [그림 1-4](#그림-1-4-항등원과-역원-개념의-비교)와 같다.

###### 그림 1-4 항등원과 역원 개념의 비교
![항등원과 역원 개념의 비교](/img/)

이항연산에 사용하는 임의의 수를 $a$로 지정했을 때, 결과가 항등원이 되는 덧셈과 곱셈의 역원은 각각 다음과 같다.
$$a + (-a) = 0$$

$$a \cdot \frac{1}{a} = 1$$

***항등원은 덧셈이나 곱셈에 대해 각각 0과 1로 고정***되어 있지만 ***역원은 덧셈이나 곱셈에 주어진 수에 따라 그 값이 달라진다***.    
이러한 역원은 연산에 따라 일정한 패턴을 보인다.     
즉 덧셈 역원은 주어진 수에서 항상 부호가 반대인 수가 되므로 ***반대수(Opposite number)*** 라고 부른다. 
또한 곱셈 역원은 분자가 1이고 분모는 주어진 수가 되므로 ***역수(Reciprocal)*** 라고도 일컫는다.    
단 ***분모가 0이 되는 분수는 존재하지 않으므로 0의 곱셈 역원은 없다***.

이항연산의 성질을 정리하면 [표 1-2](#표-1-2-이항연산의-성질)와 같다.

###### 표 1-2 이항연산의 성질
|성질|정의|
|---|---|
|닫혀 있음|어떤 집합에서 두 원소를 사용한 이항연산의 결과가 항상 그 집합에 속하는 성질|
|교환법칙|두 원소의 좌우 순서를 바꿔도 결과가 동일한 성질|
|결합법칙|세 원소의 연산 순서를 바꿔도 결과가 동일한 성질|
|분배법칙|두 이항연산에 대해 $a \cdot (b + c) = a \cdot b + a \cdot c$와 $(b + c) \cdot a = b \cdot a + c \cdot a$의 결과가 나오는 성질|
|항등원|주어진 원소와의 이항연산 결과가 언제나 주어진 원소가 되는 특별한 원소. 실수에서 덧셈의 항등원은 0이고 곱셈의 항등원은 1이다.|
|역원|주어진 원소와의 이항연산 결과가 언제나 항등원이 되는 특별한 원소. 실수에서 덧셈의 역원은 반대수. 곱셈의 역원은 역수라고 부른다.|

# 1.2. 수의 구조
이항연산의 성질을 바탕으로 공리를 구축하고, 공리를 사용해 기존의 수집합을 새롭게 분류한다.

1. 연산에 대해 닫혀 있다.
2. 연산에 대해 결합법칙이 성립한다.
3. 연산에 대한 항등원이 존재한다.
4. 연산에 대한 역원이 존재한다.
5. 연산에 대해 교환법칙이 성립한다.

정수 집합 Z의 구조를 이와 같은 공리 체계에서 분석하면, 정수의 덧셈(+)은 위 공리를 모두 만족한다.    
정수끼리 더한 결과는 항상 정수에 속하고, 결합법칙이 성립하면서 항등원 0과 임의의 수 $a$에 대한 역원 $-a$가 언제나 존재하기 때문이다.    
그러나 정수의 뺄셈(-)은 위 공리를 모두 만족하지 못한다.     
뺄셈은 교환법칙이 성립하지 않기 때문이다.

연산을 하나 더 추가해, 두 개의 연산에 대한 공리를 생각해보자.

6. 두 번째 연산에 대해 닫혀 있다.
7. 두 번째 연산에 대해 결합법칙이 성립한다.
8. 첫 번째 연산과 두 번째 연산에 대해 분배법칙이 성립한다.
9. 두 번째 연산에 대해 교환법칙이 성립한다.
10. 두 번째 연산에 대해 항등원이 존재한다.
11. 두 번째 연산에 대해 역원이 존재한다(단 0은 제외).

정수 집합 Z에 곱셈 연산을 추가하고 이와 같은 공리를 만족하는지 살펴보자.    
정수 집합은 곱셈에 닫혀 있고, 결합법칙과 분배법칙이 성립하며 교환법칙도 성립한다.   
하지만 정수 집합의 원소 $a$에 대한 곱셈의 역원은 $\frac{1}{a}$인데 이는 정수가 아니기 때문에 11번의 공리를 만족하지 못한다.     
따라서 정수 집합의 덧셈과 곱셈은 이들 공리를 모두 만족하지 못한다.

덧셈과 곱셈 연산에 대해 11가지 공리를 모두 만족하는 수 집합은 어떤 것이 있는지 생각해보자.  
***덧셈에 대한 역원이 존재하지 않는 자연수(N)*** 와 ***곱셈에 대한 역원이 존재하지 않는 정수(Z)*** 는 이를 만족하지 못한다.   
하지만 ***유리수(Q)*** , ***실수(R)*** 는 ***곱셈의 역원이 존재***하기 때문에 덧셈과 곱셈 두 연산에 대해 앞서 열거한 11가지 공리를 모두 만족한다.

***공리적 집합론에서 두 연산에 대해 1번부터 11번까지의 공리를 모두 만족하는 수 집합은 체(Field)의 구조를 지닌다고 표현한다***.    
유리수(Q), 실수(R)와 같이 ***체의 구조를 가지는 수 집합은 특별한 예외 상황 없이 덧셈과 곱셈을 안전하고 자유롭게 사용할 수 있다***고 볼 수 있다.   
콘텐츠를 담는 가상 세계를 구축하기 위해서 특정한 수 집합을 지정해 사용하는 것이 아닌, 체의 구조를 기반으로 체계를 확장해 공간의 구조를 생성한다.

사칙 연산을 구성하는 나머지 연산인 뺄셈과 나눗셈은 체의 구조를 만족하는지 살펴보자.     
***뺄셈과 나눗셈은 교환법칙을 만족하지 않기 때문에 체의 구조를 지니지 못한다***.
$$a - b \neq b - a$$

$$a \div b \neq b \div a$$

이에 대한 해결책은 ***뺄셈 대신 덧셈의 역원을 사용***하고 ***나눗셈 대신 곱셈의 역원을 사용***하는 것이다.

실수 집합에서 덧셈의 역원은 반대수, 곱셈의 역원은 역수였다.     
뺄셈과 나눗셈 대신 덧셈과 곱셈의 역원을 사용하면 교환법칙이 성립하면서 같은 결과를 만들어낸다.
$$a + (-b) = (-b) + a$$

$$a \cdot \frac{1}{b} = \frac{1}{b} \cdot a$$

그렇기 때문에 수 집합의 구조를 분석할 때는 덧셈과 곱셈의 두 가지 연산에 대해서만 살펴보는 것으로 충분하다.

정리하면, ***체는 사칙연산이 자유로이 시행될 수 있고 산술의 잘 알려진 규칙들을 만족하는 수의 구조다***.     

# 1.3. 수의 표현
실수(R)를 대응시켜 표현한 직선을 수직선(Number line)이라 하며 [그림 1-5](#그림-1-5-수직선의-예)과 같이 표현한다.    
> 참고: 수를 표현하는 수직선(Number line)은 직각으로 만나는 직선을 의미하는 수직선(Perpendicular line)과 동음이의어다.

###### 그림 1-5 수직선의 예
![수직선의 예](/img/)

실수의 모든 요소는 상호 간에 크기를 비교할 수 있다.     
***더 큰 수는 오른쪽에 표시하는 규칙을 사용해 실수의 모든 원소는 수직선 상에 자신의 고유한 위치를 갖게 된다***.   
따라서 하나의 실수를 시각화할 때는 그 수의 고유한 위치에 점을 찍어 표현한다.    
[그림 1-6](#그림-1-6-점으로-수를-표현하는-방법)에서는 -2보다 큰 수 2가 수직선에서 오른쪽에 위치함을 알 수 있다.

###### 그림 1-6 점으로 수를 표현하는 방법
![점으로 수를 표현하는 방법](/img/)

***수직선은 0을 기준으로 양수와 음수라는 두 개의 체계가 서로 대칭되어 있는 것으로 해석할 수 있다***.  
이러한 관점에서 하나의 수는 [그림 1-7](#그림-1-7-화살표로-수를-표현하는-방법)과 같이 원점에서부터 크기와 방향을 가진 화살표로도 표현할 수 있다.

###### 그림 1-7 화살표로 수를 표현하는 방법
![화살표로 수를 표현하는 방법](/img/)

이와 같이 수가 지니는 방향의 속성은 부호를 사용해 나타내며 크기의 속성은 원점으로부터의 거리를 의미한다.    
***어떤 수의 원점으로부터의 거리는 수직 막대(Vertical bar) 기호를 써서 나타내는데, 이를 절댓값(Absolute value)이라고 한다***.
$$|-3| = 3$$

***물체에 힘을 가해 이동하거나, 크기를 늘리는 작업은 덧셈과 곱셈 연산으로 해석할 수 있다***.  
이항연산에서 왼쪽 항의 수를 물체를 구성하는 점으로 보고, 오른쪽 항의 수를 점을 이동시키는 힘으로 보면 덧셈 연산은 [그림 1-8](#그림-1-8-점의-이동으로-표현하는-덧셈-연산)과 같이 점을 평행 이동시키는 작업으로 해석할 수 있다.    
예를 들면 어떤 수와 -5와의 합은 수의 위치를 왼쪽 방향으로 5칸만큼 이동시키는 작업이고, 2와의 합은 오른쪽 방향으로 2칸만큼 이동시키는 작업이다.

###### 그림 1-8 점의 이동으로 표현하는 덧셈 연산
![점의 이동으로 표현하는 덧셈 연산](/img/)

그리고 곱셈 연산은 [그림 1-9](#그림-1-9-크기와-방향의-변화로-표현하는-곱셈-연산)와 같이 원점을 기준으로 점의 위치를 지정된 배율만큼 늘리고 대칭시키는 작업으로 해석할 수 있다.  
예를 들면 어떤 수와 2의 곱은 원점으로부터 거리를 같은 방향으로 2배로 키우는 작업이고, -2와의 곱은 원점으로부터 거리를 2배로 늘린 후 반대쪽으로 대칭시키는 작업으로 볼 수 있다.  
왼쪽 항의 수가 가진 크기를 오른쪽 수가 가진 크기의 배율로 늘리거나 줄인 후 오른쪽 수의 부호가 양의 부호인 경우 원 방향을 유지하고, 음수인 경우 반대 방향으로 대칭시키는 작업이 곱셈 연산이다.

###### 그림 1-9 크기와 방향의 변화로 표현하는 곱셈 연산
![크기와 방향의 변화로 표현하는 곱셈 연산](/img/)

# 2. 함수
***함수(Function)란 두 집합에서 첫 번째 집합의 모든 원소가 빠짐없이 두 번째 집합의 어떤 원소에 대응하는 관계를 의미한다***.

# 2.1. 함수의 개념과 종류
두 집합을 $X$와 $Y$라는 기호로 지정하고, 집합 $X$의 원소를 $x$, 집합 $Y$의 원소를 $y$라 할 때 $X$에서 $Y$로 대응되는 함수를 $y = f(x)$로 나타낸다.  
두 집합의 대응 관계는 [그림 1-10](#그림-1-10-함수의-개념과-기호)과 같다.

###### 그림 1-10 함수의 개념과 기호
![함수의 개념과 기호](/img/)

두 집합의 요소가 서로 대응된다고 모두 함수로 인정받는 것은 아니고, 다음 두 규칙이 성립돼야 한다.

1. 첫 번째 집합의 모든 원소에 대한 대응 관계가 존재해야 함
2. 첫 번째 집합의 원소는 두 번째 집합의 원소에만 대응되어야 함

[그림 1-11](#그림-1-11-함수가-아닌-두-집합의-대응-관계)을 예시로 보면, 집합 $X$의 원소 중 3과 4는 대응 관계가 없고 원소 2는 집합 $Y$의 두 원소($B$와 $C$)에 대응된다.     
따라서 예시에서 나타난 두 집합의 대응 관계는 함수가 아니다.

###### 그림 1-11 함수가 아닌 두 집합의 대응 관계
![함수가 아닌 두 집합의 대응 관계](/img/)

왼쪽의 집합과 오른쪽의 집합이 가져야 하는 조건이 다르기 때문에 함수에서 정의된 용어를 사용해 두 집합이 가진 대응 관계를 명확하게 전달해야 한다.     
***함수에서 왼쪽에 위치한 첫 번째 집합을 정의역(Domain)이라고 하고, 오른쪽에 위치한 두 번째 집합을 공역(Codomain)이라 한다***.

함수 용어를 사용해 대응 관계를 표현한다면, ***정의역의 모든 원소는 공역의 원소에 대응되어야 한다***.  
하지만 ***공역의 모든 원소가 정의역에 대응할 필요는 없다***.  
그렇기 때문에 ***정의역에 대응되는 공역의 원소만 따로 모아 부분집합(Subset)을 형성할 수 있는데, 이를 치역(Range)이라고 부른다***.     
[그림 1-12](#그림-1-12-정의역-공역-치역의-개념)는 정의역, 공역, 치역의 개념과 관계를 표현한다.

###### 그림 1-12 정의역, 공역, 치역의 개념
![정의역, 공역, 치역의 개념](/img/)

또한 ***함수에 사용하는 정의역의 요소를 입력(Input), 입력에 대응하는 공역의 요소를 출력(Output)이라고 한다***.    
이러한 함수의 개념은 [그림 1-13](#그림-1-13-함수의-개념을-기계로-표현하기)과 같은 형태로도 표현할 수 있다.

###### 그림 1-13 함수의 개념을 기계로 표현하기
![함수의 개념을 기계로 표현하기](/img/)

정의역과 공역이 서로 대응되는 형태에 따라 함수를 여러 종류로 구분할 수 있다.

## 전사함수
***전사함수(Surjection)는 공역의 모든 요소가 정의역에 대응되는 함수를 의미한다***.    
[그림 1-14](#그림-1-14-전사함수의-예시)와 같이 공역과 치역이 동일한 함수다.   
> 참고: 위로의 함수(Onto)라고도 부름

###### 그림 1-14 전사함수의 예시
![전사함수의 예시](/img/)

[그림 1-15](#그림-1-15-전사함수가-아닌-예시)는 공역과 치역이 서로 다르므로 전사함수가 아니다.

###### 그림 1-15 전사함수가 아닌 예시
![전사함수가 아닌 에시](/img/)

## 단사함수
***단사함수(Injection)는 정의역과 공역의 요소가 일대일로 대응되는 함수를 의미한다***.     
[그림 1-16](#그림-1-16-단사함수-예시)은 정의역의 모든 요소가 공역의 요소에 일대일로 대응되므로 단사함수다.
> 참고: 일대일 함수(One-to-One)라고도 부름

###### 그림 1-16 단사함수 예시
![단사함수 예시](/img/)

[그림 1-17](#그림-1-17-단사함수가-아닌-예시)은 정의역의 두 요소가 공역의 한 요소에 대응되기 때문에 일대일 대응이 아니므로 단사함수가 아니다.

###### 그림 1-17 단사함수가 아닌 예시
![단사함수가 아닌 예시](/img/)

## 전단사함수
***전단사함수(Bijection, One-to-One and Onto)는 정의역과 공역의 모든 요소가 빠짐없이 일대일로 대응되는 함수를 의미한다***.    
[그림 1-18](#그림-1-18-전단사함수-예시)과 같이 전사함수와 단사함수의 두 가지 성질을 모두 만족하면 전단사함수라 할 수 있다.

###### 그림 1-18 전단사함수 예시
![전단사함수 예시](/img/)

# 2.2. 합성함수
함수의 대응 관계를 확장해 다수 집합의 대응 관계로 발전시킬 수도 있다.   
***2개의 함수를 연쇄적으로 이어서 하나의 함수로 만드는 연산을 함수의 합성(Function composition)이라 한다***.  
[그림 1-19](#그림-1-19-합성함수의-예시)와 같이 세 집합 $X, Y, Z$ 사이에 두 함수 $f(x)$와 $g(y)$가 존재하는 상황을 가정해보자.

###### 그림 1-19 합성함수의 예시
![합성함수의 예시](/img/)

두 함수 $f(x)$와 $g(y)$를 연쇄적으로 이어 합성함수를 만들면, [그림 1-20](#그림-1-20-합성함수의-결과)과 같이 중간에 위치한 집합 $Y$를 생략하고 집합 $X$와 $Z$의 직접적인 대응 관계를 표현할 수 있다.   
이러한 합성함수는 $g \circ f$ 혹은 $g(f(x))$로 표시한다.    
***먼저 실행되는 함수 $f$가 합성함수 기호($\circ$)의 오른쪽에 놓인다는 점에 유의해야 한다***.     
> 참고: 합성함수는 $g \circ f$는 $g$ 써클 $f$로 부르는데, 대응 순서에 맞춰서 $g$ 애프터 $f$라고도 부른다.

###### 그림 1-20 합성함수의 결과
![합성함수의 결과](/img/)

이번에는 [그림 1-21](#그림-1-21-4개-집합과-3개-함수로-구성된-대응-관계)과 같이 집합과 함수를 하나씩 더 추가한 대응 관계를 생각해보자.

###### 그림 1-21 4개 집합과 3개 함수로 구성된 대응 관계
![4개 집합과 3개 함수로 구성된 대응 관계](/img/)

이 상황에서는 두 합성함수에 대한 경우의 수를 [그림 1-22](#그림-1-22-세-함수로부터-만들어지는-두-합성함수에-대한-경우의-수)의 (a)와 (b)와 같이 생각할 수 있다.

###### 그림 1-22 세 함수로부터 만들어지는 두 합성함수에 대한 경우의 수
![세 함수로부터 만들어지는 두 합성함수에 대한 경우의 수](/img/)

[그림 1-22](#그림-1-22-세-함수로부터-만들어지는-두-합성함수에-대한-경우의-수)의 (a)와 (b)의 두 합성함수가 남은 함수와 다시 합성하는 경우는 각각 [그림 1-23](#그림-1-23-합성함수의-합성-결과)의 (a)와 (b)와 같이 전개될 것이다.

###### 그림 1-23 합성함수의 합성 결과
![합성함수와의 합성 결과](/img/)

[그림 1-23](#그림-1-23-합성함수의-합성-결과)의 (a)와 (b)의 결과는 동일한 대응 관계를 가짐을 볼 수 있다.  
***합성 함수를 이항연산으로 규정하면, 합성 함수는 결합법칙이 성립한다***.

# 2.3. 항등함수와 역함수
수의 연산에서 다룬 항등원, 역원과 동일한 개념이 함수에도 존재한다.  
[그림 1-24](#그림-1-24-항등함수의-예시)와 같이 ***정의역과 공역이 동일한 값으로 대응되는 함수를 항등함수(Identity function)라고 하며 기호 $id$로 나타낸다***.

###### 그림 1-24 항등함수의 예시
![항등함수의 예시](/img/)

항등함수는 [1.1. 연산과 수의 구조](#11-연산과-수의-구조)에서 배운 연산의 항등원과 동일한 역할을 수행한다.  
합성함수를 사용해 함수에 연산의 개념을 도입하면 세 집합의 대응 관계는 [그림 1-25](#그림-1-25-항등함수를-사용한-합성함수)와 같이 표현할 수 있다.

###### 그림 1-25 항등함수를 사용한 합성함수
![항등함수를 사용한 합성함수](/img/)

(a)를 수식으로 나타내면 $id \circ f = f$이고 (b)를 수식으로 나타내면 $f \circ id = f$가 되는데 ***항등함수는 어느 위치에 있든지 합성의 결과는 원 함수와 동일한 대응 관계를 나타낸다***.

수의 역원 개념과 동일하게 합성함수의 대응 결과가 항등함수가 되는 경우를 생각해 보자.    
[그림 1-26](#그림-1-26-합성함수의-결과가-항등함수가-되는-경우)의 (a)와 같은 대응 관계가 있다고 생각한다면, 이를 합성해 간추린 결과는 (b)와 같이 서로 동일한 원소끼리 대응될 것이다.

###### 그림 1-26 합성함수의 결과가 항등함수가 되는 경우
![합성함수의 결과가 항등함수가 되는 경우](/img/)

[그림 1-26](#그림-1-26-합성함수의-결과가-항등함수가-되는-경우)의 (a)의 $g(y)$와 같은 함수를 역함수(Inverse function)라고 한다.     
***역함수는 위 첨자를 붙여 $f^{-1}$로 표기***하며 어떤 함수와 역함수를 합성한 결과는 (b)와 같이 언제나 항등함수가 된다.   
이를 수식으로 나타내면 다음과 같다.
$$f^{-1} \circ f = id$$

$$f \circ f^{-1} = id$$

***역함수는 두 집합의 대응 관계를 뒤집어 공역 $Y$에서 정의역 $X$로 대응하는 함수로도 생각할 수 있다***.   
이 개념을 도식화하면 [그림 1-27](#그림-1-27-역함수의-개념과-기호)과 같다.

###### 그림 1-27 역함수의 개념과 기호
![역함수의 개념과 기호](/img/)

***역함수에서 주의할 점은 모든 함수가 역함수를 갖지는 않는다는 사실이다***.   
[그림 1-28](#그림-1-28-전사함수와-단사함수의-역함수)의 (a)에서 보여지는 전사함수는 하나의 원소가 두 개의 원소에 대응되기 때문에 함수의 기본 조건을 만족하지 못하고, (b)의 단사함수는 정의역의 모든 원소가 대응하지 않기 때문에 이들의 역함수는 함수의 조건을 만족하지 못한다.

###### 그림 1-28 전사함수와 단사함수의 역함수
![전사함수와 단사함수의 역함수](/img/)

하지만 전단사함수의 경우에는 [그림 1-29](#그림-1-29-전단사함수의-역함수)과 같이 모든 경우에서 함수의 조건을 만족하기 때문에 역함수가 보장된다.    
***어떤 함수가 역함수를 가지기 위해서는 반드시 전단사함수의 형태가 되어야 한다***.

###### 그림 1-29 전단사함수의 역함수
![전단사함수의 역함수](/img/)

합성함수에 역함수의 개념을 적용해보자.  
[그림 1-30](#그림-1-30-합성함수의-예시)의 (a)에 세 집합 $X, Y, Z$ 대상으로 생성된 두 전단사함수 $f, g$를 나타냈다.    
이를 합성한 결과는 (b)가 될 것이다.

###### 그림 1-30 합성함수의 예시
![합성함수의 예시](/img/)

여기서 [그림 1-30](#그림-1-30-합성함수의-예시)의 (b)의 합성함수 $g \circ f$를 거꾸로 뒤집은 역함수 $(g \circ f)^{-1}$는 [그림 1-31](#그림-1-31-합성함수의-역함수)과 같은 대응관계를 가진다고 볼 수 있다.

###### 그림 1-31 합성함수의 역함수
![합성함수의 역함수](/img/)

이는 [그림 1-32](#그림-1-32-합성함수의-역함수의-분석)와 같이 두 함수의 역함수 $f^{-1}$과 $g^{-1}$ 반대 순서로 합성한 결과로 볼 수 있다.

###### 그림 1-32 합성함수의 역함수의 분석
![합성함수의 역함수의 분석](/img/)

이러한 합성함수의 역함수가 가지는 성질은 아래와 같은 식으로 정리된다.
$$(g \circ f)^{-1} = f^{-1} \circ g^{-1}$$

# 2.4. 곱집합을 활용한 좌표 평면으로의 확장
***곱집합(Cartesian product 혹은 Product set)이란 두 집합의 원소를 순서쌍으로 묶은 원소의 집합을 의미한다***.     
두 집합 $A$와 $B$가 있고 각 집합에 속한 원소를 $a$와 $b$라고 했을 때 집합 $A$와 $B$의 곱집합은 다음과 같이 표현한다.
$$A \times B$$

***곱집합은 두 집합 $A$와 $B$의 요소를 서로 수직으로 배치해 묶는다***.    
[그림 1-33](#그림-1-33-곱집합의-예시)은 무늬 집합 $A$와 순위 집합 $B$를 곱집합으로 묶은 카드 배열을 나타낸 예시다.

###### 그림 1-33 곱집합의 예시
![곱집합의 예시](/img/곱집합의예시.png)

곱집합의 요소는 각 집합의 원소 $a$와 $b$를 다음의 순서쌍으로 묶어 표현한다.
$$(a, b)$$

곱집합의 개념은 앞서 설명한 수의 이항연산 개념을 설명하는 데에도 사용할 수 있다.    
두 실수 집합의 곱집합 $R \times R$을 구성하고 [그림 1-34](#그림-1-34-이항연산의-함수-표현)와 같이 정의역으로 설정해 입력 요소를 2개로 지정하면, 수의 이항연산을 함수로 표현하는 것이 가능해진다.

###### 그림 1-34 이항연산의 함수 표현
![이항연산의 함수 표현](/img/)

또한 두 집합을 서로 수직으로 배치하는 곱집합의 성질을 응용하면, 하나의 직선으로 표현한 실수 집합 $R$을 확장해 두 실수 집합의 곱집합 $R \times R$을 [그림 1-35](#그림-1-35-직선으로-표현되는-수를-곱집합을-사용해-평면으로-확장한-결과)와 같이 평면으로 나타낼 수 있다.

###### 그림 1-35 직선으로 표현되는 수를 곱집합을 사용해 평면으로 확장한 결과
![직선으로 표현되는 수를 사용해 평면으로 확장한 결과](/img/)

두 실수 집합의 곱집합으로 형성된 평면에 다시 실수 집합을 곱집합으로 설정하면 3차원 공간이 된다.

# 3. 데카르트 좌표계
실수와 실수의 곱집합을 사용해 직선으로 표현되는 영역을 평면으로 확장해 표현할 수 있었다.    
***이렇게 직선의 수 집합을 수직으로 배치해 평면을 표기하는 방식을 데카르트 좌표계(Cartesian coordinate system)라고 부른다***. 

데카르트 좌표계는 [그림 2-1](#그림-2-1-데카르트-좌표계)과 같이 수평으로 배치한 첫 번째 실수 집합의 미지수를 $x$, 수직으로 배치한 두 번째 실수 집합의 미지수를 $y$로 표기하고 원점을 기준으로 $x$축의 오른편, $y$축의 위편은 양의 영역을 나타낸다.  
이렇게 배치된 두 실수 집합으로 평면을 가르면 평면의 영역은 총 4개의 분면으로 나뉘는데, 오른쪽 상단에서부터 반시계 반향으로 [그림 2-1](#그림-2-1-데카르트-좌표계)과 같이 이름을 붙인다.

###### 그림 2-1 데카르트 좌표계
![데카르트 좌표계](/img/)

***데카르트 좌표계의 한 원소는 곱집합과 동일하게 순서쌍으로 표현하며 좌표(Coordinate)라고 부른다***.
$$(x, y)$$

일반적으로 좌표는 수와 동일하게 [그림 2-2](#그림-2-2-좌표의-시각화-방법)와 같이 점 또는 원점으로부터의 화살표로 표현한다.     
***좌표는 크기와 방향 두 가지 속성을 지닌다***.

###### 그림 2-2 좌표의 시각화 방법
![좌표의 시각화 방법](/img/)

# 4. 벡터 공간과 벡터
# 4.1. 스칼라와 벡터
평면의 좌표 $(x, y)$는 두 실수 $x$와 $y$를 결합해 만들어진다.   
그렇기 때문에 ***좌표의 연산은 실수가 지니는 연산의 성질을 바탕으로 설계돼야 한다***.     
***실수의 연산 성질은 체의 구조를 띤다***.    
이를 기반으로 새로운 공리를 덧붙여서 평면을 대표하는 집합을 규정하고, 해당 집합에서 이뤄지는 덧셈과 곱셈 연산 체계를 만들어야 평면에서의 움직임을 표현할 수 있다.

***두 개 이상의 실수를 곱집합으로 묶어 형성된 집합을 공리적 집합론의 관점에서 규정한 것***을 ***벡터 공간(Vector space)*** 이라고 하며, ***벡터 공간의 원소를 벡터(Vector)라고 한다***.    
공리적 집합론의 관점에서는 ***특정한 수 집합을 지칭하지 않고 연산이 갖는 성질***만 다루기 때문에, 좌푯값으로 사용하는 $x$와 $y$를 실수로 규정하기보다는 ***체의 구조를 지니는 집합, 즉 체 집합의 원소로 규정한다***.    
이렇게 ***체의 구조를 가지는 수 집합의 원소를 스칼라(Scalar)라고 부른다***.   
즉 우리가 좌표로 사용하는 실수 $x$와 $y$는 모두 공리적 집합론의 관점에서 스칼라인 것이다.   
집합의 개념인 벡터 공간을 표기할 때에는 주로 대문자 $V$를 사용하고, 이의 원소인 벡터는 소문자 $\vec{v}$로 표기한다.     
벡터는 다음과 같이 좌표와 동일한 방법으로 표기한다.
$$\vec{v} = (x, y)$$

# 4.2. 벡터 공간의 연산
공리적 집합론의 관점에서 정의된 벡터 공간은 두 가지 기본 연산이 존재한다.   
다음의 수식에서 사용되는 수 $a, x, y$는 모두 체 집합의 원소인 스칼라다.

1. 벡터와 벡터의 덧셈(줄여서 벡터의 합으로 부름)
$$\vec{v_1} + \vec{v_2} = (x_1, y_1) + (x_2, y_2) = (x_1 + x_2, y_1 + y_2)$$
2. 스칼라와 벡터의 곱셈(줄여서 스칼라 곱셈이라 부름)
$$a \cdot \vec{v} = a \cdot (x, y) = (a \cdot x, a \cdot y)$$

체가 갖는 연산의 성질에 기반해 벡터 공간의 연산이 갖는 성질은 [표 2-1]과 같이 8가지로 정리할 수 있다.   
이를 '벡터 공간의 공리'라고 한다.

###### 표 2-1 벡터 공간의 8가지 공리
|No|분류|공리|수식|
|---|---|---|---|
|1|벡터의 합|벡터의 합의 결합법칙|$\vec{u} + (\vec{v} + \vec{w}) = (\vec{u} + \vec{v}) + \vec{w}$|
|2|벡터의 합|벡터의 합의 교환법칙|$\vec{u} + \vec{v} = \vec{v} + \vec{u}$|
|3|벡터의 합|벡터의 합의 항등원|$\vec{v} + \vec{0} = \vec{v}$|
|4|벡터의 합|벡터의 합의 역원|$\vec{v} + (-\vec{v}) = \vec{0}$|
|5|스칼라 곱셈|스칼라 곱셈의 호환성|$a(b\vec{v}) = (ab)\vec{v}$|
|6|스칼라 곱셈|스칼라 곱셈의 항등원|$1 \cdot \vec{v} = \vec{v}$|
|7|스칼라 곱셈|벡터의 합에 대한 분배법칙|$a(\vec{u} + \vec{v}) = a\vec{u} + a\vec{v}$|
|8|스칼라 곱셈|스칼라 덧셈에 대한 분배법칙|$(a + b)\vec{v} = a\vec{v} + b\vec{v}$|

> 참고: 벡터와 스칼라의 곱을 표현하기 위해 스칼라 곱셈은 스칼라배(Scalar倍)라고도 불린다.   
스칼라곱은 스칼라 곱셈과 다른 연산이며 내적을 의미한다.

[표 2-1](#표-2-1-벡터-공간의-8가지-공리)에 열거한 ***벡터 공간의 공리***는 모두 ***체의 공리***를 기반으로 하기 때문에 해당 공리가 참임을 바로 파악할 수 있다.  
예를 들어 ***벡터의 합이 교환법칙을 만족하는 까닭은 두 스칼라의 덧셈이 교환법칙을 만족하기 때문이다***.
$$\vec{v_1} + \vec{v_2} = (x_1, y_1) + (x_2, y_2) = (x_1 + x_2, y_1 + y_2)$$

$$\vec{v_2} + \vec{v_1} = (x_2, y_2) + (x_1, y_1) = (x_2 + x_1, y_2 + y_1)$$

$$\therefore \vec{v_1} + \vec{v_2} = \vec{v_2} + \vec{v_1}$$

벡터의 이항 연산에서 왼쪽의 벡터는 물체를 구성하는 점으로, 오른쪽의 벡터는 점을 이동시키는 힘으로 연산을 시각화하면 [그림 2-3](#그림-2-3-벡터의-합-연산을-시각화한-예시)과 같다.    
벡터의 합 연산은 평면의 점을 각 축에 대해 독립적으로 평행 이동시키는 작업으로 해석할 수 있다.

###### 그림 2-3 벡터의 합 연산을 시각화한 예시
![벡터의 합 연산을 시각화한 예시](/img/)

***스칼라 곱셈으로 생성된 벡터는 원점을 지나고 벡터와 평행한 직선상에 위치한다***.    
따라서 스칼라 곱셈의 결과는 항상 [그림 2-4](#그림-2-4-스칼라-곱셈-연산을-시각화한-예시)에서 붉은색으로 표현한, 원점을 지나는 직선상의 벡터를 만들어낸다.

###### 그림 2-4 스칼라 곱셈 연산을 시각화한 예시
![스칼라 곱셈 연산을 시각화한 예시](/img/)

# 4.3. 벡터의 크기와 이동
[1.3. 수의 표현](#13-수의-표현)에서 수의 크기는 원점으로부터의 거리를 의미하며 절댓값 기호($| |$)를 사용해 구할 수 있었다.  
***벡터의 크기***도 동일하게 ***원점으로부터의 최단 거리***를 의미한다.     
이를 측정하려면 [그림 2-5](#그림-2-5-벡터-4-3의-크기-측정)와 같이 ***원점과 벡터를 연결해 직각삼각형을 그린 후, 피타고라스 정리를 사용해 거리를 측정한다***.
$$c^2 = a^2 + b^2$$

$$\therefore c = \sqrt{a^2 + b^2}$$

###### 그림 2-5 벡터 (4, 3)의 크기 측정
![벡터 (4, 3)의 크기 측정](/img/)

이렇게 측정된 ***벡터의 크기 역시 절댓값 기호와 동일하게 수직 막대($| |$)를 사용한다***.  
벡터 $(x, y)$의 크기를 구하는 공식은 다음과 같다.
$$||\vec{v}|| = |\vec{v}| = \sqrt{x^2 + y^2}$$

> 참고: 일반적으로 벡터의 크기는 두 개의 수직 막대 기호 $||$로 표기한다.

벡터의 크기는 ***노름(Norm)*** 이라는 용어로 부르기도 한다.    
***크기가 1인 벡터를 단위 벡터(Unit Vector)라고 한다***.  
단위 벡터는 벡터의 크기를 측정하는 기준이 되며, 벡터와 관련된 다양한 응용식을 전개하는 데 자주 사용된다.     
단위 벡터는 다음과 같이 ***모자 기호(Hat)*** 을 씌워 $\hat{v}$의 형태로 표시한다.  
***스칼라 곱셈의 성질을 이용해 임의의 벡터 $\vec{v}$를 이의 크기인 $|\vec{v}|$로 나누면 단위 벡터 $\hat{v}$를 얻을 수 있다***.    
이를 그림으로 나타내면 [그림 2-6](#그림-2-6-벡터의-크기를-1로-만드는-연산)과 같다.

###### 그림 2-6 벡터의 크기를 1로 만드는 연산
![벡터의 크기를 1로 만드는 연산](/img/)

이와 같이 임의의 벡터 $\vec{v}$를 크기가 1인 단위 벡터 $\hat{v}$로 다듬는 작업을 ***정규화***한다(Normalize)고 부르며 수식은 다음과 같다.
$$\hat{v} = \frac{\vec{v}}{|\vec{v}|}$$

# 5. 벡터의 결합과 생성
***벡터 공간의 벡터의 합과 스칼라 곱셈 연산은 선형성이 있어 선형 연산이라고도 한다***.    
선형 연산을 사용해 $n$개의 스칼라 $a_1, ..., a_n$과 $n$개의 벡터 $\vec{v_1}, ..., \vec{v_n}$를 결합해 새로운 벡터 $\vec{v'}$을 생성하는 수식을 ***선형 결합(Linear combination)*** 이라고 한다.    
선형 결합의 수식은 다음과 같다.
$$a_1\vec{v_1} + a_2\vec{v_2} + a_3\vec{v_3} + ... + a_n\vec{v_n} = \vec{v'}$$

여기서 벡터의 모든 원소가 0으로 구성된 영벡터 $\vec{0}$을 생각했을 때 선형 결합의 결과가 $\vec{0}$이 나오는 수식을 생각해보면 다음과 같다.
$$a_1\vec{v_1} + a_2\vec{v_2} + a_3\vec{v_3} + ... + a_n\vec{v_n} = \vec{0}$$

***벡터에 곱하는 모든 스칼라 값이 0이면 선형 결합의 결과는 항상 영벡터가 된다***.     
$a$값이 0이 아닌 경우에도 영벡터는 나올 수 있다.
$$2 \cdot (1, 1) + (-1) \cdot (2, 2) = (0, 0)$$

이 식과 같이 ***모든 $a$가 0이 아님에도 영벡터를 만들 수 있다***면, 선형 결합에 사용된 벡터는 서로 '***선형 종속의 관계***'를 가진다라고 표현한다.  
따라서 $(1, 1)$과 $(2, 2)$의 두 벡터는 선형 종속인 관계를 갖는다.

반면 ***영벡터가 나오기 위해서 모든 $a$값이 0이어야 한다***면 선형 결합에 사용된 벡터들은 서로 '***선형 독립의 관계***'를 가진다라고 표현한다.  
다음 수식에서 $(1, 2)$와 $(2, 1)$ 두 벡터가 결합할 때 영벡터가 나오려면 모든 스칼라 $a$의 값은 0이어야 한다.    
따라서 $(1, 2)$와 $(2, 1)$의 두 벡터는 선형 독립의 관계를 갖는다.
$$0 \cdot (1, 2) + 0 \cdot (2, 1) = (0, 0)$$

벡터 간의 선형적 관계는 벡터 공간을 다룰 때 중요하게 사용된다.  
***선형 독립의 관계를 가지는 벡터를 선형 결합하면 벡터 공간에 속한 모든 벡터를 생성***할 수 있기 때문이다.    
두 벡터 $\vec{u}, \vec{v}$와 두 스칼라 $a, b$를 결합해 새로운 벡터 $\vec{w}$를 생성하는 수식은 다음과 같이 나타낼 수 있다.
$$\vec{w} = a \cdot \vec{u} + b \cdot \vec{v}$$

두 벡터 $\vec{u}$와 $\vec{v}$가 선형 독립의 관계를 가진다면 이 선형 결합식으로 2차원 벡터 공간에 속한 모든 벡터를 생성할 수 있다.   
벡터 $\vec{w}$의 값이 $(5, 5)$라고 가정해보면, 이 벡터를 생성하는 두 벡터의 결합으로는 $x$축과 $y$축에 일치하는 두 단위 벡터 $(1, 0)$과 $(0, 1)$을 사용한 선형 결합식을 생각할 수 있다.
$$(5, 5) = 5 \cdot (1, 0) + 5 \cdot (0, 1)$$

이 수식을 그림으로 나타내면 [그림 2-7](#그림-2-7-두-단위-벡터의-선형-결합으로-벡터를-생성한-예시)과 같다.

###### 그림 2-7 두 단위 벡터의 선형 결합으로 벡터를 생성한 예시
![두 단위 벡터의 선형 결헙으로 벡터를 생성한 예시](/img/)

[그림 2-8](#그림-2-8-벡터-2-1과-1-3을-활용한-선형-결합으로-벡터-5-5를-생성한-예시)과 같이 벡터 $(5, 5)$를 생성할 수 있는 선형 결합식은 이 밖에도 얼마든지 다양하게 존재한다.
$$(5, 5) = 2 \cdot (2, 1) + 1 \cdot (1, 3)$$

###### 그림 2-8 벡터 (2, 1)과 (1, 3)을 활용한 선형 결합으로 벡터 (5, 5)를 생성한 예시
![벡터 (2, 1)과 (1, 3)을 활용한 선형 결합으로 벡터 (5, 5)를 생성한 예시](/img/)

벡터 $(2, 1)$과 $(1, 3)$을 결합했을 때 $(5, 5)$가 아닌 다른 벡터도 생성할 수 있는지 확인해보자.     
순서쌍 $(w_x, w_y)$로 구성된 임의의 벡터 $\vec{w}$를 생성하는 수식은 다음과 같다.
$$(w_x, w_y) = a \cdot (2, 1) + b \cdot (1, 3)$$

$x$값과 $y$값을 분리해 위 식을 전개하면 다음과 같다.
$$2a + b = w_x$$

$$a + 3b = w_y$$

두 식을 $a$와 $b$에 대한 연립방정식으로 보고 풀어보면 그 값은 벡터 $\vec{w}$의 좌푯값인 $w_x, w_y$값에 따라 결정되며, ***언제나 해가 존재함***을 알 수 있다.
$$a = \frac{3w_x - w_y}{5}, b = \frac{2w_y - w_x}{5}$$

따라서 벡터 $(2, 1)$과 벡터 $(1, 3)$을 결합해 ***평면에 속한 모든 벡터를 생성할 수 있음***을 알 수 있다.  
그리고 벡터 $\vec{w}$ 값이 영벡터가 되는 $a$와 $b$의 해는 모두 0인 경우뿐이다.
$$a = \frac{3 \cdot 0 - 0}{5}, b = \frac{2 \cdot 0 - 0}{5}$$

벡터 $(2, 1)$과 벡터 $(1, 3)$은 서로 선형 독립의 관계를 가진다.

다른 두 벡터 $(1, 2)$와 $(2, 4)$를 결합했을 때 벡터 $(5, 5)$를 생성할 수 있는지 알아보자.
$$(5, 5) = a \cdot (1, 2) + b \cdot (2, 4)$$

이 역시 $a$와 $b$의 연립방정식으로 보고 $a$와 $b$의 값을 구하는 문제로 귀결된다.
$$a + 2b = 5$$

$$2a + 4b = 5$$

하지만 이를 만족하는 $a$와 $b$의 값을 구할 수가 없다.
$$2a + 4b = 10$$

$$2a + 4b = 5$$

[그림 2-9](#그림-2-9-평행한-1-2와-2-4의-선형-결합-결과)를 살펴보면 두 벡터 $(1, 2)$와 $(2, 4)$는 평행하지만 $(5, 5)$와는 서로 평행하지 않다.

###### 그림 2-9 평행한 (1, 2)와 (2, 4)의 선형 결합 결과
![평행한 (1, 2)와 (2, 4)의 선형 결합 결과](/img/)

다음 식에서도 볼 수 있듯이, 평행한 두 벡터를 결합한 결과는 두 개의 벡터 결합이 아닌 하나의 벡터 $(1, 2)$에 스칼라 곱을 적용한 결과에 불과하다.
$$(x, y) = a(1, 2) + b(2, 4) = a(1, 2) + 2b(1, 2) = (a + 2b) \cdot (1, 2)$$

따라서 $a$와 $b$에 어떤 스칼라 값을 대입하더라도 선형 결합의 결과는 벡터 $(1, 2)$와 평행한 벡터만 생성될 뿐이고, 이와 평행하지 않은 벡터 $(5, 5)$를 생성하는 것은 불가능하다.   
$(1, 2)$와 $(2, 4)$의 관계를 선형 결합식으로 나타내면 다음과 같다.
$$2 \cdot (1, 2) + (-1) \cdot (2, 4) = (0, 0)$$

0이 아닌 임의의 계수 $a$와 $b$를 사용해 영벡터를 만들수 있으므로 두 벡터 $(1, 2)$와 $(2, 4)$는 선형 종속의 관계를 가진다.   
벡터와 스칼라 곱의 결과는 이들과 평행한 벡터를 생성하므로 결국에는 [그림 2-9](#그림-2-9-평행한-1-2와-2-4의-선형-결합-결과)의 붉은 선상에 위치한 벡터만 생성할 수 있다.  
이로써 ***평면의 모든 점을 생성하기 위한 선형 결합식에는 서로 평행하지 않은 2개의 벡터가 필요함***을 알 수 있으며, ***두 벡터는 서로 선형 독립의 관계를 가져야 함***을 확인할 수 있다.

벡터 3개의 선형 결합으로 평면의 모든 벡터를 만들어 낼 수 있는지 생각해보자.     
앞서 평행하지 않은 두 벡터를 결합해 평면의 모든 벡터를 만들어 낼 수 있음을 확인했다.    
그렇기에 세 번째 벡터는 없어도 되지만 이를 어떻게 수식으로 확인할 수 있을지 알아보자.   
선형 종속과 선형 독립의 관점에서 이를 분석해보면 두 벡터 $(2, 1)$과 $(1, 3)$은 선형 독립의 관계를 지니고 있다.
$$0 \cdot (2, 1) + 0 \cdot (1, 3) = (0, 0)$$

선형 독립인 두 벡터 $(2, 1)$과 $(1, 3)$에 스칼라 $a$와 $b$를 곱하고 새로운 스칼라 $c$와 임의의 벡터 $(x, y)$를 추가해 다음과 같이 세 개의 벡터로 구성된 선형 결합식을 만든다고 가정해보자.
$$a \cdot (2, 1) + b \cdot (1, 3) + c(x, y) = (0, 0)$$

세 벡터가 모두 선형 독립의 관계를 가지려면 위 식을 만족하는 모든 스칼라 $a, b, c$의 값은 0이어야 한다.  
그런데 앞에서 선형 독립인 두 벡터 $(2, 1)$과 $(1, 3)$을 결합해 평면의 모든 벡터를 생성할 수 있었으므로, 두 벡터를 결합해 임의의 벡터$(x, y)$에 $-c$를 곱한 $-c(x, y)$를 생성하는 것도 가능할 것이다.    
그렇다면 다음과 같이 0이 아닌 스칼라 $c$를 사용해 영벡터를 만들 수 있으므로 선형 독립의 관계를 더 이상 만족하지 못한다.
$$-c(x, y) + c(x, y) = (0, 0)$$

따라서 ***선형 독립의 관계가 유지되려면 2개의 벡터만 사용되어야 함***을 알 수 있다.

이러한 벡터의 선형적 관계를 사용해 벡터 공간에 관련된 몇 가지 새로운 용어를 학습해보자.     
예제에서 살펴본 두 벡터 $(2, 1)$과 $(1, 3)$과 같이 ***벡터 공간 내 모든 벡터를 생성할 수 있는 선형 독립 관계를 가지는 벡터의 집합을 기저(Basis)라고 한다***.  
두 벡터 $(1, 0)$과 $(0, 1)$도 선형 독립 관계를 가지므로 기저다.     
***집합의 개념인 기저에 속한 원소를 기저벡터(Basis vector)라고 한다***.   
벡터 $(2, 1)$은 기저 $B = {(2, 1), (1, 3)}$에 속한 기저벡터다.

기저벡터를 다른 값으로 변경하면 기저벡터로부터 세워진 벡터 공간의 모든 원소가 바뀐다고 볼 수 있는데, 이는 ***선형 변환***의 기본 원리가 된다.     
이러한 기저의 개념은 ***차원(Dimension)*** 이라는 새로운 용어를 정의하는데 사용된다.   
평면으로 구성된 벡터 공간을 생성하기 위한 ***기저는 수많은 경우의 수가 존재***하지만, ***기저 집합의 원소 수는 언제나 2개***뿐이다.     
따라서 명확한 정의에 의해 ***평면에 대응하는 벡터 공간***을 ***2차원***으로 정의할 수 있다.

벡터 공간은 두 개의 실수 집합을 결합해 생성한 벡터 공간이다.    
좀 더 구체적인 정보를 제공하기 위해 수 집합의 기호와 차원의 정보를 첨자로 결합해 $R^2$으로 나타내며 이를 ***2차원 실벡터 공간(Real vector space)*** 이라고 부른다.

***2차원을 구성하는 다양한 기저 중에서 한 축만 사용하는 단위 벡터 $(1, 0), (0, 1)$로 구성된 집합을 특별히 표준기저(Standard basis)라고 하며, 기저의 각 원소를 표준기저벡터(Standard basis vector)라고 한다***.     
표준기저벡터는 순서대로 $e_1, e_2$로 표기한다.
$$e_1 = (1, 0)$$

$$e_2 = (0, 1)$$

벡터 공간의 차원에는 제약이 없기 때문에 $R^3, R^4, ..., R^n$으로 무한 확장이 가능하다.  
3차원 실벡터 공간의 표준기저는 늘어난 차원만큼 다음과 같이 구성된다.
$$e_1 = (1, 0, 0)$$

$$e_2 = (0, 1, 0)$$

$$e_3 = (0, 0, 1)$$

# 6. 삼각함수
한 각이 직각(90도)인 직각삼각형을 이루는 세 변은 각 위치에 따라 ***빗변(직각의 대변), 밑변, 높이***라고 부른다.   
한 각이 직각이므로 나머지 두 각의 합이 90도가 되어야 한다.  
따라서 두 각은 모두 90도보다 작은 예각이다.     
빗변과 밑변의 사잇각은 $\theta$를 이용해 [그림 3-1](#그림-3-1-직각삼각형을-구성하는-세-변)과 같이 나타낸다.

###### 그림 3-1 직각삼각형을 구성하는 세 변
![직각삼각형을 구성하는 세 변](/img/)

***직각삼각형을 구성하는 세 변에서 두 변을 뽑아 각각의 비례관계를 나타낸 것을 삼각비(Trigonometric Ratio)라고 한다***.    
삼각비에는 여러 종류가 있지만 ***사인(Sine), 코사인(Cosine), 탄젠트(Tangent)*** 세 가지가 가장 대표적이다.    
밑변의 길이를 $a$, 높이의 길이를 $b$, 빗변의 길이를 $c$, 빗변과 밑변과의 사잇각을 $\theta$라고 할 때, 각 삼각비의 관계는 다음과 같이 분수식으로 표현할 수 있다.
$$\sin \theta = \frac{b}{c}$$

$$\cos \theta = \frac{a}{c}$$

$$\tan \theta = \frac{b}{a}$$

직각삼각형에서 측정할 수 있는 사잇각은 $0^\circ$보다 크거나 $90^\circ$보다 작아야 한다.     
이때 [그림 3-2](#그림-3-2-삼각함수의-개념)와 같이 ***직각삼각형을 데카르트 좌표계 상에 배치하고 사잇각의 범위를 실수 전체($R$ 집합)로 확장한 대응 관계를 삼각함수(Trigonometric function)라고 한다***.

###### 그림 3-2 삼각함수의 개념
![삼각함수의 개념](/img/)

가장 많이 사용하는 삼각함수인 $\sin$ 함수와 $\cos$ 함수의 개념은 직각삼각형에서 출발했지만, 원점을 중심으로 반지름이 1인 평면 위의 ***단위 원(Unit circle)*** 을 사용해 나타내면 좀 더 쉽게 파악할 수 있다.    
데카르트 좌표계에서 원점에서부터 1사분면의 단위 원의 원주 위에 있는 임의의 점을 이어 [그림 3-3](#그림-3-3-길이가-1인-빗변과-사잇각-세타)과 같이 빗변을 그어보면 원의 반지름의 길이는 1이므로 이 빗변의 길이는 항상 1이다.     
$x$축과 해당 빗변이 이루는 각을 사잇각($\theta$)으로 지정한다.

###### 그림 3-3 길이가 1인 빗변과 사잇각 세타
![길이가 1인 빗변과 사잇각 세타](/img/)

[그림 3-4](#그림-3-4-단위-원의-빗변으로-생성한-직각삼각형)처럼 빗변에서 $x$축으로 수직선을 내려 직각삼각형을 그려보자.  
이 직각삼각형으로부터 삼각비를 계산할 수 있다.

###### 그림 3-4 단위 원의 빗변으로 생성한 직각삼각형
![단위 원의 빗변으로 생성한 직각삼각형](/img/)

빗변 $c$의 길이가 1이므로 삼각비 $\sin \theta$의 값은 높이 $b$와 같고 $\cos \theta$ 값은 밑면 $a$와 같다.
$$\sin \theta = \frac{b}{1} = b$$

$$\cos \theta = \frac{a}{1} = a$$

따라서 데카르트 좌표계에서 빗변이 가리키는 단위 원의 좌표는 $(\cos \theta, \sin \theta)$ 로 표현할 수 있는데, 이를 삼각함수로 확장하면 원주 위의 모든 좌표는 [그림 3-5](#그림-3-5-단위-원의-빗변-좌표)와 같이 $(\cos \theta, \sin \theta)$에 대응한다고 할 수 있다.

###### 그림 3-5 단위 원의 빗변 좌표
![단위 원의 빗변 좌표](/img/)

밑변 $a$의 $x$좌표는 $\cos \theta$가 되고 높이 $b$의 $y$좌표는 $\sin \theta$가 되는데 이를 피타고라스 정리 $a^2 + b^2 = c^2$에 대입하면 다음과 같은 공식을 얻을 수 있다.
$$\cos^2 \theta + \sin^2 \theta = 1$$

이번에는 단위 원의 반지름 길이를 $r$로 일반화시켜 생각해보자.   
[그림 3-6](#그림-3-6-길이가-r인-벡터의-x-y값)과 같이 반지름이 $r$인 원에서의 빗변은 벡터의 개념으로 보았을 때 길이가 1인 벡터와 평행하고 길이는 $r$배만큼 증가했으므로 스칼라 곱셈에 의해 $r \cdot (\cos \theta, \sin \theta)$라는 좌표를 갖게 된다.     
이로써 빗변의 길이가 $r$인 직각삼각형의 밑변의 길이는 $r \cdot \cos \theta$가 되고, 높이의 길이는 $r \cdot \sin \theta$가 됨을 알 수 있다.

###### 그림 3-6 길이가 r인 벡터의 x, y값
![길이가 r인 벡터의 x, y값](/img/)

앞서 구한 식은 반지름의 길이와 무관하게 동일하게 성립함을 알 수 있다.
$$r^2(\cos^2 \theta + \sin^2 \theta) = r^2$$

$$\therefore \cos^2 \theta + \sin^2 \theta = 1$$

이 식은 삼각함수의 기본을 이루는 중요한 공식으로, 회전과 관련된 계산에 유용하게 사용된다.

# 6.1. 삼각함수의 성질
***데카르트 좌표계에서 각도(角度)는 $x$축에서 원의 궤적을 따라 반시계 방향으로 회전한 크기를 의미한다***.     
반지름이 1인 단위 원에서 반시계 방향의 회전을 생각해보면, 아직 회전하지 않아 $x$축 상에 위치한 빗변 $\vec{v}$의 좌표는 $(1, 0)$인데, 이 각도는 $0^\circ$에 대응한다고 할 수 있다.   
따라서 각도 $0^\circ$에 대한 $\sin$ 함수와 $\cos$ 함수의 값은 다음과 같다.
$$\vec{v} = (v_x, v_y) = (\cos 0^\circ, \sin 0^\circ) = (1, 0)$$

$$\therefore \sin 0^\circ = 0, \cos 0^\circ = 1$$

각도를 $0^\circ$에서 $90^\circ$까지 서서히 증가시키면서 회전하는 빗변의 좌표 $v_x$와 $v_y$의 변화를 살펴보면 ***각도가 증가할수록 $v_x$값은 감소하고 $v_y$값은 증가한다***.   
그리고 목적지인 $90^\circ$에 도달하면 $y$축 상에 위치한 좌표 $(0, 1)$과 일치하는 벡터가 만들어진다.     
$v_x$값을 보라색으로, $v_y$값을 청록색으로 표시해 좌표의 $x$값과 $y$값의 변화를 추적하면 [그림 3-7](#그림-3-7-0-90-구간에서-sin-함수와-cos-함수의-변화)과 같은 부드러운 곡선이 만들어진다.

###### 그림 3-7 [0, 90] 구간에서 sin 함수와 cos 함수의 변화
![0, 90 구간에서 sin 함수와 cos 함수의 변화](/img/)

***각도가 $90^\circ$를 넘어서면 $v_x$값은 $0$을 지나 음수가 되고, $v_y$값은 다시 $0$을 향해 감소하기 시작한다***.     
계속해서 한바퀴에 해당하는 $360^\circ$까지 빗변의 좌표 변화를 계속 관찰하면, [그림 3-8](#그림-3-8-각도에-따라-변화하는-sin-함수와-cos-함수의-그래프)과 같이 $-1$에 도달할 때까지 계속 감소하다가 $-1$에 도달하면 방향을 바꿔서 $1$을 향해 증가하며, $1$에 도달하면 다시 $-1$을 향해 감소하는 패턴을 반복한다.    
이러한 값의 변화는 $[-1, 1]$ 범위 내에서 $360^\circ$마다 반복되는데, ***변화 값의 범위***를 ***진폭(Amplitude)*** , ***반복되는 각도***를 ***주기(Period)*** 라고 한다.

###### 그림 3-8 각도에 따라 변화하는 sin 함수와 cos 함수의 그래프
![각도에 따라 변화하는 sin 함수와 cos 함수의 그래프](/img/)

$360^\circ$마다 이 패턴이 반복되므로 $\cos$ 함수에 대응하는 $v_x$값의 그래프는 [그림 3-9](#그림-3-9-a-cos-함수와-b-sin-함수-그래프)의 (a), $\sin$ 함수에 대응하는 $v_y$값의 그래프는 (b)의 형태를 가진다.

###### 그림 3-9 (a) cos 함수와 (b) sin 함수 그래프
![(a) cos 함수와 (b) sin 함수 그래프](/img/)

[그림 3-9](#그림-3-9-a-cos-함수와-b-sin-함수-그래프)의 그래프로부터 $\sin$ 함수와 $\cos$ 함수의 성질을 정리하면 다음과 같다.

1. $\sin$ 함수와 $\cos$ 함수는 항상 $-1$에서 $1$ 사이를 일정하게 반복되는 패턴을 띈다.
2. $\sin$ 함수와 $\cos$ 함수의 값은 $360^\circ$ 주기로 반복된다.
3. $y$축을 기준으로 좌우를 접어 포갰을 때 ***$\cos$ 함수 그래프는 데칼코마니처럼 좌우 대칭***인 반면, ***$\sin$ 함수 그래프는 상하가 반전된 원점 대칭***의 형태를 띤다.     
$\cos$ 함수와 같이 좌우 대칭의 성질을 가진 함수를 ***짝함수(Even function)*** 또는 ***우함수*** 라고 부르며, $\sin$ 함수와 같이 원점 대칭의 성질을 가진 함수를 ***홀함수(Odd function)*** 또는 ***기함수*** 라고 부른다.

3번에서 언급한 $\sin$ 함수와 $\cos$ 함수 그래프가 지니는 홀함수와 짝함수의 성질은 다음 식과 같이 정리할 수 있다.    
이는 회전에 관련된 계산에 유용하게 사용된다.
$$\cos(-\theta) = \cos(\theta)$$

$$\sin(-\theta) = -\sin(\theta)$$

***$\tan$ 함수는 빗변과 무관하게 밑변과 높이의 관계만을 나타낸다***.
$$\tan \theta = \frac{b}{a}$$

이 식의 분자와 분모를 모두 빗변의 값으로 각각 나누면 다음 수식과 같이 ***$\cos$과 $\sin$으로 $\tan$ 함수를 표현할 수 있다***.
$$\tan \theta = \frac{\frac{b}{c}}{\frac{a}{c}} = \frac{\sin \theta}{\cos \theta}$$

분모의 값은 $0$이 될 수 없기 때문에 ***분모에 해당하는 $\cos$ 함수 값이 $0$이 되는 $90^\circ$에서는 $\tan$ 값이 존재하지 않는다***.   
이는 ***$270^\circ$인 경우에도 동일***하고 ***$-90^\circ$, $-270^\circ$인 경우***에도 마찬가지다.   
그렇기 때문에 ***$\tan$ 함수의 정의역에는 해당 구간이 포함되지 않는다***.     
[그림 3-10](#그림-3-10-tan-함수의-그래프)은 $\tan$ 함수의 그래프며 $\sin$ 함수와 동일하게 ***홀함수의 성질***을 지님을 알 수 있다.

###### 그림 3-10 tan 함수의 그래프
![tan 함수의 그래프](/img/)

# 6.2. 각의 측정법
일반적으로 일상 생활에서 ***각(Angle)*** 의 크기를 잴 때 0에서 360까지의 수를 사용하는 ***각도법(Degree)*** 을 사용한다.  
각도법에서 기준으로 삼는 360이라는 수는 약수가 많아 원을 다양한 방법으로 쪼개어 활용할 수 있기 때문인데, 이는 일상생활에서의 편리를 위한 것일 뿐, 360이라는 값은 표준으로 사용하기에는 너무 큰 수다.

벡터의 경우 크기를 비교하기 용이하도록 크기 1의 단위 벡터를 정의한 것처럼, 각을 측정할 때도 단위량 1을 기반으로 상대적인 크기를 측정할 수 있도록 체계를 만들어야 합리적이다.    
실무 계산에서 삼각함수를 응용할 때에는 각도법 대신 ***호의 길이를 기준으로 각을 측정하는 방법***을 사용한다.  
이를 ***호도법(Radian)*** 이라 부른다.     
***호도법은 호의 길이가 1이 되는 부채꼴의 각을 기준으로 각을 측정한다***.     
[그림 3-11](#그림-3-11-반지름이-1인-반원)과 같이 원점에 중심을 둔 반지름이 1인 단위 반원을 그리고 반원의 호 길이를 비교하기 위해 $x$축에 원점에서 크기가 1인 벡터를 청록색으로 함께 배치한다.

###### 그림 3-11 반지름이 1인 반원
![반지름이 1인 반원](/img/)

반원의 호 길이를 재기 위해 [그림 3-12](#그림-3-12-반원의-왼쪽-끝을-원점으로-이동한-결과)와 같이 반원의 왼쪽 끝점을 원점으로 평행이동시킨다.

###### 그림 3-12 반원의 왼쪽 끝을 원점으로 이동한 결과
![반원의 왼쪽 끝을 원점으로 이동한 결과](/img/)

그러고 나서 반원의 왼쪽 끝(원점에 놓인 붉은색 점)을 고정한 후 $x$축의 양의 방향으로 반원의 오른쪽 끝점을 잡아당겨 $x$축 위에 쭉 펼친 후, 그 길이(보라색 선)를 $x$축 상의 단위 벡터(청록색)와 함께 비교해보면 펼친 결과는 [그림 3-13](#그림-3-13-반원호의-길이-측정)과 같을 것이다.

###### 그림 3-13 반원호의 길이 측정
![반원호의 길이 측정](/img/)

반원의 호 길이는 단위 벡터의 길이 1보다 대략적으로 3.14배 더 큰데, 정확한 값을 구할 수는 없다.  
이것이 ***3.141592...로 이어지는 무리수인 원주율 파이($\pi$)*** 다.

$180^\circ$에 해당하는 반원의 호 길이가 파이($\pi$)임을 알았으니, 이번에는 거꾸로 호의 길이가 1인 부채꼴의 중심각은 몇 도인지 생각해보자.   
호의 길이를 1로 설정하면 [그림 3-14](#그림-3-14-1rad의-정의)와 같은 부채꼴이 나오는데, 이 부채꼴의 각이 바로 호도법에서 사용하는 각의 기준인 ***$1rad$(라디안)*** 이다.    
***1라디안은 각도로 환산하면 약 $57.2958^\circ$가 되며 이 역시 $\pi$와 같은 무리수다***.

###### 그림 3-14 1rad의 정의
![1rad의 정의](/img/)

$180^\circ$에 해당하는 반원의 각을 라디안으로 표현하면 얼마인지 알아보자.   
반원의 호 길이는 파이($\pi$)이므로 각 역시 라디안을 기준으로 $\pi$배만큼 클 것이다.     
따라서 각도법과 호도법 사이에는 다음의 대응 관계가 성립한다.
$$\pi(rad) = 180^\circ$$

이 수식을 응용해 다음의 변환식을 만들 수 있다.
$$1^\circ = \frac{\pi}{180}(rad)$$

$$1(rad) = (\frac{180}{\pi})^\circ$$

[표 3-1]은 수식에서 자주 사용하는 각도와 라디안 값을 대응시켜 정리한 표다.

###### 표 3-1 가장 흔히 사용하는 각의 각도와 호도 표기
|각도법|호도법|
|---|---|
|$30^\circ$|$\frac{\pi}{6}$|
|$45^\circ$|$\frac{\pi}{4}$|
|$60^\circ$|$\frac{\pi}{3}$|
|$90^\circ$|$\frac{\pi}{2}$|
|$180^\circ$|$\pi$|
|$360^\circ$|$2\pi$|

# 7. 삼각함수를 활용한 물체의 회전
벡터의 회전은 생각보다 까다롭다.    
물체를 이동시키고 크기를 늘리는 동작은 [그림 3-15](#그림-3-15-축마다-별도로-적용되는-이동-변환)의 (a)와 같이 ***서로 수직인 $x$축과 $y$축이 서로 독립적으로 적용***된다.   
따라서 (b)와 같이 $x$축과 $y$축을 분리해 따로따로 계산한 후 두 결과를 결합한 것과 동일하다.

###### 그림 3-15 축마다 별도로 적용되는 이동 변환
![축마다 별도로 적용되는 이동 변환](/img/)

하지만 회전이라는 동작은 $x$와 $y$의 값이 함께 영향을 미치기 때문에 [그림 3-15](#그림-3-15-축마다-별도로-적용되는-이동-변환)처럼 $x$축과 $y$축을 분리해 독립적으로 계산할 수 없다.   
***회전을 구현하기 위해 기저벡터의 개념을 활용할 수 있다***.  
실벡터 공간 $R^2$는 두 표준기저벡터 $e_1, e_2$를 기저로 둔 공간이고, 공간에 속한 모든 벡터는 $e_1$과 $e_2$의 선형 결합에 의해 생성된다.     
회전을 위해 실벡터 공간 $R^2$ 전체를 각 $\theta$만큼 회전시키면 두 표준기저벡터 $e_1$과 $e_2$의 좌표는 [그림 3-16](#그림-3-16-공간-변화에-따른-기저벡터의-변화)과 같이 변화될 것이다.

###### 그림 3-16 공간 변화에 따른 기저벡터의 변화
![공간 변화에 따른 기저벡터의 변화](/img/)

표준기저벡터 $e_1$이 각 $\theta$만큼 회전한 좌표는 [그림 3-5](#그림-3-5-단위-원의-빗변-좌표)에서 확인했듯이 $(\cos \theta, \sin \theta)$이 된다.    
이를 다음과 같이 $e_1'$으로 표시한다.
$$e_1' = (\cos \theta, \sin \theta)$$

표준기저벡터 $e_2$가 각 $\theta$만큼 변한 좌표를 확인해보자.    
[그림 3-16](#그림-3-16-공간-변화에-따른-기저벡터의-변화)을 관찰해보면 $e_1'$의 $y$좌표만큼 음의 $x$값을 가지고, $x$좌표만큼 양의 $y$값을 가지고 있음을 알 수 있다.  
이를 $e_2'$으로 표시하면 좌표는 다음과 같다.
$$e_2' = (-\sin \theta, \cos \theta)$$

실벡터 공간 $R^2$의 벡터가 각 $\theta$만큼 회전하면 어떻게 변화되는지 수식으로 확인해보자.  
이를 위해 좌표 $(1, 1)$의 값을 가진 벡터 $\vec{v}$를 사용한다.  
회전되기 전의 벡터 $\vec{v}$는 표준기저벡터 $e_1$과 $e_2$를 사용해 다음의 선형 결합식으로 표현할 수 있다.
$$\vec{v} = 1 \cdot e_1 + 1 \cdot e_2$$

여기서 벡터 $\vec{v}$가 각 $\theta$만큼 회전한 벡터 $\vec{v'}$는 위 선형 결합식의 $e_1$과 $e_2$를 회전된 표준기저벡터 $e_1'$과 $e_2'$으로 치환해 얻을 수 있다.
$$\vec{v'} = 1 \cdot (\cos \theta, \sin \theta) + 1 \cdot (-\sin \theta, \cos \theta)$$

따라서 좌표 $(1, 1)$이 각 $\theta$만큼 회전한 벡터 $\vec{v'}$의 좌표는 다음과 같이 얻을 수 있다.
$$\vec{v'} = (\cos \theta - \sin \theta, \sin \theta + \cos \theta)$$

좌표 $(1, 1)$의 벡터 $\vec{v}$가 각 $\theta$만큼 회전하는 과정을 정리하면 [그림 3-17](#그림-3-17-벡터-1-1을-각-세타만큼-회전한-결과)과 같다.

###### 그림 3-17 벡터 (1, 1)을 각 세타만큼 회전한 결과
![벡터 (1, 1)을 각 세타만큼 회전한 결과]

이와 동일한 원리로 임의의 벡터 $\vec{u} = (x, y)$에 대해 각 $\theta$만큼 회전한 벡터 $\vec{u'} = (x', y')$을 구할 수 있는 일반적인 수식을 전개할 수 있다.   
실벡터 공간 $R^2$의 두 표준기저벡터를 $e_1, e_2$라고 할 때 각 $\theta$만큼 회전한 벡터 $\vec{u'}$은 다음의 수식으로 정리할 수 있다.
$$\vec{u} = (x, y) = x \cdot e_1 + y \cdot e_2 = x \cdot (1, 0) + y \cdot (0, 1)$$

$$\vec{u'} = (x', y') = x \cdot (\cos \theta, \sin \theta) + y \cdot (-\sin \theta, \cos \theta) \\
= (x \cos \theta - y \sin \theta, x \sin \theta + y \cos \theta)$$

따라서 임의의 벡터 $(x, y)$가 각 $\theta$만큼 회전된 결과 $(x', y')$는 다음과 같다.
$$x' = x \cos \theta - y \sin \theta$$

$$y' = x \sin \theta + y \cos \theta$$

# 8. 삼각함수의 역함수
삼각함수를 사용해 주어진 각에 대응하는 벡터의 좌표를 얻을 수 있다.  
게임 제작 과정에서는 거꾸로 ***주어진 벡터의 좌표로부터 이에 대응하는 각도***를 얻어내는 작업도 필요하다.     
이를 계산하려면 삼각함수의 역함수와 이에 대한 성질을 알아야 한다.   
임의의 각 $x$에 대응되는 $sin$ 함수는 다음과 같이 표기할 수 있다.
$$y = f(x) = \sin(x)$$

$\sin$ 함수가 가진 $x$와 $y$ 사이의 대응 관계를 살펴보면 ***정의역의 여러 요소가 공역의 한 요소에 대응***되는 것을 알 수 있다.

###### 그림 3-18 sin 함수의 그래프
![sin 함수의 그래프](/img/)

만일 공역의 범위를 실수 집합 전체가 아닌 $[-1, 1]$ 구간으로 한정해 정의한다면, $\sin$ 함수는 전사함수의 성질을 띤다.     

###### 그림 3-19 영역을 제한시켜 전사함수의 성질을 가지게 된 sin 함수
![영역을 제한시켜 전사함수의 성질을 가지게 된 sin 함수](/img/)

여기서 정의역의 범위를 $[-90^\circ, 90^\circ]$ 구간으로 좁히면 정의역의 한 요소가 공역의 한 요소에 대응되는 전단사함수가 된다.

###### 그림 3-20 영역을 제한시켜 전단사함수의 성질을 가지게 된 sin 함수
![영역을 제한시켜 전단사함수의 성질을 가지게 된 sin 함수](/img/)

이렇게 어떤 함수를 ***전단사함수***로 만든다면, $\sin x$값이 주어졌을 때 거꾸로 각 $x$를 구할 수 있는 ***역함수***가 존재하게 된다.     
이와 같이 ***정의역과 공역의 범위를 제한***시켜 얻은 $\sin$ 함수의 역함수를 ***$\arcsin$(아크사인)*** 함수라고 부른다.
$$f^{-1}(x) = \sin^{-1}(x) = \arcsin(x)$$

$\arcsin$ 함수의 그래프는 [그림 3-21](#그림-3-21-arcsin-함수의-그래프)과 같다.

###### 그림 3-21 arcsin 함수의 그래프
![arcsin 함수의 그래프](/img/)

이와 동일하게 $\cos$ 함수의 역함수를 구하기 위해 $\cos$ 함수가 전단사함수가 되도록 정의역과 공역을 제한하면 정의역은 $[0^\circ, 180^\circ]$, 공역은 $[-1, 1]$이다.

###### 그림 3-22 cos 함수의 그래프
![cos 함수의 그래프](/img/)

이로부터 생성한 역함수를 $\arccos$(아크코사인) 함수라고 한다.   
$\arccos$ 함수의 그래프는 [그림 2-23](#그림-3-23-arccos-함수의-그래프)과 같다.

###### 그림 3-23 arccos 함수의 그래프
![arccos 함수의 그래프](/img/)

$\tan$ 함수의 역함수를 구하기 위해서는 $\tan$ 함수가 전단사함수가 되어야 한다.  
[그림 3-24](#그림-3-24-tan-함수의-그래프)에서 보듯이 ***$\tan$ 함수의 치역은 실수 영역 전체인데 반해, 정의역이 존재하지 않는 구간이 존재***하는 것이 문제다.    
따라서 $\tan$ 함수의 ***정의역 구간을 제한해서 한정***해야 할 것이다.

###### 그림 3-24 tan 함수의 그래프
![tan 함수의 그래프](/img/)

$\tan$ 함수는 $x$값이 $-90^\circ$와 $90^\circ$일 때의 $y$값이 존재하지 않으므로 전단사함수가 되기 위한 정의역 구간은 $-90^\circ$와 $90^\circ$ 값을 제외한 $(-90^\circ, 90^\circ)$ 범위가 되어야 한다.   
$\arctan$(아크탄젠트) 함수의 그래프는 [그림 3-25](#그림-3-25-arctan-함수의-그래프)와 같다.

###### 그림 3-25 arctan 함수의 그래프
![arctan 함수의 그래프](/img/)

***$\arctan$ 함수는 벡터의 각도를 구하는 데 유용하게 사용된다***.     
임의의 벡터를 $\vec{v} = (x, y)$라고 할 때 분수식$\frac{y}{x}$를 계산해 벡터로부터 $\tan$ 함수 값을 얻을 수 있다.   
이 $\tan$ 값을 $\arctan$ 함수에 넣으면 해당 벡터가 $x$축과 이루는 사잇각을 얻어낼 수 있다.

###### 그림 3-26 벡터의 각
![벡터의 각](/img/)

$\arctan$ 함수의 치역은 $(-90^\circ, 90^\circ)$ 구간이므로 $\arctan$ 함수로 얻을 수 있는 각의 범위에는 한계가 있다.     
이는 $\arcsin$ 함수와 $\arccos$ 함수도 동일한 상황이다.

###### 그림 3-27 삼각함수의 역함수로 얻을 수 있는 각의 범위
![삼각함수의 역함수로 얻을 수 있는 각의 범위](/img/)

하지만 $\arctan$ 함수의 경우, 인자에 분수 $\frac{y}{x}$ 값을 넣지 않고 $x$와 $y$의 두 값을 분리해 전달하면 4분면 전체에 해당하는 각의 정보를 얻을 수 있다.  
예를 들어 [그림 3-28](#그림-3-28-3사분면에-위치한-벡터의-사잇각)과 같이 3사분면에서 $x$값의 부호가 음이고, $y$의 부호도 음인 경우를 생각해보자.

###### 그림 3-28 3사분면에 위치한 벡터의 사잇각
![3사분면에 위치한 벡터의 사잇각](/img/)

분수값 $\frac{y}{x}$의 결과는 양수기 때문에, 이를 $\arctan$ 함수에 전달하면 3사분면의 정보는 사라지고 1사분면에 해당하는 각의 정보가 나와 처음에 사용한 벡터를 얻어낼 수 없다.

###### 그림 3-29 arctan 함수를 사용하는 경우의 문제점
![arctan 함수를 사용하는 경우의 문제점](/img/)

하지만 $\arctan$ 함수에 $x$와 $y$ 두 값을 따로 전달한다면 두 값이 가지는 부호를 파악해 벡터가 1사분면에 있었는지 3사분면에 있었는지를 파악할 수 있다.   
그래서 $\arctan$ 함수에는 분수값 $\frac{y}{x}$를 계산해 전달하는 함수와 $x$와 $y$를 따로 전달하는 함수의 두 종류가 있다.

$x$와 $y$를 따로 전달하는 $\arctan$ 함수를 $atan2$ 함수라고 부르며, 이는 분수 $\frac{y}{x}$를 연상하기 쉽게 $y$값에 이어 $x$값을 전달하도록 설계되어 있다.   
$atan2$를 사용하면 평면의 모든 사분면에 대응하는 각도를 얻을 수 있다.
$$atan2(y, x)$$

각의 크기를 $x$축으로 둔 $atan2$ 함수의 그래프는 [그림 3-30](#그림-3-30-atan2-함수의-그래프)과 같으며 이의 공역은 $(-180^\circ, 180^\circ)$ 범위를 가진다.

###### 그림 3-30 atan2 함수의 그래프
![atan2 함수의 그래프](/img/)

# 9. 극좌표계
***물체를 이동시키고 크기를 늘리는 동작은 $x$와 $y$가 독립적으로 적용되는 움직임***인 데 반해, ***회전은 $x$와 $y$가 함께 영향받는 동작***이다.   
따라서 데카르트 좌표계로 회전을 구현하면 회전에 따른 $x$와 $y$의 변화를 매번 계산하는 번거로움이 발생한다.

회전 동작을 기반으로 설계된 좌표계를 고안해 사용한다면, 이로부터 편리하게 회전을 관리하고 구현할 수 있다.   
이를 위해 고안된 좌표게가 바로 ***극좌표계(Polar coordinate system)*** 다.     
극좌표계는 원점으로부터의 거리 $r$과 각 $\theta$의 두 요소로 구성되며 극좌표계의 좌표는 $(r, \theta)$로 표시한다.

극좌표계는 [그림 3-31](#그림-3-31-극좌표계의-개념)과 같이 동심원의 형태로 평면의 모든 점을 표현하며, 주로 시간에 따른 회전의 움직임을 구현하거나 회전에 관련된 효과를 연출할 때 활용된다.

###### 그림 3-31 극좌표계의 개념
![극좌표계의 개념](/img/)

데카르트 좌표계로 표현된 벡터 $(x, y)$는 벡터의 크기와 $\arctan$함수를 사용해 다음과 같이 극좌표계 $(r, \theta)$로 변환할 수 있다.
$$r = \sqrt{x^2 + y^2}$$

$$\theta = atan2(y, x)$$

반대로 극좌표계의 좌표 $(r, \theta)$를 데카르트 좌표계 $(x, y)$로 변환하는 식은 삼각함수를 사용해 구할 수 있다.
$$x = r \cdot \cos \theta$$

$$y = r \cdot \sin \theta$$

# 10. 선형성: 예측 가능한 비례 관계
원점에서 시작하는 벡터와 스칼라 곱셈으로 생성된 벡터는 [그림 4-1](#그림-4-1-스칼라-곱셈-연산을-시각화한-예시)과 같이 그 벡터와 평행한 원점을 지나는 붉은 직선 상에 위치한다.

###### 그림 4-1 스칼라 곱셈 연산을 시각화한 예시
![스칼라 곱셈 연산을 시간화한 예시](/img/)

그림에서와 같이 붉은색으로 표현된 쭉 뻗은 직선이 지는 성질을 ***선형성(Linearity)*** 이라고 한다.  
즉 선형성은 ***직선의 형태를 띠는 성질***을 의미한다.     
수학에서는 선형성을 다음과 같은 ***가법성(Additivity)*** 과 ***1차 동차성(Homogeneity of degree 1)*** 두 가지 조건을 모두 만족하는 함수의 성질로 정의한다.   
- $f(x_1 + x_2) = f(x_1) + f(x_2)$ <- 가법성  
- $f(k \cdot x) = k \cdot f(x)$ <- 1차 동차성

# 10.1. 선형 함수
입력에 사용하는 요소 $x$와 출력이 모두 실수인 함수에서 원점을 지나는, 다음과 같은 직선의 함수를 생각할 수 있다.
$$f(x) = ax$$

출력의 원소를 $y$로 표시했을 때 위 함수는 $y = ax$로 표현되며, 이를 그래프로 나타내면 [그림 4-2](#그림-4-2-함수-y--ax-형태의-한-예시)와 같다.

###### 그림 4-2 함수 y = ax 형태의 한 예시
![함수 y = ax 형태의 한 예시](/img/)

직선 형태를 띠는 이 함수가 선형성을 만족하는지를 직접 수학적으로 확인하기 위해 선형성의 첫 번째 성질인 ***가법성***을 만족하는 수식 $f(x_1 + x_2) = f(x_1) + f(x_2)$에서 좌변 $f(x_1 + x_2)$과 우변 $f(x_1) + f(x_2)$의 값이 동일한지 확인하는 것으로 판별할 수 있다.     
그림으로 표현하면 [그림 4-3](#그림-4-3-가법성의-검증)과 같다.

###### 그림 4-3 가법성의 검증
![가법성의 검증](/img/)

함수 $f(x) = ax$에 두 미지수 $x_1, x_2$를 대입해 좌변과 우변을 계산한 결과는 다음과 같다.   
- 좌변: $f(x_1 + x_2) = a(x_1 + x_2)$     
- 우변: $f(x_1) + f(x_2) = ax_1 + ax_2$

$a, x_1, x_2$가 모두 ***체의 성질***을 가지는 실수라면 ***분배법칙***에 의해 $a(x_1 + x_2) = ax_1 + ax_2$가 성립한다.   
따라서 함수 $f(x) = ax$는 ***가법성***을 만족함을 알 수 있다.

선형성의 두 번째 성질인 ***1차 동차성***을 만족하는 수식 $f(k \cdot x) = k \cdot f(x)$의 검증 과정을 그림으로 나타내면 [그림 4-4](#그림-4-4-1차-동차성의-검증)와 같다.

###### 그림 4-4 1차 동차성의 검증
![1차 동차성의 검증](/img/)

***1차 동차성***을 만족하는 수식 $f(k \cdot x) = k \cdot f(x)$에 함수 $f(x) = ax$를 적용해 좌변과 우변을 계산한 결과는 다음과 같다.
- 좌변: $f(kx) = a(kx)$
- 우변: $kf(x) = k(ax)$

이때 $a, x, k$가 모두 ***체의 성질***을 가지는 실수라면 ***체는 곱셈에 대해 결합법칙과 교환법칙이 성립***하므로, $a(kx) = k(ax)$가 성립한다.    
따라서 함수 $y = ax$는 ***1차 동차성***을 만족함을 확인할 수 있다.

가법성과 1차 동차성, 두 가지 성질을 만족하는 함수 $y = ax$는 선형성을 만족한다는 사실을 알 수 있다.     
수식을 사용해 [그림 4-5](#그림-4-5-y--x2의-그래프)와 같이 곡선의 형태를 띠는 $f(x) = x^2$과 같은 함수는 선형성을 만족하는지 수학적으로 검증해보자.

###### 그림 4-5 y = x^2의 그래프
![y = x^2의 그래프](/img/)

가법성을 만족하는지 파악하기 위해 가법성을 만족하는 수식 $f(x_1 + x_2) = f(x_1) + f(x_2)$에 함수 $f(x) = x^2$를 적용해 양변을 전개하면 다음과 같다.
- 좌변: $f(x_1 + x_2) = (x_1 + x_2)^2 = x_1^2 + x_2^2 + 2x_1x_2$
- 우변: $f(x_1) + f(x_2) = x_1^2 + x_2^2$

좌변과 우변의 결과가 각기 다르므로 함수 $y = x^2$은 가법성을 만족하지 못하므로 ***선형성을 만족하는 함수가 아님***을 확인할 수 있다.

함수 $f(x) = ax$에 스칼라 $b$를 더한 $f(x) = ax + b$는 선형성을 만족하는지 확인하기 위해 [그림 4-6](#그림-4-6-y--ax--b의-그래프)과 같이 그래프로 그려보면 직선 형태를 띤다.

###### 그림 4-6 y = ax + b의 그래프
![y = ax + b의 그래프](/img/)

함수 $f(x) = ax + b$에 가법성을 판별하는 수식의 좌변과 우변에 두 미지수 $x_1, x_2$를 대입한 결과는 다음과 같다.
- 좌변: $f(x_1 + x_2) = a(x_1 + x_2) + b$
- 우변: $f(x_1) + f(x_2) = ax_1 + ax_2 + 2b$

두 변의 계산 결과는 $b$만큼 차이가 나게 되어 원점을 지나지 않는 함수 $f(x) = ax + b$는 가법성을 만족하지 못함을 확인할 수 있다.     
***선형성이란 단지 곧게 뻗은 직선의 성질을 뜻하는 것이 아니라, 두 집합의 순수한 비(Ratio)로 구성된 1차적 대응 관계를 의미한다***.     
함수 $f(x) = ax$에서 대응되는 ***두 집합***은 ***순수한 비***로 구성되어 있기 때문에 다른 입력값을 투여했을 때 어떤 출력값이 나올지 쉽게 예측할 수 있으며, 반대로 ***역함수*** $f(x) = \frac{1}{a}x$를 사용하면 ***출력값으로부터 입력값을 거꾸로 계산***하는 것이 가능하다.

# 10.2. 벡터 공간의 선형 변환
입력과 출력을 2차원 벡터 공간으로 설정한 상황에서 선형성을 가지는 함수에 대해 알아보자.     
정의역에 해당하는 벡터 공간을 $V$, 그 원소를 $\vec{v}$로, 공역에 해당하는 벡터 공간을 $W$, 그 원소 $\vec{w}$로 표시하고 두 벡터 공간의 대응관계를 표현하면 [그림 4-7](#그림-4-7-벡터를-입출력으로-하는-함수)과 같다.

###### 그림 4-7 벡터를 입출력으로 하는 함수
![벡터를 입출력으로 하는 함수](/img/)

2차원 벡터를 입력받고 2차원 벡터를 출력하는 함수에서 선형성을 가지는 함수를 설계해보자.     
입력에 사용한 2차원 벡터가 $(x, y)$로 구성되어 있는 경우, $x$와 $y$는 서로 독립된 관계를 형성한다.

***선형성을 가지는 함수는 순수한 비의 형태로 구성되어 있다***.    
따라서 $x$와 $y$ 각각에 대해 선형성을 유지하고자 한다면 이들은 $ax$와 $by$ 같은 ***단순 비의 형태를 사용***할 것이고, 이를 섞은 최종 결과는 ***각 비의 결과를 더한*** $ax + by$의 형태가 될 것이다.     
따라서 2차원 벡터를 입출력으로 사용하는 선형성을 가지는 함수는 다음과 같이 설계할 수 있다.
$$f(\vec{v}) = f(x, y) = (ax + by, cx + dy)$$

가법성 확인.
- 좌변의 식:

$$
\begin{matrix}
f(\vec{v_1} + \vec{v_2}) & = & f(x_1 + x_2, y_1 + y_2) \\
& = & (a(x_1 + x_2) + b(y_1 + y_2), c(x_1 + x_2) + d(y_1 + y_2))
\end{matrix}
$$

- 우변의 식:

$$
\begin{matrix}
f(\vec{v_1}) + f(\vec{v_2}) &=& (ax_1 + by_1, cx_1 + dy_1) + (ax_2 + by_2, cx_2 + dy_2) \\
&=& (ax_1 + ax_2 + by_1 + by_2, cx_1 + cx_2 + dy_1 + dy_2) \\
&\therefore& f(\vec{v_1} + \vec{v_2}) = f(\vec{v_1}) + f(\vec{v_2})
\end{matrix}
$$

1차 동차성 확인.
- 좌변의 식:
$$
kf(\vec{v}) = (kax + kby, kcx + kdy)
$$

- 우변의 식:
$$
f(k\vec{v}) = (akx + bky, ckx + dky) \\
\therefore kf(\vec{v}) = f(k\vec{v})
$$

함수 $f(x, y) = (ax + by, cx + dy)$는 ***가법성***과 ***1차 동차성***을 만족하므로 ***선형 함수***다.     
***표준기저벡터의 선형 결합으로 형성된 벡터 공간은 선형성을 지닌다***.    
이 벡터 공간을 ***선형 함수***로 ***변화***시킨 새로운 공간도 기저벡터의 선형 결합으로 형성되므로 선형성을 지닌다.  
이렇게 두 공간이 동일한 구조를 지닐 때 두 공간의 대응 관계를 ***변환(Transoformation)*** 이라고도 부른다.  
따라서 선형성을 유지시켜주는 선형 함수 $f(x, y) = (ax + by, cx + dy)$는 ***선형 변환(Linear transformation)*** 이라고 한다.

벡터 공간에서 발생하는 선형 변환의 원리는 ***크기 변환***이나 ***회전 변환***과 관련이 있다.    
임의의 벡터 $\vec{v}$의 크기를 $k$배 늘리는 작업은 다음과 같이 스칼라 곱셈으로 표현이 가능했다.
$$f(\vec{v}) = f(x, y) = (kx, ky)$$

이는 $(ax + by, cx + dy)$의 형식에 $a = k, b = 0, c = 0, d = k$를 대입한 결과와 동일하므로 선형 변환임을 알 수 있다.    
그리고 임의의 벡터 $\vec{v}$를 각 $\theta$만큼 회전시키는 작업은 다음과 같은 함수로 표현이 가능했다.
$$f(\vec{v}) = f(x, y) = (\cos \theta x - \sin \theta y, \sin \theta x + \cos \theta y)$$

이 역시 $(ax + by, cx + dy)$의 형식에서 $a = \cos \theta, b = -\sin \theta, c = \sin \theta, d = \cos \theta$ 값인 셈이므로 선형 변환이다.  
벡터 공간에서의 선형 변환은 앞서 살펴본 단순한 비례 관계로 구성된 선형 함수 $f(x) = ax$처럼 두 집합의 순수한 비를 통해 ***예측할 수 있는 형태로 변환***되며, ***역함수를 통해 변환 후의 벡터로부터 변환 전의 벡터를 파악할 수 있다***.

선형 변환의 계산 과정을 체계화하여 손쉽게 계산할 수 있는 편리한 도구를 발명했는데, 그것이 바로 ***행렬(Matrix)*** 이다.

# 11. 행렬
***행렬은 수를 사각형의 형태로 행과 열을 맞춰 배열한 테이블이다***.   
따라서 $n$개의 행과 $m$개의 열로 구성된 반듯한 사각형의 형태를 띤다.    
예를 들어 $2 \times 3$ 행렬은 다음과 같이 2행 3열의 형태를 띤다.

$$
\begin{bmatrix}
a & b & c \\
d & e & f \\
\end{bmatrix}
$$

행렬은 ***선형 변환***과 ***벡터***를 나타내는 데 사용된다.     
***벡터는 한 줄로 구성된 행렬로 표현***되며, 가로와 세로 두 가지 표현 방식이 존재한다.    
$(x, y)$로 구성된 2차원의 벡터는 다음과 같은 행렬로 표기할 수 있는데, $A$는 ***열벡터***, $B$는 ***행벡터***라고 부른다.

$$A = 
\begin{bmatrix} 
x \\
y \\
\end{bmatrix}
$$

$$B = 
\begin{bmatrix}
x & y
\end{bmatrix}
$$

***선형 변환***을 표현할 때는 행과 열이 크기가 같은 ***정방행렬(Square matrix)*** 을 사용한다.   
2차원 벡터 공간의 선형 변환 $f(x, y) = (ax + by, cx + dy)$는 $2 \times 2$ 크기의 정방행렬로 표현하는데, 이에 대응하는 행렬 $A$는 다음과 같다.

$$
A = 
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix}
$$

정방행렬 $A$는 ***2개의 행벡터 또는 2개의 열벡터로 구성***된다고 할 수 있다.  
정방행렬 $A$를 행벡터와 열벡터로 분석하면, 첫 번째 행벡터 $A_{row1}$은 $(a, b)$, 두 번째 행벡터 $A_{row2}$는 $(c, d)$이고, 첫 번째 열벡터 $A_{col1}$은 $(a, c)$, 두 번째 열벡터 $A_{col2}$는 $(b, d)$가 된다.
$$A_{row1} = (a, b)$$

$$A_{row2} = (c, d)$$

$$A_{col1} = (a, c)$$

$$A_{col2} = (b, d)$$

# 11.1. 행렬의 기본 연산
행렬은 사각형의 형태로 수를 배열한 것에 불과하지만 지정된 계산 방법을 통해 많은 문제를 해결할 수 있다.  
- 행렬과 행렬의 덧셈
- 행렬과 스칼라의 곱셈
- 행렬의 전치(Transpose of a matrix)
- 행렬과 행렬의 곱셈(줄여서 행렬 곱이라 부름)

***행렬과 행렬의 덧셈은 행렬의 크기가 같은 경우에만 성립***되며, 다음과 같이 ***같은 위치의 원소끼리 더한다***.

$$A + B = 
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix} +
\begin{bmatrix}
e & f \\
g & h \\
\end{bmatrix} =
\begin{bmatrix}
a + e & b + f \\
c + g & d + h \\
\end{bmatrix}
$$

행렬에 스칼라를 곱하는 연산은 다음과 같이 ***행렬을 구성하는 모든 원소에 스칼라를 곱한다***.

$$k \cdot A = k \cdot 
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix} =
\begin{bmatrix}
k \cdot a & k \cdot b \\
k \cdot c & k \cdot d \\
\end{bmatrix}
$$

행렬의 전치연산은 첨자 $T$로 표시하는데 ***행과 열을 바꾸는 작업을 수행***한다.   
예를 들어 $3 \times 2$ 행렬의 전치연산은 $2 \times 3$ 행렬이 된다.

$$
\begin{bmatrix}
a & d \\
b & e \\
c & f \\
\end{bmatrix}^{T} = 
\begin{bmatrix}
a & b & c \\
d & e & f \\
\end{bmatrix}
$$

행과 열의 크기가 같은 정방행렬의 전치연산은 행과 열의 정보가 동일한 ***대각 성분의 원소***는 그대로 유지되고, 나머지 원소는 대각 성분을 중심으로 대칭된 행렬을 만든다.    
아래 $2 \times 2$ 행렬의 전치연산을 살펴보면 대각 성분 $a$와 $d$는 동일하고 $b$와 $c$의 위치가 서로 바뀐 것을 볼 수 있다.

$$
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix}^{T} = 
\begin{bmatrix}
a & c \\
b & d \\
\end{bmatrix}
$$

# 11.2. 행렬의 곱셈
***행렬의 곱셈은 앞에 위치한 행렬의 행벡터와 뒤에 위치한 행렬의 열벡터를 각각 곱하는 방식으로 진행된다***.    
예를 들어 $2 \times 2$ 행렬의 곱셈은 [그림 4-8](#그림-4-8-행렬의-곱셈)에서의 화살표 방향으로 전개된다.

###### 그림 4-8 행렬의 곱셈
![행렬의 곱셈](/img/)

행렬 곱셈의 중요한 성질 중 하나는 ***교환법칙이 성립하지 않는다***는 점이다.  
실제로 두 행렬의 순서를 바꿔 곱셈을 하면 다른 결과가 나온다.

$$A \cdot B = 
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix} \cdot
\begin{bmatrix}
e & f \\
g & h \\
\end{bmatrix} =
\begin{bmatrix}
ae + bg & af + bh \\
ce + dg & cf + dh \\
\end{bmatrix}
$$

$$B \cdot A =
\begin{bmatrix}
e & f \\
g & h \\
\end{bmatrix} \cdot
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix} = 
\begin{bmatrix}
ae + cf & be + df \\
ag + ch & bg + dh \\
\end{bmatrix}
$$

$$\therefore A \cdot B \neq B \cdot A$$

한편, 행렬은 다음과 같이 ***결합법칙을 만족***한다.

$$
\begin{matrix}
A \cdot (B \cdot C) &=& 
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix} \cdot
(
    \begin{bmatrix}
    e & f \\
    g & h \\
    \end{bmatrix} \cdot
    \begin{bmatrix}
    i & j \\
    k & l \\
    \end{bmatrix}
) \\
&=&
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix} \cdot
\begin{bmatrix}
ei + fk & ej + fl \\
gi + hk & gj + hl \\
\end{bmatrix} \\
&=&
\begin{bmatrix}
aei + afk + bgi + bhk & aej + afl + bgj + bhl \\
cei + cfk + dgi + dhk & cej + cfl + dgj + dhl \\
\end{bmatrix}
\end{matrix}
$$

$$
\begin{matrix}
(A \cdot B) \cdot B &=&
(
    \begin{bmatrix}
    a & b \\
    c & d \\
    \end{bmatrix} \cdot
    \begin{bmatrix}
    e & f \\
    g & h \\
    \end{bmatrix}
) \cdot
\begin{bmatrix}
i & j \\
k & l \\
\end{bmatrix} \\
&=&
\begin{bmatrix}
ae + bg & af + bh \\
ce + dg & cf + dh \\
\end{bmatrix} \cdot
\begin{bmatrix}
i & j \\
k & l \\
\end{bmatrix} \\
&=&
\begin{bmatrix}
aei + bgi + afk + bhk & aej + bgj + afl + bhl \\
cei + dgi + cfk + dhk & cej + dgj + cfl + dhl \\
\end{bmatrix}
\end{matrix}
$$

$$\therefore (A \cdot B) \cdot C = A \cdot (B \cdot C)$$

행렬 곱의 특징 중 하나는, 행렬 곱을 전치한 결과는 순서를 바꾼 후 각각 전치해 곱한 결과와 동일하다는 것이다.

$$(A \cdot B)^{T} = 
\begin{bmatrix}
ae + bg & af + bh \\
ce + dg & cf + dh \\
\end{bmatrix}^{T} =
\begin{bmatrix}
ae + bg & ce + dg \\
af + bh & cf + dh \\
\end{bmatrix}
$$

$$B^T \cdot A^T = 
\begin{bmatrix}
e & g \\
f & h \\
\end{bmatrix} \cdot
\begin{bmatrix}
a & c \\
b & d \\
\end{bmatrix} =
\begin{bmatrix}
ea + gh & ec + gd \\
fa + hb & fc + hd \\
\end{bmatrix}
$$

$$\therefore (A \cdot B)^T = B^T \cdot A^T$$

$a, b, c, d$ 네 개의 원소로 구성된 $2 \times 2$ 정방행렬과 2차원 벡터 $(x, y)$를 열벡터로 설정한 두 행렬의 곱은 다음과 같이 전개된다.

$$
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix} \cdot
\begin{bmatrix}
x \\
y \\
\end{bmatrix} =
\begin{bmatrix}
ax + by \\
cx + dy \\
\end{bmatrix}
$$

행렬 곱의 결과는 2차원 벡터 공간의 선형 변환 $f(x, y) = (ax + by, cx + dy)$와 동일하다.     
따라서 $2 \times 2$ ***정방행렬*** $A$는 ***2차원 공간의 선형 변환에 대응되는 함수***를 의미하고, 이 수식은 $f(x, y) = (ax + by, cx + dy)$ ***2차원 벡터에 선형 변환을 적용해 새로운 벡터를 생성하는 작업***으로 해석할 수 있다.  
또한, ***벡터에 선형 변환을 적용하기 위한 연산 순서는 오른쪽에서 왼쪽 방향으로 이뤄짐***을 알 수 있다.

# 11.3. 정방행렬의 곱셈
$2 \times 2$ 정방행렬이 2차원 벡터 공간의 선형 변환에 대응된다면, $2 \times 2$ ***정방행렬 간의 곱은 합성함수에 대응되는 연산이다***.

벡터 $\vec{v}$에 선형 변환을 나타내는 $2 \times 2$ 정방행렬 $A, B$를 순서대로 연산한다고 가정하면, ***연산 순서는 오른쪽에서 왼쪽으로 진행***되므로 이의 수식은 다음과 같다.

$$B \cdot A \cdot \vec{v}$$

이는 다음 [그림 4-9](#그림-4-9-두-번의-선형-변환을-순서대로-적용한-예시)와 같이 세 개의 2차원 벡터 공간 $V, U, W$에 대해 두 번의 선형 변환을 거쳐 벡터 공간 $V$에 속한 벡터 $\vec{v}$가 벡터 공간 $W$의 벡터 $\vec{w}$에 대응되는 관계로 해석할 수 있다.

###### 그림 4-9 두 번의 선형 변환을 순서대로 적용한 예시
![두 번의 선형 변환을 순서대로 적용한 예시](/img/)

선형 변환을 담당하는 정방행렬 $A, B$와 벡터 $\vec{v}$의 각 요소를 다음과 같이 행렬로 나타낸다.

$$B = 
\begin{bmatrix}
e & f \\
g & h \\
\end{bmatrix}
$$

$$A = 
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix}
$$

$$\vec{v} = 
\begin{bmatrix}
x \\
y \\
\end{bmatrix}
$$

벡터 $\vec{v}$가 벡터 $\vec{w}$로 변환되는 과정은 다음과 같은 행렬 곱으로 표현할 수 있다.

$$\vec{w} = 
\begin{bmatrix}
e & f \\
g & h \\
\end{bmatrix} \cdot
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix} \cdot
\begin{bmatrix}
x \\
y \\
\end{bmatrix}
$$

***합성함수에 대응하는 행렬의 곱셈 역시 결합법칙을 만족한다***.   
따라서 행렬의 연산 순서를 바꿔도 최종 계산된 벡터 $\vec{w}$ 값은 동일하다.  
미지수로 구성된 정방행렬과 벡터를 사용해 이를 확인할 수 있다.

$$
\begin{matrix}
A \cdot \vec{v} = 
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix} \cdot
\begin{bmatrix}
x \\
y \\
\end{bmatrix} =
\begin{bmatrix}
ax + by \\
cx + dy \\
\end{bmatrix} \\
B \cdot (A \cdot \vec{v}) = 
\begin{bmatrix}
e & f \\
g & h \\
\end{bmatrix} \cdot
\begin{bmatrix}
ax + by \\
cx + by \\
\end{bmatrix} =
\begin{bmatrix}
e(ax + by) + f(cx + dy) \\
g(ax + by) + h(cx + dy) \\
\end{bmatrix}
\end{matrix}
$$

$$
\begin{matrix}
B \cdot A =
\begin{bmatrix}
e & f \\
g & h \\
\end{bmatrix} \cdot
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix} =
\begin{bmatrix}
ae + cf & be + df \\
ag + ch & bg + dh \\
\end{bmatrix} \\
(B \cdot A) \cdot \vec{v} = 
\begin{bmatrix}
x(ae + cf) + y(be + df) \\
x(ag + ch) + y(bg + dh) \\
\end{bmatrix}
\end{matrix}
$$

1번 식과 2번 식은 동일한 값이므로 다음 식이 성립한다.

$$\vec{W} = B \cdot (A \cdot \vec{v}) = (B \cdot A) \cdot \vec{v}$$

이처럼 ***결합법칙이 성립하는 행렬 곱의 성질***은 ***컴퓨터 그래픽 연산***에서 아주 유용하게 활용된다.  
예를 들어 100개의 점으로 구성된 물체가 모니터에 표현되기까지 5번의 선형 변환이 발생한다고 가정해보자.   
물체의 점을 각각 $\vec{v_1}...\vec{v_{100}}$으로 표기하고 선형 변환을 수행하는 행렬을 각각 $A, B, C, D, E$라고 하면 컴퓨터가 수행해야 할 계산은 다음과 같다.

$$
\begin{matrix}
E \cdot D \cdot C \cdot B \cdot A \cdot \vec{v_1} \\
... \\
E \cdot D \cdot C \cdot B \cdot A \cdot \vec{v_{100}} \\
\end{matrix}
$$

각 점마다 5번의 행렬 곱이 수행되므로 100개 점에 대한 행렬 곱의 총 횟수는 500이 될 것이다.

$$5 \cdot 100 = 500$$

이때 결합법칙이 성립하는 행렬 연산의 특징을 사용하면 계산량을 줄이되 동일한 결과를 얻을 수 있다.    
다음과 같이 행렬 곱을 4번 수행해서 합성함수에 해당하는 행렬 $F$를 미리 만들어둘 수 있다.

$$F = E \cdot D \cdot C \cdot B \cdot A$$

이제 각 점에 대해 미리 계산된 행렬 $F$만 곱하면 동일한 결과가 나온다.

$$
\begin{matrix}
F \cdot \vec{v_1} \\
... \\
F \cdot \vec{v_{100}} \\
\end{matrix}
$$

이 경우 100개 점에 대한 행렬 곱의 총 횟수는 최초 합성 변환을 만들기 위한 4번의 행렬 곱과 벡터마다 1번의 행렬 곱이 수행되므로 104가 된다.

$$4 + 1 \cdot 100 = 104$$

이의 결과는 앞서 구한 500번의 행렬 곱 연산과 동일하다.  
가상 공간의 한 캐릭터를 표현하는 데 보통 10만 개의 점이 사용되므로, 컴퓨터 그래픽에서 행렬은 가상 세계를 구축하는 데 필요한 계산량을 크게 줄여주는 중요한 역할을 수행한다는 사실을 알 수 있다.

> 참고: ***열 기준 행렬과 행 기준 행렬***     
행렬과 벡터의 곱셈을 수행하는 방식으로, 열 기준 행렬(Column major matrix)과 행 기준 행렬(Row major matrix) 두 가지가 있다.  
수학에서 행렬을 다룰 때는, 벡터를 열벡터로 나타내는 열 기준 행렬 방식을 주로 사용한다.
>
> $$
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix} \cdot
\begin{bmatrix}
x \\
y \\
\end{bmatrix} =
\begin{bmatrix}
ax + by \\
cx + dy \\
\end{bmatrix}$$
>
> 컴퓨터에서 실제로 행렬을 응용할 때는, 행 기준 행렬을 사용하는 경우도 있다.    
행 기준으로 선형 변환을 수행할 때는 열 기준과 다르게 행렬과 벡터의 위치를 거꾸로 뒤집어서, 다음과 같이 벡터를 앞쪽에 두어야 행렬의 곱셈이 성립된다.
>
> $$
\begin{bmatrix}
x & y
\end{bmatrix} \cdot
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix} =
\begin{bmatrix}
ax + cy & bx + dy
\end{bmatrix}$$
>
> 이와 같이 정방행렬 $A$의 요소를 열 기준 방식과 동일하게 배치한다면 행렬 곱셈의 결과는 다른 값이 나온다.   
>
> $$(ax + by, cx + dy) \neq (ax + cy, bx + dy)$$
>
> 원하는 결과는 $(ax + by, cx + dy)$이므로 열 기준 행렬 방식을 사용한다면 정방행렬 $A$의 요소는 다음과 같이 배치해야 할 것이다.
>
> $$
\begin{bmatrix}
x & y
\end{bmatrix} \cdot
\begin{bmatrix}
a & c \\
b & d \\
\end{bmatrix} =
\begin{bmatrix}
ax + by & cx + dy
\end{bmatrix}$$
>
> 이는 행 기준 방식의 정방행렬 $A$를 전치시킨 결과와 동일하다.
>
> $$
\begin{bmatrix}
a & c \\
b & d \\
\end{bmatrix} = 
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix}^T$$
>
> 행 기준 방식을 사용하는 대표적인 사례로는 게임 그래픽스 라이브러리인 다이렉트X(DirectX)가 있으며, 열 기준 방식을 사용하는 게임 그래픽스 라이브러리로는 오픈GL(OpenGL)이 있다.     
유니티(Unity) 엔진은 C# 스크립트에서 열 기준 방식을 사용하고, 언리얼(Unreal) 엔진의 C++ 코드는 행 기준 방식을 사용한다.     
이렇게 그래픽 라이브러리와 애플리케이션마다 행렬을 사용하는 방법은 다르다.      
두 방식 모두 전치연산을 통해 서로 변환할 수 있으므로 방식만 명확하게 이해하고 있다면 응용하는 데 큰 문제는 없다.    
열벡터와 행벡터는 서로 전치 관계에 있기 때문에, 선형 변환 역시 전치 관계의 차이가 있을 뿐이다.
>
> 열 기준 체계에서 설계된 수식을 행 기준에서 가져다 쓰고 싶다면 다음과 같이 전치연산을 적용해 변환하면 된다.
>
> $$(A \cdot \vec{v})^T = \vec{v}^T \cdot A^T$$
>
> $$
(
    \begin{bmatrix}
    a & b \\
    c & d \\
    \end{bmatrix} \cdot
    \begin{bmatrix}
    x \\
    y \\
    \end{bmatrix}
)^T =
\begin{bmatrix}
x \\
y \\
\end{bmatrix}^T \cdot
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix}^T =
\begin{bmatrix}
x & y
\end{bmatrix} \cdot
\begin{bmatrix}
a & c \\
b & d \\
\end{bmatrix}$$
>
> 열 기준 행렬은 행렬의 적용 순서가 오른쪽에서 왼쪽 방향으로 흐르는 역방향으로 진행된다.    
다음 행렬의 곱셈이 열 기준 방식으로 이뤄진다면, 벡터 $v$에 대해 행렬 $A$의 선형 변환이 적용된 후 행렬 $B$의 선형 변환이 적용된다.
>
> $$B \cdot A \cdot \vec{v} = \vec{W}$$
>
> 이와 같은 열 기준 방식의 변환을 행 기준 방식으로 변환하기 위해 위 식을 전치해보면, 계산은 다음과 같이 왼쪽에서 오른쪽의 순방향으로 진행된다.
>
> $$(B \cdot A \cdot \vec{v})^T = (\vec{W})^T$$
> 
> $$\vec{v}^T \cdot A^T \cdot B^T = (\vec{W})^T$$
>
> 이와 같이 열벡터 행렬을 전치한 결과는 행벡터가 된다.  
따라서 행벡터 변환 방식을 사용한다면 행렬의 적용 순서는 왼쪽에서 오른쪽의 순방향으로 진행되므로 이 점을 주의해야 한다.

# 12. 행렬의 설계
$2 \times 2$ ***정방행렬은 2차원 벡터 공간의 선형 변환에 대응한다***.
벡터 공간 $V$를 구성하는 두 표준기저벡터 $(1, 0)$과 $(0, 1)$이 [그림 4-10](#그림-4-10-선형-변환을-통해-기저벡터가-변하는-과정)과 같이 선형 변환을 통해 새로운 벡터 공간 $W$의 벡터 $(a, c)$와 $(b, d)$에 대응되어 변환된다고 생각해보자.

$$(1, 0) \mapsto (a, c)$$

$$(0, 1) \mapsto (b, d)$$

###### 그림 4-10 선형 변환을 통해 기저벡터가 변하는 과정
![선형 변환을 통해 기저벡터가 변하는 과정](/img/)

원 벡터 공간 $V$의 벡터 $\vec{v} = (x, y)$는 다음과 같은 ***표준기저벡터의 선형 결합을 통해 생성***됐다.

$$\vec{v} = (x, y) = x \cdot (1, 0) + y \cdot (0, 1)$$

같은 방법으로 벡터 $\vec{v}$가 선형 변환되는 경우에는 동일한 선형 결합식을 사용해 벡터 $\vec{w}$가 다음과 같이 계산된다.

$$\vec{w} = x(a, c) + y(b, d) = (ax + by, cx + dy)$$

이는 $a, b, c, d$로 만들어진 정방행렬에 벡터 $(x, y)$를 곱한 결과와 동일하다.

$$
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix} \cdot
\begin{bmatrix}
x \\
y \\
\end{bmatrix} =
\begin{bmatrix}
ax + by \\
cx + dy \\
\end{bmatrix}
$$

위의 정방행렬과 표준기저벡터가 변화된 두 벡터 $(a, c)$와 $(b, d)$와의 관계를 분석해보면 이들은 [그림 4-11](#그림-4-11-2개의-표준기저벡터로-구성된-행렬)과 같이 ***정방행렬을 구성하는 열벡터***임을 알 수 있다.

###### 그림 4-11 2개의 표준기저벡터로 구성된 행렬
![2개의 표준기저벡터로 구성된 행렬](/img/)

벡터 공간 $V$의 $(0, 0)$에서 $(1, 1)$까지로 둘러싸인 ***사각형의 부분 공간***을 관찰해 벡터 공간 $V$에서 벡터 공간 $W$로의 선형 변환을 통해 진행되는 부분 공간의 변화는 [그림 4-12](#그림-4-12-부분-공간을-사용한-선형-변환의-관찰)와 같다.

###### 그림 4-12 부분 공간을 사용한 선형 변환의 관찰
![부분 공간을 사용한 선형 변환의 관찰](/img/)

***부분 공간의 변화***를 관찰함으로써 선형 변환을 눈으로 확인할 수 있으며, 이를 활용해 원하는 형태로 공간이 변환되도록 행렬을 설계할 수 있다.

# 12.1. 크기 변환행렬
***크기 변환행렬(Scale transformation matrix)*** 은 물체의 크기를 변경하는 행렬이다.   
크기 변환은 ***각 표준기저벡터를 동일한 방향으로 지정한 크기만큼 늘리는 변환***을 의미한다.   
이를 위해 $(1, 0)$의 좌표를 갖는 $e_1$과 $(0, 1)$의 좌표를 갖는 $e_2$의 두 표준기저벡터를 다음과 같이 변환해보자.
- 표준기저벡터 $e_1$을 $a$배 늘리거나 줄인 벡터: $a \cdot (1, 0) = (a, 0)$
- 표준기저벡터 $e_2$를 $b$배 늘리거나 줄인 벡터: $b \cdot (0, 1) = (0, b)$

$e_1$을 $a$배만큼 늘리고 $e_2$를 $b$배만큼 줄인 선형 변환으로 인한 벡터 공간의 변화는 [그림 4-13](#그림-4-13-크기-변환의-시각화)과 같이 표현할 수 있다.

###### 그림 4-13 크기 변환의 시각화
![크기 변환의 시각화](/img/)

변환된 두 표준기저벡터 $(a, 0)$과 $(0, b)$를 열벡터로 설정해 생성한 크기 변환행렬은 다음과 같다.

$$S = 
\begin{bmatrix}
a & 0 \\
0 & b \\
\end{bmatrix}
$$

# 12.2. 회전 변환행렬
***회전 변환행렬(Rotation transformation matrix)*** 은 주어진 각 $\theta$로 벡터 공간을 회전시킨다.    
$90^\circ$ 회전은 양의 방향(+)에 해당하는 회전과 음의 방향(-) 두 가지가 있는데, 반시계 방향으로 회전하는 양의 방향 $90^\circ$ 회전은 [그림 4-14](#그림-4-14-반시계-방향으로-90도-회전-변환한-결과)와 같이 두 표준기저벡터가 서로 바뀐 형태를 가진다.

###### 그림 4-14 반시계 방향으로 90도 회전 변환한 결과
![반시계 방향으로 90도 회전 변환한 결과](/img/)

두 표준기저벡터는 변환에 의해 다음과 같이 좌표가 변경된다.
- 표준기저벡터 $e_1$을 $90^\circ$ 회전한 벡터: $(0, 1)$
- 표준기저벡터 $e_2$를 $90^\circ$ 회전한 벡터: $(-1, 0)$

따라서 $90^\circ$ 회전 변환을 수행하는 행렬은 다음과 같이 설계할 수 있다.

$$R_{90^\circ} = R_{\frac{\pi}{2}} = 
\begin{bmatrix}
0 & -1 \\
1 & 0 \\
\end{bmatrix}$$

시계 방향으로 진행하는 $-90^\circ$ 회전 변환을 설계해보면 해당 변환은 [그림 4-15](#그림-4-15-시계-방향으로-90도-회전-90도-회전-변환한-결과)와 같이 표현할 수 있다.

###### 그림 4-15 시계 방향으로 90도 회전(-90도 회전) 변환한 결과
![시계 방향으로 90도(-90도 회전) 변환한 결과](/img/)

두 표준기저벡터는 변환에 의해 다음과 같이 좌표가 변경된다.
- 표준기저벡터 $e_1$을 $-90^\circ$ 회전한 벡터: $(0, -1)$
- 표준기저벡터 $e_2$를 $-90^\circ$ 회전한 벡터: $(1, 0)$

따라서 $-90^\circ$ 회전 변환을 수행하는 행렬은 다음과 같이 설계할 수 있다.

$$R_{-90^\circ} = R_{-\frac{\pi}{2}} = 
\begin{bmatrix}
0 & 1 \\
-1 & 0 \\
\end{bmatrix}$$

> 참고: $90^\circ$ ***회전의 구현***    
$(x, y)$의 값을 가지는 벡터 $\vec{v}$를 $90^\circ$로 변환하는 작업은 행렬을 사용하지 않아도 두 값을 바꿔치는 방법으로 간단히 구할 수 있다.  
벡터 $\vec{v}$를 시계 반대 방향으로 $90^\circ$로 회전한 벡터 $\vec{v'}$는 두 값을 바꾸고 첫 번째 요소에 음수를 부여해 얻을 수 있다.
>
> $$\vec{v'} = (-y, x)$$
>
> 벡터 $\vec{v}$를 시계 방향으로 $90^\circ$로 회전한 벡터 $\vec{v'}$는 유사하게 두 값을 바꾸고 두 번째 요소에 음수를 부여하면 얻어진다.
>
> $$\vec{v'} = (y, -x)$$

두 표준기저벡터 $e_1$과 $e_2$가 각 $\theta$만큼 회전한 결과는 각각 [그림 4-16](#그림-4-16-두-표준기저벡터가-각-세타만큼-회전-변환한-결과)의 $(\cos \theta, \sin \theta)$와 $(-\sin \theta, \cos \theta)$가 된다.

###### 그림 4-16 두 표준기저벡터가 각 세타만큼 회전 변환한 결과
![두 표준기저벡터가 각 세타만큼 회전 변환한 결과](/img/)

정리하면 두 표준기저벡터가 각 $\theta$만큼 회전한 좌표는 다음과 같다.
- 표준기저벡터 $e_1$을 $\theta$만큼 회전한 벡터: $(\cos \theta, \sin \theta)$
- 표준기저벡터 $e_2$를 $\theta$만큼 회전한 벡터: $(-\sin \theta, \cos \theta)$

따라서 각 $\theta$에 대한 회전 변환행렬은 다음과 같이 설계할 수 있다.

$$R_\theta = 
\begin{bmatrix}
\cos \theta & -\sin \theta \\
\sin \theta & \cos \theta \\
\end{bmatrix}$$

# 12.3. 전단 변환행렬
표준기저벡터 $e_1$을 고정한 상태에서 표준기저벡터 $e_2$를 $x$축 방향으로 밀면 표준기저벡터 $e_1$은 고정되어 있기 때문에 변환된 결과는 [그림 4-17](#그림-4-17-e1을-고정한-상태에서-e2를-x축-방향으로-미는-변환)과 같이 대각선으로 밀리는 형태를 띤다.   
이를 ***전단 변환행렬(Shear transformation matrix)*** 이라고 한다.

###### 그림 4-17 e1을 고정한 상태에서 e2를 x축 방향으로 미는 변환
![e1을 고정한 상태에서 e2를 x축 방향으로 미는 변환](/img/)

$x$축 방향으로 1만큼 미는 전단 변환에 의해 두 표준기저벡터는 다음과 같이 좌표가 변경된다.
- 표준기저벡터 $e_1$의 변환 결과: $(1, 0)$ (변화 없음)
- 표준기저벡터 $e_2$의 변환 결과: $(1, 1)$

따라서 표준기저벡터 $e_2$를 $x$축 방향으로 1만큼 밀어내는 전단 변환행렬은 다음과 같이 설계할 수 있다.

$$S = 
\begin{bmatrix}
1 & 1 \\
0 & 1 \\
\end{bmatrix}$$

전단 변환에서 미는 크기는 1행 2열에 위치한 원소 값을 변경해 조절이 가능하다.    
만일 [그림 4-18](#그림-4-18-미는-크기에-따른-기저벡터의-변화)과 같이 $x$축 방향으로 $a$ 만큼 민다면 각 표준기저벡터 $e_1$과 $e_2$는 다음과 같이 변환된다.

###### 그림 4-18 미는 크기에 따른 기저벡터의 변화
![미는 크기에 따른 기저벡터의 변화](/img/)

$x$축 방향으로 $a$만큼 미는 전단 변환에 의해 두 표준기저벡터는 다음과 같이 좌표가 변경된다.
- 표준기저벡터 $e_1$의 변환 결과: $(1, 0)$ (변화 없음)
- 표준기저벡터 $e_2$의 변환 결과: $(a, 1)$

그러므로 $x$축 방향으로 $a$만큼 미는 전단 변환행렬은 다음과 같다.

$$S = 
\begin{bmatrix}
1 & a \\
0 & 1 \\
\end{bmatrix}$$

# 12.4. 삼각함수의 덧셈 정리
삼각함수를 응용할 때 유용하게 사용되는 공식에는 삼각함수의 덧셈 정리가 있다.    
$\cos$ 함수와 $\sin$ 함수의 덧셈 정리는 다음과 같다.

$$\cos(\alpha + \beta) = \cos \alpha \cos \beta - \sin \alpha \sin \beta$$

$$\sin(\alpha + \beta) = \sin \alpha \cos \beta + \cos \alpha \sin \beta$$

회전행렬의 원리를 파악하면 행렬 곱을 사용해 덧셈 정리를 유도할 수 있다.     
[그림 4-19](#그림-4-19-두-회전을-합성한-변환과-각각-회전한-변환의-비교)와 같이 회전 변환에 사용하는 두 각 $\alpha$와 $\beta$가 있을 때, 이 둘을 합한 $\alpha + \beta$ 만큼 회전한 변환은 두 각에 대한 회전 변환을 순서대로 적용한 결과와 동일하다.

###### 그림 4-19 두 회전을 합성한 변환과 각각 회전한 변환의 비교
![두 회전을 합성한 변환과 각각 회전한 변환의 비교](/img/)

각 $\alpha$에 대한 회전 변환행렬을 $R_\alpha$로, 각 $\beta$에 대한 회전 변환행렬을 $R_\beta$로 표기한다면 각 회전 변환과 이 둘을 합한 각 $\alpha + \beta$의 회전 변환도 다음과 같은 행렬로 나타낼 수 있다.

$$R_\alpha = 
\begin{bmatrix}
\cos \alpha & -\sin \alpha \\
\sin \alpha & \cos \alpha \\
\end{bmatrix}$$

$$R_\beta = 
\begin{bmatrix}
\cos \beta & -\sin \beta \\
\sin \beta & \cos \beta \\
\end{bmatrix}$$

$$R_{(\alpha + \beta)} = 
\begin{bmatrix}
\cos(\alpha + \beta) & -\sin(\alpha + \beta) \\
\sin(\alpha + \beta) & \cos(\alpha + \beta) \\
\end{bmatrix}$$

각 $\alpha + \beta$의 회전 변환은 각 $\alpha$에 대한 회전 변환을 수행한 후에 각 $\beta$에 대한 회전 변환을 이어서 변환한 결과와 동일하다.   
이를 행렬 곱으로 나타내면 다음과 같다.

$$
\begin{matrix}
R_\beta \cdot R_\alpha &=& 
\begin{bmatrix}
\cos \beta & -\sin \beta \\
\sin \beta & \cos \beta \\
\end{bmatrix}
\begin{bmatrix}
\cos \alpha & -\sin \alpha \\
\sin \alpha & \cos \alpha \\
\end{bmatrix} \\
&=&
\begin{bmatrix}
\cos \alpha \cos \beta - \sin \alpha \sin \beta & -(\cos \alpha \sin \beta + \sin \alpha \cos \beta) \\
\cos \alpha \sin \beta + \sin \alpha \cos \beta & \cos \alpha \cos \beta - \sin \alpha \sin \beta \\
\end{bmatrix} \\
&=&
\begin{bmatrix}
\cos(\alpha + \beta) & -\sin(\alpha + \beta) \\
\sin(\alpha + \beta) & \cos(\alpha + \beta) \\
\end{bmatrix}
\end{matrix}
$$

> 참고: ***삼각함수의 배각 공식***  
삼각함수의 덧셈 정리를 응용한 삼각함수의 배각 공식은 각 $\beta$ 대신 $\alpha$를 대입해 얻을 수 있다.    
>
> $$
\begin{matrix}
\cos 2 \alpha &=& \cos(\alpha + \alpha) \\
&=& \cos^2 \alpha - \sin^2 \alpha \\
&=& 1 - 2 \sin^2 \alpha \\
\end{matrix}$$
>
> $$
\begin{matrix}
\sin 2 \alpha &=& \sin(\alpha + \alpha) \\
&=& 2 \sin \alpha \cos \alpha
\end{matrix}$$

# 13. 역행렬
***선형 변환을 수행하는 행렬은 본질적으로 함수의 성질을 지니기 때문에 항등함수와 역함수에 대응하는 행렬이 존재한다***.    
이를 각각 ***항등행렬(Identity matrix)*** 과 ***역행렬(Inverse matrix)*** 이라고 부른다.

***항등행렬은 원 공간의 변화없이 동일한 공간으로 유지하는 변환***을 의미한다.     
변환된 공간의 표준기저벡터는 원 공간의 표준기저벡터와 동일하다.     
따라서 항등행렬은 표준기저벡터 $(1, 0)$과 $(0, 1)$을 순서대로 넣어 만들 수 있다.    
항등행렬은 $I$로 표기한다.

$$I = 
\begin{bmatrix}
1 & 0 \\
0 & 1 \\
\end{bmatrix}$$

역함수의 정의와 동일하게 ***행렬 곱의 결과가 항등행렬이 나오는 특별한 행렬을 역행렬***이라고 부른다.  
역행렬은 역함수와 동일하게 위 첨자 $^{-1}$을 사용해 표시하며 임의의 행렬을 $A$라고 했을 때 다음의 수식이 성립한다.

$$A \cdot A^{-1} = A^{-1} \cdot A = I$$

역행렬을 시각적으로 나타내본다면 [그림 4-20](#그림-4-20-역행렬의-시각적-의미)과 같이 벡터 공간 $V$가 선형 변환된 벡터 공간 $W$에서 원 벡터 공간 $V$로 되돌리는 선형 변환이라고 할 수 있다.

###### 그림 4-20 역행렬의 시각적 의미
![역행렬의 시각적 의미](/img/)

# 13.1. 역행렬의 존재를 판별하는 행렬식
어떤 함수가 역함수를 갖기 위한 조건은 전단사함수여야한다.     
행렬도 함수이므로 ***두 공간의 변환이 전단사로 대응될 때만 역행렬이 존재***한다.  
***어떤 행렬에 대해 역행렬이 존재하는지 파악할 수 있는 특별한 수식***이 있는데 이를 ***행렬식(Determinant)*** 이라 한다.

행렬식은 $\det()$의 기호로 표시하며, 일반적인 $2 \times 2$ 정방행렬 $A$의 행렬식은 다음과 같이 계산한다.

$$A = 
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix}$$

$$\det(A) = ad - bc$$

행렬식 $\det(A)$의 값이 0인 선형 변환은 전단사 대응이 성립하지 않아 역행렬이 존재하지 않는다.   
예를 들어 행렬이 아래와 같을 경우 

$$A = 
\begin{bmatrix} 
2 & 1 \\ 
1 & 0.5 \\ 
\end{bmatrix}$$

이의 행렬식 $\det(A)$의 값은 다음과 같이 0으로 계산된다.

$$\det(A) = ad - bc = 2 \cdot 0.5 - 1 \cdot 1 = 0$$

이러한 경우 행렬 $A$는 역행렬이 존재하지 않는데, 시각적으로 행렬 $A$의 결과가 어떻게 변환되어 역행렬이 존재하지 않게 되는지 [그림 4-21](#그림-4-21-행렬식이-0인-행렬을-사용한-변환-결과)을 통해 확인할 수 있다.  
행렬 $A$를 분석하면 원 벡터 공간 $V$의 두 표준기저벡터는 각각 $(2, 1)$과 $(1, 0.5)$의 열벡터로 변환됨을 알 수 있다.     
변환된 두 표준기저벡터를 추적하면 ***두 기저벡터의 기울기가 같음***을 알 수 있다.     
이를 시각적으로 분석하면 2차원의 평면 영역이 1차원의 직선 영역으로 압축됐다고 볼 수 있다.

###### 그림 4-21 행렬식이 0인 행렬을 사용한 변환 결과
![행렬식이 0인 행렬을 사용한 변환 결과](/img/)

이렇게 ***차원이 줄어들어 원 공간의 정보가 소멸***되면, 거꾸로 벡터 공간 $W$에서 벡터 공간 $V$로 변환되는 것은 불가능해진다.  
따라서 역행렬이 존재할 수 없다.  

벡터 공간 $V$에서 임의의 행렬

$$A = 
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix}$$

를 사용해 표준기저벡터가 $(a, c)$와 $(b, d)$로 변환된 새로운 벡터 공간 $W$를 생각해보면, 영역을 계산하는 함수를 $Area()$라고 지정했을 때 [그림 4-22](#그림-4-22-선형-변환된-사각형-영역의-넓이)의 왼쪽 그림에서 회색으로 칠해진 두 표준기저벡터가 형성하는 ***정사각형(Square)*** 영역의 넓이는 1이다.   
해당 영역이 행렬에 의해 ***평행사변형(Parallelogram)*** 으로 변환되면 넓이도 변화될 것이다.

###### 그림 4-22 선형 변환된 사각형 영역의 넓이
![선형 변환된 사각형 영역의 넓이](/img/)

변환된 두 벡터가 이루는 평행사변형의 넓이는 [그림 4-23](#그림-4-23-평행사변형-영역의-넓이)과 같다.

###### 그림 4-23 평행사변형 영역의 넓이
![평행사변형 영역의 넓이](/img/)

[그림 4-23](#그림-4-23-평행사변형-영역의-넓이)의 평행사변형의 넓이 $Area(P)$는 전체 사각형의 넓이에서 평행사변형을 제외한 삼각형과 사각형 영역을 빼서 구할 수 있는데, 이 값은 앞에서 구한 행렬식 $\det(A)$와 동일하다.

$$
\begin{matrix}
Area(P) &=& (a + b) \cdot (c + d) - 2 \cdot (\frac{1}{2}ac) - 2 \cdot (\frac{1}{2}bd) - bc - bc \\
&=& (a + b) \cdot (c + d) - ac - bd - 2bc \\
&=& ad - bc
\end{matrix}$$

따라서 이렇게 계산된 넓이, 즉 ***행렬식 값이 0인 경우에는 해당 평행사변형의 넓이는 소멸***되면서 평면의 모든 요소는 1차원 선 위에 놓이게 되어 이후에는 더 이상 2차원으로 돌아갈 수 없게 된다.

> 참고: ***행렬식 계산 결과가 음수가 나오는 경우***     
[그림 4-24](#그림-4-24-행렬식-값이-음수가-나오는-경우)와 같이 표준기저벡터 $e_1$이 변환된 결과 $(a, c)$가 표준기저벡터 $e_2$가 변환된 결과 $(b, d)$보다 상단에 위치한 상황을 생각해보면, 두 벡터를 구성하는 $a, b, c, d$ 값은 모두 양수인데 $b$는 $a$보다 크고 $c$는 $d$보다 크다.     
따라서 행렬식 $ad - bc$의 계산 결과는 음수가 나온다.
>
> ###### 그림 4-24 행렬식 값이 음수가 나오는 경우
> ![행렬식 값이 음수가 나오는 경우](/img/)
>
> 그림으로 두 표준기저벡터의 변환 과정을 추적해보면 보라색은 위로, 청록색은 아래로 가면서 평면이 뒤집혔다고 생각할 수 있다.     
따라서 행렬식 값은 단순히 면적의 변화를 측정하는 것뿐만 아니라 부호를 통해 평면이 원 공간과 동일한 면으로 설정되어 있는지, 뒤집힌 반대면으로 설정되어 있는지를 파악할 수 있다.

# 13.2. 크기 변환행렬의 역행렬
크기 변환행렬의 역행렬은 [그림 4-25](#그림-4-25-크기-변환의-역변환)와 같이 변화된 크기만큼 거꾸로 크기를 변화시키는 방법으로 구할 수 있다.     
크기 변환행렬 $S$는 다음과 같다.

$$S = 
\begin{bmatrix}
a & 0 \\
0 & b \\
\end{bmatrix}$$

크기 변환에 사용한 ***두 원소의 역수***를 사용해 크기 변환을 설계하면 변환된 두 기저벡터는 다시 표준기저벡터로 돌아온다.

###### 그림 4-25 크기 변환의 역변환
![크기 변환의 역변환](/img/)

원 공간에서 $x$축을 $a$배, $y$축을 $b$배만큼 크기를 변화시킨 크기 변환행렬 $S$의 역행렬 $S^{-1}$는 다음과 같이 $a$와 $b$의 역수를 대입해 구할 수 있다.

$$S^{-1} = 
\begin{bmatrix}
\frac{1}{a} & 0 \\
0 & \frac{1}{b} \\
\end{bmatrix}$$

# 13.3. 전단 변환행렬의 역행렬
전단 변환행렬 $S$는 다음과 같다.

$$S = 
\begin{bmatrix}
1 & a \\
0 & 1 \\
\end{bmatrix}$$

[그림 4-26](#그림-4-26-전단-변환의-역변환)과 같이 표준기저벡터 $e_1$을 고정한 상태에서 민 방향의 반대 방향으로 밀면 밀린 공간은 원대래로 돌아온다.

###### 그림 4-26 전단 변환의 역변환
![전단 변환의 역변환](/img/)

원 공간에서 $x$축으로 $a$만큼 민 전단 변환행렬 $S$의 역행렬 $S^{-1}$는 $a$의 반대수를 대입해 다음과 같이 구할 수 있다.

$$S^{-1} = 
\begin{bmatrix}
1 & -a \\
0 & 1 \\
\end{bmatrix}$$

# 13.4. 회전 변환행렬의 역행렬
회전 변환행렬 $R$은 다음과 같다.

$$R = 
\begin{bmatrix}
\cos \theta & -\sin \theta \\
\sin \theta & \cos \theta \\
\end{bmatrix}$$

회전각 $\theta$에 대한 회전 변환행렬의 역행렬은 [그림 4-27](#그림-4-27-회전-변환의-역변환)과 같이 반대방향의 회전각 $-\theta$에 대한 회전 변환을 의미한다.

$$R^{-1}_\theta = R_{(-\theta)}$$

###### 그림 4-27 회전 변환의 역변환
![회전 변환의 역변환](/img/)

$\sin$ 함수와 $\cos$ 함수는 다음과 같은 성질이 있다.

$$\cos(-\theta) = \cos(\theta)$$

$$\sin(-\theta) = -\sin(\theta)$$

이를 활용하면 회전행렬의 역행렬은 다음과 같이 정리할 수 있다.

$$R^{-1}_\theta = R_{(-\theta)} = 
\begin{bmatrix}
\cos \theta & \sin \theta \\
-\sin \theta & \cos \theta \\
\end{bmatrix}$$

역행렬에서 부호가 변하지 않는 $\cos$ 함수는 ***대각선 영역에만 위치***하므로 회전행렬과 이것의 역행렬은 서로 ***전치 관계***에 있다.

$$R_\theta = 
\begin{bmatrix}
\cos \theta & -\sin \theta \\
\sin \theta & \cos \theta \\
\end{bmatrix}$$

$$R^{-1}_\theta = 
\begin{bmatrix}
\cos \theta & \sin \theta \\
-\sin \theta & \cos \theta \\
\end{bmatrix}$$

따라서 ***회전행렬의 역행렬은 별도로 삼각함수를 사용하지 않아도 기존 행렬에 전치연산을 적용하는 방법으로 쉽게 구할 수 있다***.

$$R^{-1}_\theta = R^T_\theta$$

# 13.5. 행렬 곱의 역행렬
합성함수의 역함수에 대해 다음의 수식이 성립된다.

$$(g \circ f)^{-1} = f^{-1} \circ g^{-1}$$

합성함수에 해당하는 두 행렬 곱의 역행렬도 동일하게 다음의 수식이 성립한다.

$$(A \cdot B)^{-1} = B^{-1} \cdot A^{-1}$$

역행렬이 존재하는 두 행렬 $A$와 $B$를 곱한 행렬을 $C$라고 가정해보자.

$$A \cdot B = C$$

행렬 $C$의 역행렬이 존재한다면 다음과 같은 식이 성립한다.

$$C \cdot C^{-1} = I$$

이 식에서 $C$에 행렬 $A$와 $B$를 대입해 풀어 쓰면 다음과 같다.

$$(A \cdot B) \cdot (A \cdot B)^{-1} = I$$

이 식의 양변에 $A$의 역행렬 $A^{-1}$을 곱하면 다음과 같이 전개된다.

$$A^{-1} \cdot (A \cdot B) \cdot (A \cdot B)^{-1} = A^{-1}$$

행렬의 곱은 결합법칙이 성립하므로 이 식은 다음과 같이 전개할 수 있다.

$$(A^{-1} \cdot A) \cdot B \cdot (A \cdot B)^{-1} = A^{-1}$$

$A^{-1} \cdot A$은 항등행렬이므로 이 식은 다음과 같이 간략화된다.

$$B \cdot (A \cdot B)^{-1} = A^{-1}$$

이번에는 양 변에 $B$의 역행렬 $B^{-1}$을 곱한다.

$$B^{-1} \cdot B \cdot (A \cdot B)^{-1} = B^{-1} \cdot A^{-1}$$

$B^{-1} \cdot B$ 역시 항등행렬이므로 이를 소거하면 $(A \cdot B)^{-1} = B^{-1} \cdot A^{-1}$가 증명됨을 확인할 수 있다.

$$(A \cdot B)^{-1} = B^{-1} \cdot A^{-1}$$

# 14. 이동 변환을 위한 아핀 공간
$2 \times 2$ ***정방 행렬의 곱셈으로는 2차원 평면에서의 이동을 구현할 수 없다***.     
임의의 벡터 $(x, y)$를 지정한 크기 $(a, b)$만큼 이동시키는 기능은 다음과 같이 행렬의 덧셈으로 구할 수 있다.

$$
\begin{bmatrix}
x \\
y \\
\end{bmatrix} + 
\begin{bmatrix}
a \\
b \\
\end{bmatrix} = 
\begin{bmatrix}
x + a \\
y + b \\
\end{bmatrix}$$

하지만 다음의 행렬 곱을 만족하는 정방행렬 $A$는 존재하지 않는다.

$$A \cdot
\begin{bmatrix}
x \\
y \\
\end{bmatrix} =
\begin{bmatrix}
x + a \\
y + b \\
\end{bmatrix}$$

그 이유를 시각적으로 살펴보면, [그림 5-1](#그림-5-1-선형-변환의-형태를-벗어나는-이동-변환)과 같이 ***표준기저벡터의 원점을 이동시키는 변환이 행렬이 되기 위해서는 선형성을 만족***해야 하는데, ***선형성이 되기 위해서는 기저벡터가 원점에서부터 출발해야 한다***는 조건을 만족해야 하기 때문이다.

###### 그림 5-1 선형 변환의 형태를 벗어나는 이동 변환
![선형 변환의 형태를 벗어나는 이동 변환](/img/)

공간의 차원을 하나 더 늘린다면 이를 구현하는 것이 가능하다.     
[그림 5-2](#그림-5-2-차원을-하나-높여-선형-변환으로-이동을-구현하기)와 같이 물체를 표현하는데 두 개의 차원을 사용하고, ***차원 하나를 더 추가해 선형 변환을 위한 원점과의 연결고리로 활용***한다면 선형 변환의 형태로 이동을 구현할 수 있다.

###### 그림 5-2 차원을 하나 높여 선형 변환으로 이동을 구현하기
![차원을 하나 높여 선형 변환으로 이동을 구현하기](/img/)

선형 변환의 한 종류인 전단 변환은 [그림 5-3](#그림-5-3-전단-변환으로-발생하는-공간의-변화)처럼 표준기저벡터 $e_1$을 고정시킨 상태에서 옆으로 밀어 공간을 기울이는 특징을 지닌다.  
[그림 5-3](#그림-5-3-전단-변환으로-발생하는-공간의-변화)은 2차원에서 전단 변환의 변화를 나타낸 그림이다.  
(a)는 $x$축으로 1만큼 밀었을 때의 공간의 변화를 나타내고 (b)는 $x$축으로 2만큼 밀었을 때의 변화를 나타낸다.

###### 그림 5-3 전단 변환으로 발생하는 공간의 변화
![전단 변환으로 발생하는 공간의 변화](/img/)

[그림 5-4](#그림-5-4-전단-변환에-따라-변하는-x값의-영역)에서 전단 변환을 적용하기 전의 공간 (a)에서 $y$값이 1인 영역(보라색으로 표시됨)을 살펴보면 $x$ 범위는 $|0, 1|$임을 볼 수 있다.    
여기서 $x$축으로 1만큼 민 전단 변환 (b)의 $x$범위는 $|0, 1|$에서 1만큼 늘어난 $|1, 2|$가 되고, 2만큼 민 전단 변환 (c)의 $x$범위는 $|0, 1|$에서 2만큼 늘어난 $|2, 3|$이 됨을 확인할 수 있다.     
이는 전단 변환을 사용해 공간을 오른쪽으로 밀었을 때 $y$값이 1인 영역의 $x$범위는 밀어낸만큼 이동한다는 의미다.

###### 그림 5-4 전단 변환에 따라 변하는 x값의 영역
![전단 변환에 따라 변하는 x값의 영역](/img/)

이러한 전단 변환의 성질을 활용한다면, 선형 변환의 체계에서 특정 조건하에 이동 기능의 구현이 가능하다.   
다음과 같이 벡터의 $y$값에 1을 고정한 상태에서 전단 변환을 적용시키면 다음과 같은 결과가 나온다.

$$
\begin{bmatrix}
1 & a \\
0 & 1 \\
\end{bmatrix} \cdot
\begin{bmatrix}
x \\
1 \\
\end{bmatrix} = 
\begin{bmatrix}
x + a \\
1 \\
\end{bmatrix}$$

위 수식으로 $y = 1$이라는 조건하에 $a$만큼 미는 전단 변환의 결과는 1차원의 이동 변환 $x + a$로 활용할 수 있다.  
이의 원리를 2차원 평면 공간에도 적용해보면, 2차원 공간의 무대를 한 차원 늘려 3차원 공간으로 확장한 후, 마지막 차원 $z$의 값을 1로 조건을 고정한 전단 변환을 설계할 수 있다.

$$
\begin{bmatrix}
1 & 0 & a \\
0 & 1 & b \\
0 & 0 & 1 \\
\end{bmatrix} \cdot
\begin{bmatrix}
x \\
y \\
1 \\
\end{bmatrix} =
\begin{bmatrix}
x + a \\
y + b \\
1 \\
\end{bmatrix}$$

이는 $z = 1$의 조건에서 임의의 벡터 $(x, y)$를 지정한 크기 $(a, b)$만큼 이동시키는 2차원의 이동 변환을 만들어낸다.      
이를 시각적으로 표현하면 [그림 5-5](#그림-5-5-3차원-전단-변환을-사용해-2차원-이동-변환을-구현하기)와 같다.

###### 그림 5-5 3차원 전단 변환을 사용해 2차원 이동 변환을 구현하기
![3차원 전단 변환을 사용해 2차원 이동 변환을 구현하기](/img/)

마지막 차원의 값이 1이라는 특정 조건을 가지는 전단 변환을 활용하면 게임 콘텐츠 제작에 필수적인 이동 기능을 행렬로 구현할 수 있다.   
이를 ***이동 변환행렬(Translate transformation matrix)*** 이라고 하며 다음과 같이 설계할 수 있다.

$$T = 
\begin{bmatrix}
1 & 0 & a \\
0 & 1 & b \\
0 & 0 & 1 \\
\end{bmatrix}$$

이동 변환행렬에서 주의할 점은 ***이동에 사용되는 벡터는 언제나 마지막 차원 값이 1이어야 한다***는 것이다.     
만일 2차원 상의 벡터 $(x, y)$를 이동 변환을 사용해 이동시키고자 하는 경우에는 값을 $(x, y, 1)$로 지정해야 한다.     
이와 같이 이동이 가능한 벡터는 모두 마지막 차원 값이 1이 된다는 공통점을 가지며, 이들을 모두 모으면 [그림 5-5](#그림-5-5-3차원-전단-변환을-사용해-2차원-이동-변환을-구현하기)에서의 보라색으로 채워진 영역을 형성하게 된다.     
이렇게 벡터 공간에서 이동을 위해 마지막 차원 값을 1로 한정한 부분 공간을 ***아핀 공간(Affine space)*** 이라고 부른다.

크기 변환행렬과 회전 변환행렬은 $2 \times 2$ 정방행렬이고, 여기서 다루는 이동 변환행렬은 $3 \times 3$ 정방행렬이다.     
행렬 곱의 장점을 살리려면 $S, R, T$ 세 행렬은 크기가 같아야 한다.   
따라서 이동 변환에 맞춰서 3차원으로 늘린 크기 변환행렬 $S$와 회전 변환행렬 $R$은 각각 다음과 같다.

$$S = 
\begin{bmatrix}
a & 0 & 0 \\
0 & b & 0 \\
0 & 0 & 1 \\
\end{bmatrix}$$

$$R = 
\begin{bmatrix}
\cos \theta & -\sin \theta & 0 \\
\sin \theta & \cos \theta & 0 \\
0 & 0 & 1 \\
\end{bmatrix}$$

이렇게 ***한 차원을 높여 설계한 선형 변환***을 ***아핀 변환(Affine transformation)*** 이라고 하며, 위에 나열한 크기 변환(S), 회전 변환(R), 이동 변환(T)은 가상 공간의 변환을 다루는 데 있어 핵심적으로 사용되는 대표적인 아핀 변환이다.     
임의의 벡터 $(x, y, 1)$을 아핀 변환행렬에 곱한 결과는 다음과 같으며, 이들의 결과 역시 마지막 차원 값이 1이 되어 해당 연산은 ***아핀 공간에 닫혀 있음***을 확인할 수 있다.

$$
\begin{bmatrix}
a & 0 & 0 \\
0 & b & 0 \\
0 & 0 & 1 \\
\end{bmatrix}
\begin{bmatrix}
x \\
y \\
1 \\
\end{bmatrix} =
\begin{bmatrix}
ax \\
by \\
1 \\
\end{bmatrix}$$

$$
\begin{bmatrix}
\cos \theta & -\sin \theta & 0 \\
\sin \theta & \cos \theta & 0 \\
0 & 0 & 1 \\
\end{bmatrix}
\begin{bmatrix}
x \\
y \\
1 \\
\end{bmatrix} = 
\begin{bmatrix}
\cos \theta x - \sin \theta y \\
\sin \theta x + \cos \theta y \\
1 \\
\end{bmatrix}$$

$$
\begin{bmatrix}
1 & 0 & a \\
0 & 1 & b \\
0 & 0 & 1 \\
\end{bmatrix}
\begin{bmatrix}
x \\
y \\
1 \\
\end{bmatrix} =
\begin{bmatrix}
x + a \\
y + b \\
1 \\
\end{bmatrix}$$

# 15. 아핀 공간의 구성 요소
행렬 곱의 장점을 활용하기 위해 가상 공간의 이동 기능은 ***아핀 변환***으로 구현해야 한다면, 아핀 공간의 정의에 따라 아핀 공간에 속한 물체의 ***마지막 차원값은 언제나 1***이 되어야 한다.

이러한 아핀 공간의 성질로부터 ***가상 공간을 구성하는 체계***가 만들어진다.

# 15.1. 점
마지막 차원 값이 1인 ***아핀 공간의 원소***를 ***점(Point)*** 이라고 부른다.     
점이 지니는 성질은 ***행렬 곱을 사용해 이동이 가능하다***는 것이다.   
가상 공간이 이동하려면 물체는 점으로 구성되어야 한다.

2차원 공간에서 점은 항상 $(x, y, 1)$의 형태여야 한다.   
이의 규칙을 벗어난 벡터 $(x, y, 2)$에 $(a, b)$만큼의 이동 변환을 적용한 결과는 예상과 달리 $(x + 2a, y + 2b, 2)$가 되어 사용할 수 없다.

$$
\begin{bmatrix}
1 & 0 & a \\
0 & 1 & b \\
0 & 0 & 1 \\
\end{bmatrix}
\begin{bmatrix}
x \\
y \\
2 \\
\end{bmatrix} =
\begin{bmatrix}
x + 2a \\
y + 2b \\
2 \\
\end{bmatrix}$$

이러한 점이 가지는 규칙은 3차원 공간에도 동일하게 적용된다.     
한 차원 더 늘린 4차원 공간을 만들고 마지막 차원의 값을 1로 지정하면 3차원 공간에서의 이동 변환을 구현할 수 있다.    
이동 가능한 2차원 아핀 공간과 3차원 아핀 공간의 구성 요소인 점은 다음의 형태를 띤다.

- 2차원 공간의 점: $(x, y, 1)$    
- 3차원 공간의 점: $(x, y, z, 1)$    

# 15.2. 이동 벡터
행렬 곱의 장점을 살리기 위해 의도적으로 벡터 공간의 부분 공간인 아핀 공간을 사용한다.    
벡터의 합 연산으로 아핀 공간의 원소인 점을 이동시켰을 때, 행렬 곱의 장점을 유지하기 위해서는 그 결과는 항상 ***아핀 공간에 닫혀 있어야 한다***.   
이를 위해서 아핀 공간은 ***벡터(Vector)*** 라는 개념을 추가로 제공한다.

벡터는 ***아핀 공간 내의 이동을 지정하기 위해 사용***되는데, 벡터 공간의 원소로 정의한 벡터와 ***같은 단어지만 다른 용도로 사용***된다.    
둘을 구분하기 위해 ***아핀 공간의 벡터***를 ***이동 벡터*** 또는 ***변위 벡터(Displacement vector)*** 라고 부른다.

이동 벡터는 [그림 5-6](#그림-5-6-아핀-공간의-이동-벡터-v)과 같이 아핀 공간의 점과 점 간의 최단 거리로 정의한다.

###### 그림 5-6 아핀 공간의 이동 벡터 v
![아핀 공간의 이동 벡터 v](/img/)

아핀 공간의 점 $P_1$에 이동 벡터 $\vec{v}$를 더한 결과는 아핀 공간의 다른 점 $P_2$에 대응되는데 이를 수식으로 나타내면 다음과 같다.

$$P_1 + \vec{v} = P_2$$

이 수식에서 점 $P_1$을 우변으로 이항하면 점과 점의 뺄셈을 통해 이동 벡터를 만들어낸다.

$$\vec{v} = P_2 - P_1$$

여기서 벡터 $\vec{v}$는 뺄셈식의 뒤에 위치한 점 $P_1$에서 앞에 위치한 $P_2$로 향하는 벡터를 의미한다.   
벡터의 뺄셈은 교환법칙이 성립하지 않기 때문에 두 점의 위치를 바꾸면 점 $P_2$에서 $P_1$으로 향하는 반대 방향의 이동 벡터를 만들어내니 주의해야 한다.

$$P_1 - P_2 = -\vec{v}$$

점 $P_1$의 좌표를 $(x_1, y_1, 1)$로 $P_2$의 좌표를 $(x_2, y_2, 1)$로 지정할 때 두 점을 빼서 만든 이동 벡터의 마지막 차원 값은 $x, y$값과 무관하게 항상 0이 됨을 알 수 있다.

$$(x_1 - x_2, y_1 - y_2, 0)$$

따라서 이러한 이동 벡터들이 모이면 마지막 차원 $z$의 값이 항상 0인 영역을 형성한다.     
점들의 집합인 아핀 공간과 이동 벡터의 영역을 구분해 표현하면 [그림 5-7](#그림-5-7-점의-영역과-이동-벡터의-영역)과 같다.

###### 그림 5-7 점의 영역과 이동 벡터의 영역
![점의 영역과 이동 벡터의 영역](/img/)

# 15.3. 아핀 공간의 성질
아핀 공간의 중심을 원점 $O$라 한다면 원점 $O$의 값은 $(0, 0, 1)$이 된다.    
아핀 공간에 속한 임의의 점 $P$의 값을 $(x, y, 1)$로 지정한다면 원점 $O$에서 점 $P$로 향하는 이동벡터 $\vec{v}$는 다음과 같이 구할 수 있다.

$$\vec{v} = P - O = (x, y, 1) - (0, 0, 1) = (x, y, 0)$$

이를 시각적으로 나타내면 [그림 5-8](#그림-5-8-점과-이동-벡터의-관계)과 같다.

###### 그림 5-8 점과 이동 벡터의 관계
![점과 이동 벡터의 관계](/img/)

***점과 벡터의 덧셈 연산은 아핀 공간에 대해 닫혀 있다***.     
따라서 마지막 차원을 배제하고 점의 이동을 2차원 평면으로 표현해보면 점과 이동 벡터를 구분하는 마지막 차원값을 생략해도 [그림 5-8](#그림-5-8-점과-이동-벡터의-관계)과 같이 2차원 평면에서 아핀 공간의 점을 점으로, 이동 벡터를 화살표로 표시하면 둘을 구분할 수 있다.    
눈에 보이는 물체는 점으로, 물체를 이동시키는 데 사용하는 보이지 않는 힘은 화살표로 표현된다.

[그림 5-9](#그림-5-9-아핀-공간에서-물체와-이를-이동시키는-힘의-표현)와 같이 서로 다른 위치에 있는 점들에 이동 벡터 $(a, b, 0)$를 더하면 마치 물체에 보이지 않는 힘을 가해 동일한 크기와 방향으로 이동시킨 결과를 만들어낼 수 있다.

###### 그림 5-9 아핀 공간에서 물체와 이를 이동시키는 힘의 표현
![아핀 공간에서 물체와 이를 이동시키는 힘의 표현](/img/)

물리적인 관점에서 바라본 현실 세계의 3차원 공간을 ***유클리드 공간(Euclidean space)*** 이라고 하고, 유클리드 공간에서 작용하는 힘을 ***유클리드 벡터(Euclidean vector)*** 라고 하는데, 이에 대응되는 개념이 각각 아핀 공간과 이동 벡터다.

게임 콘텐츠를 담는 가상 세계를 구성하는 두 요소는 다음과 같다.  
- 점: 물체를 표현하고 위치를 지정하는 데 사용한다. 마지막 차원의 값은 항상 1이다.
- 이동 벡터(이하 벡터): 물체를 움직이는 데 사용한다. 마지막 차원의 값은 항상 0이다.

점과 벡터의 마지막 차원 값을 토대로 두 요소 사이에는 다음과 같은 연산 규칙이 성립된다.  
이 때 ***점과 점을 더하는 수식은 성립하지 않는데, 점과 점을 더하면 마지막 차원 값이 2가 되어 아핀 공간 영역을 벗어나기 때문이다***.
- 점 - 점 = 벡터 (예: $1 - 1 = 0$)
- 점 + 벡터 = 점 (예: $1 + 0 = 1$)
- 벡터 + 벡터 = 벡터 (예: $0 + 0 = 0$)
- 점 + 점 $\neq$ 점 (예: $1 + 1 \neq 1$)

점과 벡터의 관계는 시각과 시간 개념의 관계로 주로 설명된다.     
다음과 같이 점을 시각에, 벡터를 시간에 대응해보면 둘의 차이점을 더 쉽게 이해할 수 있다.
- 3시 - 2시 = 1시간(점 - 점 = 벡터)
- 2시 + 2시간 = 4시(점 + 벡터 = 점)
- 1시간 + 2시간 = 3시간(벡터 + 벡터 = 벡터)
- 2시 + 3시 = ?(점 + 점 $\neq$ 점)

# 16. 아핀 결합
아핀 공간을 다룰 때 ***일반적으로 점과 점을 더한 결과는 사용할 수 없다***.    
그러나 점과 점을 더할 때 그대로 더하는 것이 아닌 ***선형 결합***의 형태로 점에 ***스칼라(계수)*** 를 곱해 더한다면, 특정 조건에서 새로운 점을 생성하는 것이 가능해진다.

2차원 평면상 임의의 두 점 $P_1(x_1, y_1, 1)$과 $P_2(x_2, y_2, 1)$에 각각 스칼라 $a, b$를 곱한 선형 결합의 식은 다음과 같다.

$$a \cdot P_1 + b \cdot P_2 = (ax_1 + bx_2, ay_1 + by_2, a + b)$$

위 식에서 두 점의 결합 결과가 언제나 점이 되려면 마지막 차원 값 $a + b$가 1이 되어야 한다.  
$x$와 $y$ 값과 무관하게 $a + b = 1$의 조건을 유지한다면 점과 점을 결합해 새로운 점을 만들 수 있다.      
동일한 원리로 세 점에 대해서도 다음 수식과 같이 모든 스칼라 $a, b, c$의 합이 1이면 점의 생성이 가능하다(다음 수식의 $s.t.$는 ***such that***의 약자이며 ***수식이 성립하기 위한 조건***을 의미한다).

$$a \cdot P_1 + b \cdot P_2 + c \cdot P_3 = P_4 (s.t. a + b + c = 1)$$

이렇게 여러 개의 점을 결합해 새로운 점을 생성하는 수식을 ***아핀 결합(Affine combination)*** 이라고 한다.  
$n$개의 점을 아핀 결합하는 경우에는 각 점을 $P_i$로, 점에 사용하는 스칼라를 $c_i$로 지정한 후 모든 항을 더하는 ***시그마***($\Sigma$) 기호를 사용해 다음 식과 같이 간략히 표현할 수 있다.

$$\sum\limits_{i = 1}^n c_i \cdot P_i (s.t. \sum\limits_{i = 1}^n c_i = 1)$$

# 16.1. 두 점의 결합
아핀 결합을 통해 생성한 점들 사이에는 특정한 관계가 형성된다.   
두 점의 아핀 결합이 성립하려면 점에 곱한 두 스칼라의 합이 $a + b = 1$을 만족해야 했는데, 이를 바탕으로 식 $a \cdot P_1 + b \cdot P_2 = (ax_1 + bx_2, ay_1 + by_2, a + b)$의 $b$를 $1 - a$로 치환하면 계수 $a$에 대한 식을 얻게 되며 이는 언제나 점의 생성을 보장한다.   
두 점을 $P_1, P_2$로 지정하고 아핀 결합으로 생성된 점을 $P'$으로 지정하면 다음의 수식이 성립된다.

$$a \cdot P_1 + (1 - a) \cdot P_2 = P'$$

스칼라 $a$ 값의 변환에 따라 점들이 어떻게 생성되는지 관찰해보자.    
먼저 $a$에 1을 대입하면 점 $P_1$이 생성된다.

$$1 \cdot P_1 + 0 \cdot (x_2, y_2, 1) = P_1$$

$a$에 0을 대입하면 점 $P_2$가 생성된다.

$$0 \cdot (x_1, y_1, 1) + P_2 = P_2$$

$a = 0.5$를 대입하면 점 $P_1$과 점 $P_2$의 중점이 만들어진다.

$$\frac{1}{2} \cdot (x_1, y_1, 1) + \frac{1}{2} \cdot (x_2, y_2, 1) = \left(\frac{x_1 + x_2}{2}, \frac{y_1 + y_2}{2}, 1\right)$$

두 점 $P_1$과 $P_2$의 아핀 결합을 통해 새로운 점을 생성하면, $a$ 값이 양의 방향으로 커질수록 $P_1$의 바깥쪽 방향에 점이 생성되고, $a$ 값이 음의 방향으로 커질수록 $P_2$의 바깥쪽 방향에 점이 생성된다.      
이러한 규칙을 시각화해보면 [그림 5-10](#그림-5-10-두-점의-결합에-따른-새로운-점의-생성)과 같이 아핀 결합으로 생성되는 점을 모두 모으면 두 점 $P_1$과 $P_2$를 지나는 무한한 긴 선이 만들어진다.

###### 그림 5-10 두 점의 결합에 따른 새로운 점의 생성
![두 점의 결합에 따른 새로운 점의 생성](/img/)

아핀 결합으로 생성된 점들이 실제로 $P_1$과 $P_2$를 지나는 무한선상에 위치하는지 수식으로 확인해보자.    
식 $a \cdot P_1 + (1 - a) \cdot P_2 = P'$을 $a$로 수식을 묶은 후 다시 정리하면 다음과 같은 식이 성립한다.

$$a(P_1 - P_2) = (P' - P_2)$$

앞서 살펴본 바와 같이 점에서 점을 빼면 벡터가 되므로, 좌변의 $(P_1 - P_2)$는 $P_2$에서 $P_1$으로 향하는 벡터가 되고 우변의 $(P' - P_2)$는 $P_2$에서 새롭게 생성된 점 $P'$로 향하는 벡터가 된다.     
이 두 벡터를 각각 $\vec{u}$와 $\vec{v}$로 표시하면 위 식은 다음과 같이 간단히 정리된다.

$$a \cdot \vec{u} = \vec{v}$$

스칼라 곱셈의 성질을 떠올려보면 두 벡터 $\vec{u}$와 $\vec{v}$는 서로 평행한 벡터임을 알 수 있다.    
그렇기 때문에 두 점의 아핀 결합으로 생성되는 점은 [그림 5-11](#그림-5-11-벡터를-사용해-결합된-점이-동일-선상에-위치함을-증명한-모습)과 같이 점 $P_2$에서 $P_1$을 지나는 직선 상에 위치함을 보장받게 된다.

###### 그림 5-11 벡터를 사용해 결합된 점이 동일 선상에 위치함을 증명한 모습
![벡터를 사용해 결합된 점이 동일 선상에 위치함을 증명한 모습](/img/)

식 $a \cdot P_1 + (1 - a) \cdot P_2 = P'$에 모든 실수 $a$를 대입하면 두 점을 이은 양 끝으로 무한히 뻗은 선을 얻게 될 것이다.    
이 수식을 ***직선의 방정식***이라고 한다.

$$L(a) = a \cdot P_1 + (1 - a) \cdot P_2$$

직선의 방정식은 $a$의 범위에 따라 다양한 종류의 선이 대응된다.  
(a)를 ***직선(Line)***, (b)를 ***반직선(Ray)***, (c)를 ***선분(Line segment)*** 이라고 부른다.

###### 그림 5-12 매개변수 범위에 따른 직선의 종류
![매개변수 범위에 따른 직선의 종류](/img/)

***직선(Line)*** 은 두 점의 양쪽 방향으로 무한히 뻗어나가는 선의 형태를 의미하며 ***추상적인 선의 성질을 표현할 때 사용***한다.

***반직선(Ray)*** 은 지정한 위치에서 한쪽 방향으로만 뻗어나가는 선을 뜻한다.   
반직선도 ***추상적인 개념이지만 게임 제작에서 여러 용도로 사용***된다.    
게임 제작에서 전방에 물체가 있는지 탐지하기 위해 사용하는 기능에 ***레이캐스팅(Raycasting)*** 이 있다.     
지정한 위치에서 특정 방향으로 ***반직선(Ray)*** 을 ***던져(Casting)*** 이와 맞닿는 물체를 탐지하는 기능이다.     
컴퓨터 그래픽스에서 각광받는 ***레이트레이싱(Raytracing)*** 기술에도 ***반직선(Ray)*** 개념이 사용된다.     
레이트레이싱은 ***화면에 도달한 빛의 경로를 거꾸로 추적해(Tracing) 현실 세계와 유사하게 빛의 경로를 시뮬레이션***하여 [그림 5-13](#그림-5-13-반직선-레이트레이싱-기술로-제작한-컴퓨터-그래픽-화면)과 같은 사실적인 이미지를 만들어내는 기법이다.

###### 그림 5-13 반직선 레이트레이싱 기술로 제작한 컴퓨터 그래픽 화면
![반직선 레이트레이싱 기술로 제작한 컴퓨터 그래픽 화면](/img/)

마지막으로 ***선분(Line segment)*** 은 시작점과 끝점의 위치가 정해져 있는 선을 말한다.     
프로그래밍을 활용해 화면에 선을 그리려면 무한이라는 추상적인 개념을 배제하고 명확하게 시작점과 끝점을 정해주어 선분의 형태로 정보가 제공되어야 한다.

# 17. 벡터의 내적
벡터의 ***내적(Dot product)*** 은 같은 차원의 두 벡터가 주어졌을 때, ***벡터를 구성하는 각 성분을 곱한 후 이들을 더해 스칼라를 만들어내는 연산***이다.   
내적은 곱셈 기호와 동일한 ***가웃뎀점(·)*** 을 사용한다.   
2차원 벡터의 내적을 계산하는 수식은 다음과 같다.

$$\vec{u} = (a, b)$$

$$\vec{v} = (c, d)$$

$$\vec{u} \cdot \vec{v} = a \cdot c + b \cdot d$$

# 17.1. 내적의 성질
***내적은 스칼라의 곱셈과 덧셈으로 구성되어 있으므로 교환법칙이 성립한다***.

$$\vec{u} \cdot \vec{v} = a \cdot c + b \cdot d$$

$$\vec{v} \cdot \vec{u} = c \cdot a + d \cdot b$$

$$\therefore \vec{u} \cdot \vec{v} = \vec{v} \cdot \vec{u}$$

하지만 ***결과가 벡터가 아닌 스칼라로 나오는 성질***로 인해 ***결합법칙은 성립하지 않는다***.

$$\vec{u} \cdot (\vec{v} \cdot \vec{w}) \neq (\vec{u} \cdot \vec{v}) \cdot \vec{w}$$

***내적은 덧셈에 대한 분배법칙이 성립된다***.

$$\vec{w} \cdot (\vec{u} + \vec{v}) = (e, f) \cdot (a + c, b + d) = ae + ce + bf + df$$

$$\vec{u} \cdot \vec{w} + \vec{v} \cdot \vec{w} = (a, b) \cdot (e, f) + (c, d) \cdot (e, f) = ae + bf + ce + df$$

$$\therefore \vec{w} \cdot (\vec{u} + \vec{v}) = \vec{u} \cdot \vec{w} + \vec{v} \cdot \vec{w}$$

같은 벡터를 내적하면 ***벡터의 크기를 제곱한 결과***가 나온다.    
이와 같은 내적의 성질은 모든 차원의 벡터에 동일하게 적용된다.

$$(x, y) \cdot (x, y) = x^2 + y^2$$

$$\therefore \vec{v} \cdot \vec{v} = |\vec{v}|^2$$

> 참고: ***벡터 크기의 정의***      
벡터의 크기를 정의할 때 피타고라스 정리를 활용한 최단 거리의 개념으로 설명했는데, 직각삼각형과 같은 기하학적인 요소를 완전히 배제한다면 벡터의 크기는 자신을 내적한 결과의 제곱근으로 정의할 수 있다.

내적은 교환법칙과 분배법칙이 성립하기 때문에, 두 벡터 합의 내적 $(\vec{u} + \vec{v}) \cdot (\vec{u} + \vec{v})$은 두 벡터의 크기로 표현할 수 있다.

$$
\begin{matrix}
(\vec{u} + \vec{v}) \cdot (\vec{u} + \vec{v}) &=& \vec{u} \cdot \vec{u} + \vec{v} \cdot \vec{v} + 2(\vec{u} \cdot \vec{v}) \\
&=& |\vec{u}|^2 + |\vec{v}|^2 + 2(\vec{u} \cdot \vec{v}) \\
\end{matrix}
$$

벡터의 내적은 벡터를 응용하는 데 있어 빈번히 사용되는 중요한 공식이다.      
특히 ***곱셈과 덧셈으로만 구성된 내적은 컴퓨터에서 빠르게 처리***되기 때문에, 컴퓨터 그래픽에서 실시간으로 변화하는 효과를 구현하는 데 유용하게 사용된다.    

# 17.2. 내적과 삼각함수의 관계
벡터의 내적은 [그림 6-1](#그림-6-1-두-벡터의-사잇각-세타)과 같이 ***두 벡터의 사잇각에 대한*** $\cos$ ***함수와 비례하는 특징***을 가진다.

###### 그림 6-1 두 벡터의 사잇각 세타
![두 벡터의 사잇각 세타](/img/)

두 벡터 $\vec{u}, \vec{v}$의 사잇각을 $\theta$라고 할 때 내적과 $\cos$ 함수의 관계는 다음과 같다.

###### 식 6-1

$$\vec{u} \cdot \vec{v} = |\vec{u}||\vec{v}| \cos \theta$$

[그림 6-2](#그림-6-2-삼각형의-설정)와 같이 데카르트 좌표계에 세 점 $A, B, C$로 구성된 삼각형을 그리고, 각 점을 마주보는 벡터를 $\vec{a}, \vec{b}, \vec{c}$로, 원점에 위치한 사잇각은 $\theta$로 지정하자.

###### 그림 6-2 삼각형의 설정
![삼각형의 설정](/img/)

삼각형을 구성하는 점과 벡터의 값을 [표 6-1](#표-6-1-삼각형을-구성하는-점과-변을-구성하는-벡터의-좌표)에 정리했다(편의상 점과 벡터를 구분하는 마지막 차원 값 0과 1은 생략한다).

###### 표 6-1 삼각형을 구성하는 점과 변을 구성하는 벡터의 좌표
|삼각형 점의 좌표|삼각형 변을 구성하는 벡터|
|---|---|
|$B = (0, 0)$|$\vec{a} = C - B = (\|\vec{a}\|, 0)$|
|$C = (\vec{a}, 0)$|$\vec{c} = A - B = (\|\vec{c}\| \cos \beta, \|\vec{c}\| \sin \beta)$|
|$A = (\|\vec{c}\| \cos \beta, \|\vec{c}\| \sin \beta)$|$\vec{b} = C - A = (\|\vec{a}\| - \|\vec{c}\| \cos \beta, 0 - \|\vec{c}\| \sin \beta)$|

여기서 벡터 $\vec{b}$는 [그림 6-3](#그림-6-3-벡터의-뺄셈으로-표현한-벡터-b)과 같이 벡터 $\vec{a}$에서 벡터 $\vec{c}$를 뺀 결과와 동일하다.

$$\vec{b} = C - A = \vec{a} + (-\vec{c})$$

###### 그림 6-3 벡터의 뺄셈으로 표현한 벡터 b
![벡터의 뺄셈으로 표현한 벡터 b](/img/)

이때 벡터 $\vec{b}$의 크기를 제곱한 수식은 다음과 같이 전개된다.

$$
\begin{matrix}
|\vec{b}|^2 &=& (|\vec{a}| - |\vec{c}| \cos \theta)^2 + |\vec{c}|^2 \sin^2 \theta \\
&=& |\vec{a}|^2 - 2|\vec{a}||\vec{c}| \cos \theta + |\vec{c}|^2 \cos^2 \theta + |\vec{c}|^2 \sin^2 \theta \\
&=& |\vec{a}|^2 + |\vec{c}|^2 - 2|\vec{a}||\vec{c}| \cos \theta \\
\end{matrix}$$

***같은 벡터를 내적하면 벡터 크기의 제곱***이 되므로 이를 활용해 내적을 전개할 수 있다.

$$
\begin{matrix}
|\vec{b}|^2 &=& \vec{b} \cdot \vec{b} \\
&=& (\vec{a} - \vec{c}) \cdot (\vec{a} - \vec{c}) \\
&=& (\vec{a} + (-\vec{c})) \cdot (\vec{a} + (-\vec{c})) \\
&=& |\vec{a}|^2 + |\vec{c}|^2 - 2\vec{a} \cdot \vec{c} \\
\end{matrix}$$

위의 두 식은 동일한 값이므로 다음 식이 성립함을 알 수 있다.

$$\vec{a} \cdot \vec{c} = |\vec{a}||\vec{c}| \cos \theta$$

[식 6-1](#식-6-1)에서 두 벡터의 크기가 1이면, 두 벡터의 내적은 $\cos$ 함수가 된다.

###### 식 6-2

$$\vec{u} \cdot \vec{v} = \cos \theta$$

이러한 내적의 성질은 ***덧셈과 곱셈만 사용***해 $\cos$ 함수 값을 빠르게 계산할 수 있어 유용하게 활용된다.     
또한 [식 6-1](#식-6-1)에서 영벡터가 아닌 경우, 내적 값이 0이 되기 위한 조건은 $\cos$ 함수 값이 0이 되는 경우 뿐인데, 이는 두 벡터의 사잇각이 $90^\circ$ 혹은 $270(-90^\circ)$인 경우다.     
이는 [그림 6-4](#그림-6-4-두-벡터의-내적이-0이-나오는-경우)와 같이 ***두 벡터가 서로 직교하는 경우***다.

###### 그림 6-4 두 벡터의 내적이 0이 나오는 경우
![두 벡터의 내적이 0이 나오는 경우](/img/)

따라서 ***두 벡터의 내적이 0이면 두 벡터는 직교한다***고 결론내릴 수 있으며 이는 두 벡터의 ***직교성을 판별하는 데 활용***될 수 있다.

직교성을 판별할 수 있는 내적의 성질은 많은 곳에서 응용된다.     
벡터 공간에서 직교하는 두 표준기저벡터 $(1, 0)$과 $(0, 1)$을 내적한 결과는 0이 나온다.  
두 표준기저벡터를 각 $\theta$만큼 회전한 두 기저벡터도 서로 직교하는데, [그림 6-5](#그림-6-5-회전행렬을-구성하는-항상-직교하는-두-기저벡터)와 같이 두 기저벡터 $(\cos \theta, \sin \theta)$와 $(-\sin \theta, \cos \theta)$는 항상 직교하기 때문에 두 벡터의 내적은 언제나 0이 나온다.

###### 그림 6-5 회전행렬을 구성하는 항상 직교하는 두 기저벡터
![회전행렬을 구성하는 항상 직교하는 두 기저벡터](/img/)

# 17.3. 행렬의 곱셈을 내적으로 표현하기
***행렬의 곱셈 연산은 내적으로 표현이 가능하다***.    

$$
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix}
\begin{bmatrix}
x \\
y \\
\end{bmatrix} = 
\begin{bmatrix}
ax + by \\
cx + dy \\
\end{bmatrix}
$$

행렬과 벡터의 곱셈은 행렬을 구성하는 두 개의 행벡터 $(a, b), (c, d)$와 벡터를 구성하는 열벡터 $(x, y)$의 내적으로 표현할 수 있다.

$$
\begin{bmatrix}
ax + by \\
cx + dy \\
\end{bmatrix} =
\begin{bmatrix}
(a, b) \cdot (x, y) \\
(c, d) \cdot (x, y) \\
\end{bmatrix}
$$

행렬의 곱셈 또한 벡터의 내적으로 바꿔 표현할 수 있다.   
행렬의 곱을 내적으로 표현하면 다음과 같다.

$$
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix}
\begin{bmatrix}
e & f \\
g & h \\
\end{bmatrix} =
\begin{bmatrix}
ae + bg & af + bh \\
ce + dg & cf + dh \\
\end{bmatrix} =
\begin{bmatrix}
(a, b) \cdot (e, g) & (a, b) \cdot (f, h) \\
(c, d) \cdot (e, g) & (c, d) \cdot (f, h) \\
\end{bmatrix}
$$

***직교 행렬(Orthogonal matrix)*** 은 ***정방행렬을 구성하는 모든 행벡터와 열벡터의 크기가 1이고 벡터들이 서로 직교하는 행렬***이다.     
$a, b, c, d$로 구성된 직교행렬을 $Q$로 지정하면 열벡터와 행벡터를 구성하는 $(a, b), (b, d), (a, c), (c, d)$의 크기는 1이고 $(a, b)$와 $(c, d)$는 서로 직교한다.

$$Q = 
\begin{bmatrix}
a & c \\
b & d \\
\end{bmatrix}$$

직교행렬이 지니는 특징은 ***직교행렬의 전치행렬은 역행렬이 된다***는 점이다.  
그렇다면 직교행렬 $Q$와 이의 전치행렬 $Q^T$의 곱은 항등행렬이 된다.

$$Q \cdot Q^T = I$$

이는 내적을 사용해 증명할 수 있다.  
임의의 직교행렬과 이의 전치행렬의 곱을 내적을 사용해 표현해보자.

$$
\begin{bmatrix}
a & c \\
b & d \\
\end{bmatrix}^T
\begin{bmatrix}
a & c \\
b & d \\
\end{bmatrix} =
\begin{bmatrix}
(a, b) \cdot (a, b) & (a, b) \cdot (c, d) \\
(c, d) \cdot (a, b) & (c, d) \cdot (c, d) \\
\end{bmatrix}
$$

직교행렬의 정의에 의해 벡터 $(a, b)$와 $(c, d)$는 서로 직교하므로 두 벡터의 내적은 0이 나온다.  
직교행렬의 정의에 의해 행벡터와 열벡터의 크기는 각각 1이므로, 자신을 내적한 결과는 1이 된다.    
따라서 직교행렬과 그 전치행렬의 곱은 언제나 항등행렬을 보장한다.

$$
\begin{bmatrix}
(a, b) \cdot (a, b) & (a, b) \cdot (c, d) \\
(c, d) \cdot (a, b) & (c, d) \cdot (c, d) \\
\end{bmatrix} = 
\begin{bmatrix}
1 & 0 \\
0 & 1 \\
\end{bmatrix} = 
I
$$

***회전 변환행렬은 각 행벡터와 열벡터의 크기가 1이고 서로 직교하므로 직교행렬이다***.     
회전행렬의 역행렬은 전치연산으로 쉽게 구할 수 있다.

$$
\begin{matrix}
R_\theta &=& 
\begin{bmatrix}
\cos \theta & -\sin \theta \\
\sin \theta & \cos \theta \\
\end{bmatrix} \\
R^T_\theta \cdot R_\theta &=&
\begin{bmatrix}
\cos^2 \theta + \sin^2 \theta & 0 \\
0 & \cos^2 \theta + \sin^2 \theta \\
\end{bmatrix} = 
\begin{bmatrix}
1 & 0 \\
0 & 1 \\
\end{bmatrix} =
1
\end{matrix}
$$

여러 종류의 선형 변환 중 물체의 형태가 그대로 유지되는 선형 변환을 ***강체 변환(Rigid Transformation)*** 이라고 하는데, 선형 변환이 강체 변환이 되기 위한 조건은 다음과 같다.

1. 변화된 기저벡터의 크기는 모두 1이어야한다.
2. 모든 기저벡터는 서로 직교해야 한다.
3. 행렬식의 값이 1이어야 한다.

회전 변환은 강체 변환의 성질을 가지고 있음을 수식으로 확인해보자.   
앞에서 회전행렬은 직교행렬의 성질을 가지고 있음을 확인했으므로 1번과 2번은 만족한다.    
3번을 확인하기 위해 회전 행렬의 행렬식 값을 확인해보자.     
회전행렬의 행렬식 $ad - bc$의 값은 언제나 1이 됨을 알 수 있다.  
따라서 ***회전 변환은 물체의 형태를 그대로 유지시켜주는 강체 변환***이다.

$$\det(R) = \cos^2 \theta + \sin^2 \theta = 1$$

# 18. 시야 판별
# 18.1. 앞뒤 판별
게임 제작 과정에서 공간을 파악하는 데 가장 유용하게 활용되는 사례는 목표물이 캐릭터의 앞에 있는지, 뒤에 있는지를 구분하는 것이다.   
이는 내적의 부호를 통해 쉽게 파악할 수 있다.

내적과 삼각함수와의 관계를 나타내는 [식 6-1](#식-6-1)을 살펴보자.   
벡터의 크기 값은 언제나 양수이므로 벡터 내적의 부호는 $\cos$ 함수가 결정한다.    
$\cos$ 함수는 [그림 6-6](#그림-6-6--180-180-범위에서의-cos-함수-그래프)에서 $(-90^\circ, 90^\circ)$ 영역에 대해 양의 부호를 가지고 $-90^\circ$와 $90^\circ$에서는 0, 나머지 범위에서는 음의 부호를 가진다.

###### 그림 6-6 [-180, 180] 범위에서의 cos 함수 그래프
![-180, 180 범위에서의 cos 함수 그래프](/img/)

벡터 내적의 부호는 [그림 6-7](#그림-6-7-벡터-내적의-부호-영역)과 같이 두 벡터가 이루는 사잇각의 범위에 따라 결정된다.    
첫 번째 벡터를 캐릭터의 시선 방향으로 생각한다면 두 번째 벡터는 시선 벡터에서부터 멀어질수록 사잇각이 커질 것이다.      
하지만 $\cos$ 함수는 $(-90^\circ, 90^\circ)$ 영역에 대해 양의 부호를 가지므로 두 번째 벡터가 보라색으로 칠해진 영역에 존재한다면 내적 값은 언제나 양의 부호를 가진다.

###### 그림 6-7 벡터 내적의 부호 영역
![벡터 내적의 부호 영역](/img/)

이를 응용하면 내적의 부호만 가지고도 두 벡터가 같은 방향을 향하는지, 아니면 서로 마주보는지를 확인할 수 있다.

- 벡터 내적의 결과가 양수: 두 벡터는 같은 방향을 향하고 있다.
- 벡터 내적의 결과가 음수: 두 벡터는 다른 방향을 향하고 있다.   
벡터는 위치의 개념이 없으므로 두 벡터는 서로 마주보고 있다로도 해석할 수 있다.
- 벡터 내적의 결과가 0: 두 벡터는 서로 직교한다.

이 성질을 응용하면 앞뒤 판별 기능을 구현할 수 있다.     
[그림 6-8](#그림-6-8-캐릭터-시선-벡터와-목표-벡터의-설정)과 같이 게임 공간에 캐릭터와 목표물이 배치된 상황을 가정한다.   
캐릭터가 바라보는 방향을 시선 벡터 $\vec{f}$로 표시한 후에 목표물의 위치에서 캐릭터의 위치를 빼서 캐릭터에서 목표물로 향하는 벡터 $\vec{v}$를 만든다.    
시선 벡터 $\vec{f}$와 목표물로 향하는 벡터 $\vec{v}$의 사잇각을 $\alpha$로 설정한다.

###### 그림 6-8 캐릭터 시선 벡터와 목표 벡터의 설정
![캐릭터 시선 벡터와 목표 벡터의 설정](/img/)

그렇다면 두 벡터의 내적 $\vec{f} \cdot \vec{v}$의 부호에 따라 캐릭터와 목표물의 사이의 공간 구성을 파악할 수 있다.

- $\vec{f} \cdot \vec{v}$ 결과의 부호가 양수: 캐릭터 앞에 목표물이 있다.
- $\vec{f} \cdot \vec{v}$ 결과의 부호가 음수: 캐릭터 뒤에 목표물이 있다.
- $\vec{f} \cdot \vec{v}$ 결과가 0: 캐릭터 바로 옆에 목표물이 있다.

# 18.2. 시야 판별
[그림 6-9](#그림-6-9-캐릭터-시야각의-설정)와 같이 캐릭터에 시야각이라는 특성을 부여해보자.  
캐릭터에 부여한 시야각이 $\beta$라면 양쪽으로 균등하게 $\frac{\beta}{2}$의 시야각이 설정된다.   
나머지는 앞뒤 판별 문제와 동일하게 캐릭터의 시선 방향을 벡터 $\vec{f}$로 표시하고, 캐릭터에서 목표물로 향하는 벡터 $\vec{v}$를 만든 후 벡터 $\vec{f}$와 벡터 $\vec{v}$의 사잇각을 $\alpha$로 설정한다.

###### 그림 6-9 캐릭터 시야각의 설정
![캐릭터 시야각의 설정](/img/)

내적으로 캐릭터의 시야에 목표물이 탐지되는지 여부를 파악해보자.     
이는 사잇각 $\alpha$가 시야각의 절반인 $\frac{\beta}{2}$보다 작거나 같은지 비교하는 문제가 된다.    
내적에 비례하는 $\cos$ 함수는 [그림 6-10](#그림-6-10-각-0-180-범위에서의-코사인-그래프의-특징)에서 볼 수 있듯이 $[0^\circ, 180^\circ]$ 범위에서는 각이 커질수록 값이 작아지는 성질을 지닌다.     
따라서 해당 범위에서 각이 작을수록 $\cos$ 함수의 값은 반대로 커진다.

###### 그림 6-10 각 [0, 180] 범위에서의 코사인 그래프의 특징
![각 0, 180 범위에서의 코사인 그래프의 특징](/img/)

이를 활용해 다음의 과정으로 캐릭터의 시야에 목표물이 탐지됐는지 판별할 수 있다.

1. 시야각을 절반 나눈 각의 $\cos \frac{\beta}{2}$를 미리 계산해둔다.
2. 캐릭터의 시선 벡터를 구하고 이의 크기를 1로 정규화시킨다.    
이를 단위 벡터 $\hat{f}$라고 한다.
3. 캐릭터에서 목표물로 향하는 벡터도 정규화시킨다.  
이를 단위 벡터 $\hat{v}$라고 한다.
4. 내적 $\hat{f} \cdot \hat{v}$의 계산 결과는 $\cos \alpha$가 된다.  
이를 앞서 계산해 둔 $\cos \frac{\beta}{2}$값과 비교한다.

$\hat{f} \cdot \hat{v}$ 값이 $\cos \frac{\beta}{2}$보다 크다면 사잇각이 시야각보다 작다는 것을 의미하므로 물체가 시야 영역에 들어왔음을 의미한다.   
따라서 사잇각을 몰라도 내적 $\hat{f} \cdot \hat{v}$의 결과에 따라 캐릭터 시야 범위에 목표물이 있는지 파악할 수 있다.

- $\hat{f} \cdot \hat{v} \geq \cos \frac{\beta}{2}$: 목표물이 시야 범위 안에 있음
- $\hat{f} \cdot \hat{v} < \cos \frac{\beta}{2}$: 목표물이 시야 범위 밖에 있음

$atan2$ 함수를 활용해 두 벡터가 이루는 각 $\alpha$를 구한 후 이를 $\frac{\beta}{2}$와 비교해도 동일한 결과를 얻을 수 있다.  
하지만 단위 벡터를 구한 후 내적을 계산하는 방식이 $atan2$를 호출하는 것보다 더 효율적이다.

# 19. 조명 효과의 구현
현실 세계와 비슷한 조명 효과를 만들기 위해 고안된 방법으로 ***램버트 반사(Lambertian reflection)*** 모델이 있다.  
이 모델을 고안한 스위스의 수학자 ***요한 하인리히 램버트(Johann Heinrich Lambert)*** 의 이름을 따서 지어진 램버트 반사 모델은 ***컴퓨터 그래픽스에서 표면에서의 조명 모델 계산***을 위해 쓰인다.     
[그림 6-11](#그림-6-11-램버트-반사-모델로-3차원-물체의-조명-효과를-구현한-예시)은 램버트 반사 모델을 사용해 3차원 물체의 조명 효과를 구현한 화면이다.   
램버트 반사 모델은 계산량이 적어 속도가 빠르지만 그럴듯한 조명 효과를 줄 수 있어 ***실시간 조명 구현***이 필요한 게임 제작에 널리 사용된다.

###### 그림 6-11 램버트 반사 모델로 3차원 물체의 조명 효과를 구현한 예시
![램버트 반사 모델로 3차원 물체의 조명 효과를 구현한 예시](/img/)

[그림 6-12](#그림-6-12-조명-모델-계산을-위한-설정)와 같이 광원이 물체를 향해 직사광선을 발사하는 상황을 가정해보자.    
빛을 받아 표면에서 반사되는 ***빛의 세기는 두 벡터가 만드는 사잇각의*** $\cos$ ***함수에 비례한다***는 것이 램버트 반사 모델의 주요 내용이다.   
표면이 향하는 단위 벡터를 $\hat{N}$으로 지정하고 표면에서 광원으로 향하는 단위 벡터를 $\hat{L}$로 지정한다.

###### 그림 6-12 조명 모델 계산을 위한 설정
![조명 모델 계산을 위한 설정](/img/)

***두 벡터의 내적***을 사용하면 램버트 반사 모델에 필요한 사잇각의 $\cos$ 값을 얻을 수 있다.

$$\hat{N} \cdot \hat{L} = \cos \theta$$

# 20. 투영 벡터
***벡터 내적은 어떤 벡터를 다른 벡터에 직교 투영하는 용도로 사용된다***.  
예를 들어 [그림 6-13](#그림-6-13-카메라-공간의-분석-예시)과 같이 카메라가 만드는 공간을 분석할 때 ***카메라와 물체 사이의 거리*** 외에도 ***카메라에서 물체까지의 깊이*** 값이 필요한 경우도 있다.  
이 경우 내적을 활용한 투영 벡터를 구하는 공식이 활용된다.

###### 그림 6-13 카메라 공간의 분석 예시
![카메라 공간의 분석 예시](/img/)

[그림 6-14](#그림-6-14-벡터-투영-과정의-시각화)와 같이 임의의 두 벡터 $\vec{u}$와 $\vec{v}$가 주어졌을 때 벡터 $\vec{u}$를 벡터 $\vec{v}$에 투영하는 상황을 생각해보자.     
투영한 벡터를 $\vec{v'}$로 표기했는데, 투영한 벡터는 대상 벡터 $\vec{v}$와 방향이 같기 때문이다.

###### 그림 6-14 벡터 투영 과정의 시각화
![벡터 투영 과정의 시각화](/img/)

따라서 투영한 벡터 $\vec{v'}$의 크기를 알고 있다면 [그림 6-15](#그림-6-15-투영-벡터식-유도에-사용되는-단위-벡터)에서 보듯이 $\vec{v}$를 정규화시킨 단위 벡터 $\hat{v}$를 구하고 그 크기를 곱하면 투영된 벡터를 얻을 수 있다.

###### 그림 6-15 투영 벡터식 유도에 사용되는 단위 벡터
![투영 벡터식 유도에 사용되는 단위 벡터](/img/)

이를 수식으로 표현하면 다음과 같다.

$$\vec{v'} = |\vec{v'}| \cdot \hat{v}$$

내적을 활용해 $\vec{u}$로부터 $\vec{v'}$를 구하도록 수식을 전개한다.

$$
\begin{matrix}
\vec{v'} &=& |\vec{v'}| \cdot \hat{v} \\
&=& |\vec{v'}| \cdot \frac{\vec{v}}{|\vec{v}|} \\
&=& |\vec{u}| \cdot \cos \theta \cdot \frac{\vec{v}}{|\vec{v}|} \\
&=& |\vec{u}| \cdot \frac{\vec{u} \cdot \vec{v}}{|\vec{u}||\vec{v}|} \cdot \frac{\vec{v}}{|\vec{v}|} \\
&=& \frac{(\vec{u} \cdot \vec{v})}{|\vec{v}|^2} \cdot \vec{v} \\
&=& \frac{(\vec{u} \cdot \vec{v})}{(\vec{v} \cdot \vec{v})} \cdot \vec{v} \\
\end{matrix}
$$

1. 단위 벡터 $\hat{v}$를 구하기 위해 벡터 $\vec{v}$를 정규화한다.
2. $\vec{v'}$의 크기는 벡터 $\vec{u}$의 크기에 $\cos \theta$를 곱해 얻을 수 있다.
3. $\cos \theta$는 내적 공식 $\vec{u} \cdot \vec{v} = |\vec{u}||\vec{v}| \cos \theta$로부터 얻을 수 있다.
4. 분자와 분모를 소거하고 정리한다.
5. 벡터의 크기의 제곱을 내적으로 변경한다.

위 식에서 투영할 벡터 $\vec{v}$의 크기가 1이면 위 식은 다음과 같이 단순하게 정리된다.

$$\vec{v'} = (\vec{u} \cdot \vec{v}) \cdot \vec{v}$$