# 게임 수학 정리 문서
게임 개발에 필요한 수학 개념에 대해 정리한 문서입니다.

# 목차
* [1. 수와 집합](#1-수와-집합)
    * [1.1. 연산과 수의 구조](#11-연산과-수의-구조)
    * [1.2. 수의 구조](#12-수의-구조)
    * [1.3. 수의 표현](#13-수의-표현)
* [2. 함수](#2-함수)
    * [2.1. 함수의 개념과 종류](#21-함수의-개념과-종류)
    * [2.2. 합성함수](#22-합성함수)
    * [2.3. 항등함수와 역함수](#23-항등함수와-역함수)
    * [2.4. 곱집합을 활용한 좌표 평면으로의 확장](#24-곱집합을-활용한-좌표-평면으로의-확장)
* [3. 데카르트 좌표계](#3-데카르트-좌표계)
* [4. 벡터 공간과 벡터](#4-벡터-공간과-벡터)
    * [4.1. 스칼라와 벡터](#41-스칼라와-벡터)
    * [4.2. 벡터 공간의 연산](#42-벡터-공간의-연산)
    * [4.3. 벡터의 크기와 이동](#43-벡터의-크기와-이동)
* [5. 벡터의 결합과 생성](#5-벡터의-결합과-생성)
* [6. 삼각함수](#6-삼각함수)
    * [6.1. 삼각함수의 성질](#61-삼각함수의-성질)
    * [6.2. 각의 측정법](#62-각의-측정법)
* [7. 삼각함수를 활용한 물체의 회전](#7-삼각함수를-활용한-물체의-회전)
* [8. 삼각함수의 역함수](#8-삼각함수의-역함수)
* [9. 극좌표계](#9-극좌표계)
* [10. 선형성: 예측 가능한 비례 관계](#10-선형성-예측-가능한-비례-관계)
    * [10.1. 선형 함수](#101-선형-함수)
    * [10.2. 벡터 공간의 선형 변환](#102-벡터-공간의-선형-변환)
* [11. 행렬](#11-행렬)
    * [11.1. 행렬의 기본 연산](#111-행렬의-기본-연산)
    * [11.2. 행렬의 곱셈](#112-행렬의-곱셈)
    * [11.3. 정방행렬의 곱셈](#113-정방행렬의-곱셈)
* [12. 행렬의 설계](#12-행렬의-설계)
    * [12.1. 크기 변환행렬](#121-크기-변환행렬)
    * [12.2. 회전 변환행렬](#122-회전-변환행렬)
    * [12.3. 전단 변환행렬](#123-전단-변환행렬)
    * [12.4. 삼각함수의 덧셈 정리](#124-삼각함수의-덧셈-정리)
* [13. 역행렬](#13-역행렬)
    * [13.1. 역행렬의 존재를 판별하는 행렬식](#131-역행렬의-존재를-판별하는-행렬식)
    * [13.2. 크기 변환행렬의 역행렬](#132-크기-변환행렬의-역행렬)
    * [13.3. 전단 변환행렬의 역행렬](#133-전단-변환행렬의-역행렬)
    * [13.4. 회전 변환행렬의 역행렬](#134-회전-변환행렬의-역행렬)
    * [13.5. 행렬 곱의 역행렬](#135-행렬-곱의-역행렬)
* [14. 이동 변환을 위한 아핀 공간](#14-이동-변환을-위한-아핀-공간)
* [15. 아핀 공간의 구성 요소](#15-아핀-공간의-구성-요소)
    * [15.1. 점](#151-점)
    * [15.2. 이동 벡터](#152-이동-벡터)
    * [15.3. 아핀 공간의 성질](#153-아핀-공간의-성질)
* [16. 아핀 결합](#16-아핀-결합)
    * [16.1. 두 점의 결합](#161-두-점의-결합)
* [17. 벡터의 내적](#17-벡터의-내적)
    * [17.1. 내적의 성질](#171-내적의-성질)
    * [17.2. 내적과 삼각함수의 관계](#172-내적과-삼각함수의-관계)
    * [17.3. 행렬의 곱셈을 내적으로 표현하기](#173-행렬의-곱셈을-내적으로-표현하기)
* [18. 시야 판별](#18-시야-판별)
    * [18.1. 앞뒤 판별](#181-앞뒤-판별)
    * [18.2. 시야 판별](#182-시야-판별)
* [19. 조명 효과의 구현](#19-조명-효과의-구현)
* [20. 투영 벡터](#20-투영-벡터)
* [21. 세 점의 결합](#21-세-점의-결합)
* [22. 메시](#22-메시)
* [23. 무게중심좌표](#23-무게중심좌표)
    * [23.1. 무게중심좌표의 계산](#231-무게중심좌표의-계산)
* [24. 텍스처 매핑](#24-텍스처-매핑)
* [25. 3차원 공간의 설계](#25-3차원-공간의-설계)
* [26. 3차원 공간의 트랜스폼](#26-3차원-공간의-트랜스폼)
    * [26.1. 오일러 각](#261오일러-각)
    * [26.2. 회전행렬의 유도](#262-회전행렬의-유도)
    * [26.3. 3차원 모델링 행렬](#263-3차원-모델링-행렬)
* [27. 카메라 공간](README2.md/#27-카메라-공간)
* [28. 오일러 각의 특징](README2.md/#28-오일러-각의-특징)
    * [28.1 짐벌락 현상](README2.md/#281-짐벌락-현상)
    * [28.2 회전 보간의 계산](README2.md/#282-회전-보간의-계산)
* [29. 벡터의 외적](README2.md/#29-벡터의-외적)
    * [29.1. 평행성 판별](README2.md/#291-평행성-판별)
    * [29.2. 법선 벡터](README2.md/#292-법선-벡터)
    * [29.3. 좌우 방향 판별](README2.md/#293-좌우-방향-판별)
* [30. 벡터로부터 회전행렬 생성](README2.md/#30-벡터로부터-회전행렬-생성)
* [31. 렌더링 계산량을 줄여주는 백페이스 컬링](README2.md/#31-렌더링-계산량을-줄여주는-백페이스-컬링)
* [32. 오일러 각의 문제를 해결하는 로드리게스 회전 공식](README2.md/#32-오일러-각의-문제를-해결하는-로드리게스-회전-공식)
* [33. 삼중곱](README2.md/#33-삼중곱)
    * [33.1. 스칼라 삼중곱](README2.md/#331-스칼라-삼중곱)
    * [33.2. 벡터 삼중곱](README2.md/#332-벡터-삼중곱)
* [34. 원근 투영 변환의 원리](README2.md/#34-원근-투영-변환의-원리)
* [35. 동차 좌표계](README2.md/#35-동차-좌표계)
* [36. 깊이 값](README2.md/#36-깊이-값)
* [37. 원근 보정 매핑](README2.md/#37-원근-보정-매핑)
* [38. 깊이 버퍼](README2.md/#38-깊이-버퍼)
* [39. 절두체 컬링](README2.md/#39-절두체-컬링)
    * [39.1. 평면의 방정식](README2.md/#391-평면의-방정식)
    * [39.2. 평면의 방정식의 정규화](README2.md/#392-평면의-방정식의-정규화)
    * [39.3. 평면의 방정식을 활용한 절두체 표현](README2.md/#393-평면의-방정식을-활용한-절두체-표현)
    * [39.4. 원근 투영 행렬로부터 평면의 방정식 만들기](README2.md/#394-원근-투영-행렬로부터-평면의-방정식-만들기)
* [40. 바운딩 볼륨](README2.md/#40-바운딩-볼륨)
    * [40.1. 구 바운딩 볼륨의 판정](README2.md/#401-구-바운딩-볼륨의-판정)
    * [40.2. aabb와의 판정](README2.md/#402-aabb와의-판정)
* [41. 삼각형 클리핑](README2.md/#41-삼각형-클리핑)
* [42. 복소수](README2.md/#42-복소수)
    * [42.1. 허수](README2.md/#421-허수)
    * [42.2. 복소수의 구조](README2.md/#422-복소수의-구조)
* [43. 복소평면](README2.md/#43-복소평면)
    * [43.1. 단위 복소수와의 곱](README2.md/#431-단위-복소수와의-곱)
    * [43.2. 켤레 복소수의 회전 변환](README2.md/#432-켤레-복소수의-회전-변환)
* [44. 복소수와 행렬의 관계](README2.md/#44-복소수와-행렬의-관계)
* [45. 자연지수함수](README2.md/#45-자연지수함수)
    * [45.1. 무리수 e](README2.md/#451-무리수-e)
    * [45.2. 자연지수함수](README2.md/#452-자연지수함수)
* [46. 미분](README2.md/#46-미분)
    * [46.1. 도함수](README2.md/#461-도함수)
    * [46.2. 자연지수함수의 도함수)](README2.md/#462-자연지수함수의-도함수)
    * [46.3. sin 함수와 cos 함수의 도함수)](README2.md/#463-sin-함수와-cos-함수의-도함수)
* [47. 급수](README2.md/#47-급수)
    * [47.1. 등비수열](README2.md/#471-등비수열)
    * [47.2. 급수](README2.md/#472-급수)
    * [47.3. 매클로린 급수](README2.md/#473-매클로린-급수)
* [48. 오일러 공식](README2.md/#48-오일러-공식)
* [49. 사원수 대수](README2.md/#49-사원수-대수)
    * [49.1. 사원수를 구성하는 세 허수](README2.md/#491-사원수를-구성하는-세-허수)
    * [49.2. 사원수의 구조](README2.md/#492-사원수의-구조)
    * [49.3. 사원수와 벡터](README2.md/#493-사원수와-벡터)
* [50. 사원수의 회전](README2.md/#50-사원수의-회전)
    * [50.1. 사원수와 오일러 공식](README2.md/#501-사원수와-오일러-공식)
    * [50.2. 회전 사원수를 이용한 3차원 공간에서의 회전](README2.md/#502-회전-사원수를-이용한-3차원-공간에서의-회전)
* [51. 사원수의 변환](README2.md/#51-사원수의-변환)
    * [51.1. 오일러 각에서 사원수로의 변환](README2.md/#511-오일러-각에서-사원수로의-변환)
    * [51.2. 사원수에서 오일러 각으로의 변환](README2.md/#512-사원수에서-오일러-각으로의-변환)
    * [51.3. 사원수에서 회전 변환행렬로의 변환](README2.md/#513-사원수에서-회전-변환행렬로의-변환)
    * [51.4. 회전 변환행렬에서 사원수로의 변환](README2.md/#514-회전-변환행렬에서-사원수로의-변환)
* [52. 사원수의 보간](README2.md/#52-사원수의-보간)

# 1. 수와 집합
### 선요약

> 집합: 서로 구분되는 원소로 구성된 묶음 = 소박한 집합론         
> 대표적인 수집합: 자연수, 정수, 유리수, 실수, 복소수, 사원수 등        
> 명제: 집합의 성질을 참과 거짓으로 명확하게 구분하는 문장      
> 공리: 명제 중에서 증명할 필요가 없는 기본 명제    
> 
> 공리를 기반으로 대상을 구분하는 집합론 = 공리적 집합론
> 
> |집합론|설명|
> |---|---|
> |소박한 집합론|용도에 따라 수집합을 구분하고 인간의 언어를 통해 정의한다|
> |공리적 집합론|수가 가지는 연산에 대한 공리를 기반으로 수를 분류한다|

* * *

[본문](README-ORIGIN.md#1-수와-집합)

# 1.1. 연산과 수의 구조
### 선요약

> 수집합의 고유한 특징: 원소를 이용해 연산      
> 대표적인 연산: 덧셈, 뺄셈, 곱셈, 나눗셈     
> 이항연산: 사칙연산과 같이 두 개의 원소를 사용해 새로운 원소를 만들어내는 연산       
> 
> |이항연산의 성질|정의|덧셈|곱셈|비고|
> |---|---|---|---|---|
> |닫혀 있음|어떤 집합에서 두 원소를 사용한 이항연산의 결과가 항상 그 집합에 속하는 성질|O|O||
> |교환법칙|두 원소의 좌우 순서를 바꿔도 결과가 동일한 성질|$$a + b = b + a$$|$$a \cdot b = b \cdot a$$||
> |결합법칙|세 원소의 연산 순서를 바꿔도 결과가 동일한 성질|$$(a + b) + c = a + (b + c)$$|$$(a \cdot b) \cdot c = a \cdot (b \cdot c)$$||
> |분배법칙|두 이항연산에 대해 $a \cdot (b + c) = a \cdot b + a \cdot c$와 $(b + c) \cdot a = b \cdot a + c \cdot a$의 결과가 나오는 성질|$$a \cdot (b + c) = a \cdot b + a \cdot c$$|$$(b + c) \cdot a = b \cdot a + c \cdot a$$||
> |항등원|주어진 원소와의 이항연산 결과가 언제나 주어진 원소가 되는 특별한 원소|$$a + 0 = a$$|$$a \cdot 1 = a$$||
> |역원|주어진 원소와의 이항연산 결과가 언제나 항등원이 되는 특별한 원소|$$a + (-a) = 0$$|$$a \cdot \frac{1}{a} = 1 \quad a \neq 0$$|실수에서 덧셈의 역원은 반대수, 곱셈의 역원은 역수라고 부른다|

* * *

[본문](README-ORIGIN.md#11-연산과-수의-구조)

# 1.2. 수의 구조
### 선요약

> 체의 구조: 공리적 집합론에서 덧셈과 곱셈 연산에 대해 11가지 공리를 모두 만족하는 수 집합
> 
> 체의 구조 11가지 공리:
> 1. 연산에 대해 닫혀 있다.
> 2. 연산에 대해 결합법칙이 성립한다.
> 3. 연산에 대한 항등원이 존재한다.
> 4. 연산에 대한 역원이 존재한다.
> 5. 연산에 대해 교환법칙이 성립한다.
> 6. 두 번째 연산에 대해 닫혀 있다.
> 7. 두 번째 연산에 대해 결합법칙이 성립한다.
> 8. 첫 번째 연산과 두 번째 연산에 대해 분배법칙이 성립한다.
> 9. 두 번째 연산에 대해 교환법칙이 성립한다.
> 10. 두 번째 연산에 대해 항등원이 존재한다.
> 11. 두 번째 연산에 대해 역원이 존재한다(단 0은 제외).
> 
> 대표적인 체의 구조를 가지는 수 집합: 유리수(Q), 실수(R)
> 
> 체의 구조에서 뺄셈과 나눗셈: 교환법칙을 만족하지 않기 때문에 체의 구조를 지니지 못한다.     
> 
> $$a - b \neq b - a$$
> 
> $$a \div b \neq b \div a$$
> 
> 뺄셈, 나눗셈 대신 덧셈, 곱셈의 역원을 사용하면 교환법칙이 성립하면서 같은 결과를 만들어낸다.
> 
> $$a + (-b) = (-b) + a$$
> 
> $$a \cdot \frac{1}{b} = \frac{1}{b} \cdot a$$
> 
> 체의 구조 특징: 특별한 예외 상황 없이 덧셈과 곱셈을 안전하고 자유롭게 사용할 수 있다.       
> 체는 사칙연산이 자유로이 시행될 수 있고 산술의 잘 알려진 규칙들(교환법칙, 분배법칙, 결합법칙)을 만족하는 수의 구조다.

* * *

[본문](README-ORIGIN.md#12-수의-구조)

# 1.3. 수의 표현
### 선요약

> 유리수: 유리수는 $\pi$나 $\sqrt{2}$ 같은 무리수를 표현할 수 없기 때문에 직선의 어느 지점에서는 빈틈이 발생
> 실수: 유리수 사이에 무리수를 채워 완벽한 연속성을 가지는 직선을 만들어내는 수
> 수직선(Number line): 실수를 대응시켜 표현한 직선

* * *

[본문](README-ORIGIN.md#13-수의-표현)

# 2. 함수
***함수(Function)란 두 집합에서 첫 번째 집합의 모든 원소가 빠짐없이 두 번째 집합의 어떤 원소에 대응하는 관계를 의미한다***.

# 2.1. 함수의 개념과 종류
### 선요약

> 두 집합 $X, Y$와 집합의 원소 $x, y$를 $X$에서 $Y$로 대응되는 함수: $y = f(x)$       
> 
> 함수의 규칙:      
> 1. 첫 번째 집합의 모든 원소에 대한 대응 관계가 존재해야 함
> 2. 첫 번째 집합의 원소는 두 번째 집합의 한 원소에만 대응되어야 함
> 
> - 정의역(Domain): 함수에서 왼쪽에 위치한 첫 번째 집합     
> - 공역(Codomain): 함수에서 오른쪽에 위치한 두 번째 집합       
> - 치역(Range): 정의역에 대응되는 공역의 원소만 따로 모은 부분집합(Subset)     
> 정의역의 모든 원소는 공역의 원소에 대응되어야 하지만, 공역의 모든 원소가 정의역에 대응할 필요는 없다.      
> 
> |함수|정의|
> |---|---|
> |전사함수(Surjection)|공역의 모든 요소가 정의역에 대응되는 함수를 의미(공역과 치역이 동일한 함수)|
> |단사함수(Injection)|정의역과 공역의 요소가 일대일로 대응되는 함수를 의미(정의역의 모든 요소가 공역의 요소에 일대일로 대응되는 함수)|
> |전단사함수(Bijection)|정의역과 공역의 모든 요소가 빠짐없이 일대일로 대응되는 함수를 의미(전사함수와 단사함수의 두 가지 성질을 모두 만족하는 함수)|

* * *

[본문](README-ORIGIN.md#21-함수의-개념과-종류)

# 2.2. 합성함수
### 선요약

> - 함수의 합성(Function composition): 2개의 함수를 연쇄적으로 이어서 하나의 함수로 만드는 연산
> - 합성함수 표기: $g \circ f$, $g(f(x))$     
> 먼저 실행되는 함수 $f$가 합성함수 기호($\circ$)의 오른쪽에 놓인다.
> 
> 세 함수로부터 만들어지는 합성함수 경우의 수: $(h \circ (g \circ f))(w)$, $((h \circ g) \circ f)(w)$
> 
> 합성 함수를 이항연산으로 규정하면, 합성 함수는 결합법칙이 성립한다.

* * *

[본문](README-ORIGIN.md#22-합성함수)

# 2.3. 항등함수와 역함수
### 선요약

> - 항등함수(Identity function): 정의역과 공역이 동일한 값으로 대응되는 함수
> - 역함수(Inverse function): 어떤 함수와 역함수를 합성한 결과는 언제나 항등함수가 된다       
> 역함수는 위 첨자를 붙여 $f^{-1}$로 표기한다
> 
> 역함수를 가지는 조건:
> - 전단사함수: 하나의 원소가 두 개의 원소에 대응되기 때문에 함수의 기본 조건을 만족하지 못함
> - 단사함수: 정의역의 모든 원소가 대응하지 않기 때문에 함수의 기본 조건을 만족하지 못함
> - 전단사함수: 정의역과 공역의 모든 원소가 일대일로 대응하기 때문에 모든 경우에서 역함수가 보장된다      
> 어떤 함수가 역함수를 가지기 위해서는 반드시 전단사함수의 형태가 되어야 한다
> 
> 합성함수의 역함수가 가지는 성질:
> - 합성함수 $g \circ f$를 거꾸로 뒤집은 역함수 $(g \circ f)^{-1}$는 두 함수의 역함수 $f^{-1}$과 $g^{-1}$를 반대 순서로 합성한 결과다
> - $(g \circ f)^{-1} = f^{-1} \circ g^{-1}$

* * *

[본문](README-ORIGIN.md#23-항등함수와-역함수)

# 2.4. 곱집합을 활용한 좌표 평면으로의 확장
### 선요약

> - 곱집합(Cartesian product 혹은 Product set): 두 집합의 원소를 순서쌍으로 묶은 원소의 집합        
> - 집합 $A$와 $B$의 곱집합 표시: $A \times B$
> - 원소 $a$와 $b$의 순서쌍 표시: $(a, b)$
> 
> 두 실수 집합의 곱집합 $R \times R$을 구성하고 정의역으로 설정해 입력 요소를 2개로 지정하면 수의 이항연산을 함수로 표현하는 것이 가능하고, 하나의 직선으로 표현한 실수 집합 $R$을 확장해 두 실수 집합의 곱집합 $R \times R$을 평면으로 나타낼 수 있다.       
> 두 실수 집합의 곱집합으로 형성된 평면에 다시 실수 집합을 곱집합으로 설정하면 3차원 공간이 된다.

* * *

[본문](README-ORIGIN.md#24-곱집합을-활용한-좌표-평면으로의-확장)

# 3. 데카르트 좌표계
### 선요약

> - 벡터(Vector): 평면을 구성하는 원소
> - 데카르트 좌표계(Cartesian coordinate system): 직선의 수 집합을 수직으로 배치해 평면을 표기하는 방식=곱집합/데카르트 곱(Cartesian product)
> - 좌표(Coordinate): 데카르트 좌표계의 한 원소, 곱집합과 동일하게 순서쌍으로 표현 $(x, y)$

* * *

[본문](README-ORIGIN.md#3-데카르트-좌표계)

# 4. 벡터 공간과 벡터
# 4.1. 스칼라와 벡터
### 선요약

> - 벡터 공간(Vector space): 공리적 집합론의 관점에서 두 개 이상의 실수를 곱집합으로 묶어 형성된 집합
> - 벡터(Vector): 벡터 공간의 원소
> - 스칼라(Scalar): 체의 구조를 가지는 수 집합의 원소     
> 공리적 집합론의 관점에서는 특정한 수 집합을 지칭하지 않고 연산이 갖는 성질만 다루기 때문에, 좌푯값으로 사용하는 $x$와 $y$를 실수로 규정하기보다는 체의 구조를 지니는 집합, 즉 체 집합의 원소로 규정한다

* * *

[본문](README-ORIGIN.md#41-스칼라와-벡터)

# 4.2. 벡터 공간의 연산
### 선요약

> 벡터 공간의 두 가지 기본 연산:
> 1. 벡터와 벡터의 덧셈(벡터의 합)        
> 
> $$\vec{v_1} + \vec{v_2} = (x_1, y_1) + (x_2, y_2) = (x_1 + x_2, y_1 + y_2)$$
> 
> 2. 스칼라와 벡터의 곱셈(스칼라 곱셈)
> 
> $$a \cdot \vec{v} = a \cdot (x, y) = (a \cdot x, a \cdot y)$$
> 
> 벡터 공간의 공리:
> |No|분류|공리|수식|
> |---|---|---|---|
> |1|벡터의 합|벡터의 합의 결합법칙|$\vec{u} + (\vec{v} + \vec{w}) = (\vec{u} + \vec{v}) + \vec{w}$|
> |2|벡터의 합|벡터의 합의 교환법칙|$\vec{u} + \vec{v} = \vec{v} + \vec{u}$|
> |3|벡터의 합|벡터의 합의 항등원|$\vec{v} + \vec{0} = \vec{v}$|
> |4|벡터의 합|벡터의 합의 역원|$\vec{v} + (-\vec{v}) = \vec{0}$|
> |5|스칼라 곱셉|스칼라 곱셈의 호환성|$a(b\vec{v}) = (ab)\vec{v}$|
> |6|스칼라 곱셉|스칼라 곱셈의 항등원|$1 \cdot \vec{v} = \vec{v}$|
> |7|스칼라 곱셉|벡터의 합에 대한 분배법칙|$a(\vec{u} + \vec{v}) = a\vec{u} + a\vec{v}$|
> |8|스칼라 곱셉|스칼라 덧셈에 대한 분배법칙|$(a + b)\vec{v} = a\vec{v} + b\vec{v}$|
> 
> 스칼라 곱셈은 스칼라배라고도 불린다.        
> 스칼라곱은 스칼라 곱셈과 다른 연산이며 내적을 의미한다.

* * *

[본문](README-ORIGIN.md#42-벡터-공간의-연산)

# 4.3. 벡터의 크기와 이동
### 선요약

> - 벡터의 크기: 원점으로부터의 최단 거리=노름(Norm)
> - 벡터 크기의 측정: 원점과 벡터를 연결해 직각삼각형을 그린 후, 피타고라스 정리를 사용해 거리를 측정
> 
> $$c^2 = a^2 + b^2$$
> 
> $$\therefore = \sqrt{a^2 + b^2}$$
> 
> - 단위 벡터(Unit Vector): 크기가 1인 벡터       
> 모자 기호(Hat)를 씌워 $\hat{v}$ 형태로 표시한다
> - 정규화(Normalize): 임의의 벡터 $\vec{v}$를 크기가 1인 단위 벡터 $\hat{v}$로 다듬는 작업       
> 스칼라 곱셈의 성질을 이용해 임의 벡터 $\vec{v}$를 이의 크기인 $|\vec{v}|$로 나누면 단위 벡터 $\hat{v}$를 얻을 수 있다
> 
> $$\hat{v} = \frac{\vec{v}}{|\vec{v}|}$$

* * *

[본문](README-ORIGIN.md#43-벡터의-크기와-이동)

# 5. 벡터의 결합과 생성
### 선요약

> - 선형 연산: 선형성이 존재하는 연산     
> 벡터 공간의 벡터의 합과 스칼라 곱셈 연산이 해당됨
> - 선형 결합(Linear combination): 선형 연산을 사용해 $n$개의 스칼라 $a_1, ..., a_n$과 $n$개의 벡터 $\vec{v_1}, ..., \vec{v_n}$를 결합해 새로운 벡터 $\vec{v'}$를 생성하는 수식
> 
> $$a_1\vec{v_1} + a_2\vec{v_2} + a_3\vec{v_3} + ... + a_n\vec{v_n} = \vec{v'}$$
> 
> - 선형 종속의 관계: 선형 결합에 사용된 벡터의 모든 $a$가 0이 아님에도 영벡터를 만들 수 있는 경우
> 
> $$2 \cdot (1, 1) + (-1) \cdot (2, 2) = (0, 0)$$
> 
> - 선형 독립의 관계: 선형 결합에 사용된 벡터들의 모든 $a$값이 0이어야 영벡터가 나오는 경우       
> 선형 독립의 관계를 가지는 벡터를 선형 결합하면 벡터 공간에 속한 모든 벡터를 생성할 수 있다
> 
> $$0 \cdot (1, 2) + 0 \cdot (2, 1) = (0, 0)$$
> 
> 평행한 두 벡터(선형 종속의 관계)를 결합한 결과는 두 개의 벡터 결합이 아닌 하나의 벡터에 스칼라 곱을 적용한 결과에 불과하기 때문에, 어떤 스칼라 값을 대입하더라도 선형 결합의 결과는 벡터와 평행한 벡터만 생성될 뿐이고 이와 평행하지 않은 벡터를 생성하는 것은 불가능하다
> 
> - 기저(Basis): 벡터 공간 내 모든 벡터를 생성할 수 있는 선형 독립 관계를 가지는 벡터의 집합
> - 기저벡터(Basis vector): 기저에 속한 원소
> - 차원(Dimension): 평면으로 구성된 벡터 공간을 생성하기 위한 기저는 수많은 경우의 수가 존재하지만, 기저 집합의 원소 수는 언제나 2개 뿐이다      
> 따라서 평면에 대응하는 벡터 공간을 2차원으로 정의할 수 있다
> - 2차원 실벡터 공간(Real vector space): 두 개의 실수 집합을 결합해 생성한 벡터 공간     수 집합의 기호와 차원의 정보를 첨자로 결합해 $R^2$로 나타낸다
> - 표준기저(Standard basis): 2차원을 구성하는 다양한 기저 중에서 한 축만 사용하는 단위 벡터 $(1, 0), (0, 1)$로 구성된 집합
> - 표준기저벡터(Standard basis vector): 기저의 각 원소
> 
> $$e_1 = (1, 0)$$
> 
> $$e_2 = (0, 1)$$

* * *

[본문](README-ORIGIN.md#5-벡터의-결합과-생성)

# 6. 삼각함수
### 선요약

> - 삼각비(Trigonometric Ratio): 직각삼각형을 구성하는 세 변에서 두 변을 뽑아 각각의 비례관계를 나타낸 것
> - 대표적인 삼각비: 사인(Sine), 코사인(Cosine), 탄젠트(Tangent)
> 
> 밑변의 길이=a, 높이의 길이=b, 빗변의 길이=c, 빗변과 밑변의 사잇각=$\theta$:
> 
> $$\sin \theta = \frac{b}{c}$$
> 
> $$\cos \theta = \frac{a}{c}$$
> 
> $$\tan \theta = \frac{b}{a}$$
> 
> - 삼각함수(Trigonometric function): 직각삼각형을 데카르트 좌표계 상에 배치하고 사잇각의 범위를 실수 전체($R$ 집합)로 확장한 대응 관계
> - 단위 원(Unit circle): 원점을 중심으로 반지름이 1인 원     
> 단위 원의 원주 위에 있는 임의의 점을 이어 직각삼각형을 그리면 빗변의 길이는 항상 1이다.      
> 빗변 $c$의 길이가 1이므로 삼각비 $\sin \theta$의 값은 높이 $b$와 같고 $\cos \theta$ 값은 밑변 $a$와 같다.       
> 
> $$\sin \theta = \frac{b}{1} = b$$
> 
> $$\cos \theta = \frac{a}{1} = a$$
> 
> 데카르트 좌표계에서 빗변이 가리키는 단위 원의 좌표는 $(\cos \theta, \sin \theta)$로 표현할 수 있다.     
> 이를 삼각함수로 확장하면 원주 위의 모든 좌표는 $(\cos \theta, \sin \theta)$에 대응한다.
> 
> 밑변 $a$의 $x$좌표는 $\cos \theta$가 되고 높이 $b$의 $y$좌표는 $\sin \theta$가 되는데 이를 피타고라스 정리 $a^2 + b^2 = c^2$에 대입하면 다음 공식을 얻을 수 있다.
> 
> $$\cos^2\theta + \sin^2\theta = 1$$
> 
> 반지름이 $r$인 원에서의 빗변은 벡터의 개념으로 보았을 때 길이가 1인 벡터와 평행하고 길이는 $r$배만큼 증가했으므로 스칼라 곱셈에 의해 $r \cdot (\cos \theta, \sin \theta)$라는 좌표를 갖게 된다.         
> 빗변의 길이가 $r$인 직각삼각형의 밑변의 길이는 $r \cdot \cos \theta$가 되고, 높이의 길이는 $r \cdot \sin \theta$가 된다.
> 
> 빗변과 삼각비의 관계를 나타내는 식은 반지름의 길이와 무관하게 성립한다.
> 
> $$r^2(\cos^2 \theta + \sin^2 \theta) = r^2$$
> 
> $$\therefore \cos^2 \theta + \sin^2 \theta = 1$$

* * *

[본문](README-ORIGIN.md#6-삼각함수)

# 6.1. 삼각함수의 성질
### 선요약

> - 데카르트 좌표계에서 각도: $x$축에서 원의 궤적을 따라 반시계 방향으로 회전한 크기
> - 각도 $0^\circ$: 단위 원에서 아직 회전하지 않아 $x$축 상에 위치한 빗변 $\vec{v}$의 좌표는 $(1, 0)$이다     
> 
> $$\vec{v} = (v_x, v_y) = (\cos 0^\circ, \sin 0^\circ) = (1, 0)$$
> 
> $$\therefore \sin 0^\circ = 0, \cos 0^\circ = 1$$
> 
> 각도를 $0^\circ$에서 $90^\circ$까지 서서히 증가시키면서 회전하는 빗변의 좌표 $v_x$와 $v_y$의 변화를 살펴보면 각도가 증가할수록 $v_x$값은 감소하고 $v_y$값은 증가한다.       
> 목적지인 $90^\circ$에 도달하면 $y$축 상에 위치한 좌표 $(0, 1)$과 일치하는 벡터가 만들어진다.
> 
> 각도가 $90^\circ$를 넘어서면 $v_x$값은 0을 지나 음수가 되고, $v_y$값은 다시 0을 향해 감소하기 시작한다.     
> 한바퀴에 해당하는 $360^\circ$까지 빗변의 좌표 변화를 관찰하면, -1에 도달할 때까지 계속 감소하다가 -1에 도달하면 방향을 바꿔서 1을 향해 증가하며, 1에 도달하면 다시 -1을 향해 감소하는 패턴을 반복한다.      
> 이러한 값의 변화는 $[-1, 1]$ 범위 내에서 $360^\circ$마다 반복된다.
> 
> - 진폭(Amplitude): 변화 값의 범위
> - 주기(Period): 반복되는 각도
> 
> $\cos$ 함수, $\sin$ 함수의 그래프로부터 정리한 함수의 성질:
> 1. $\sin$ 함수와 $\cos$ 함수는 항상 -1에서 1 사이를 일정하게 반복하는 패턴을 띈다.
> 2. $\sin$ 함수와 $\cos$ 함수의 값은 $360^\circ$ 주기로 반복된다.
> 3. $y$축을 기준으로 좌우를 접어 포갰을 때 $\cos$ 함수 그래프는 좌우 대칭인 반면, $\sin$ 함수 그래프는 상하가 반전된 원점 대칭의 형태를 띈다.        
> 
> - 우함수 또는 짝함수(Even function): $\cos$ 함수와 같이 좌우 대칭의 성질을 가진 함수
> - 기함수 또는 홀함수(Odd function): $\sin$ 함수와 같이 원점 대칭의 성질을 가진 함수
> 
> 홀함수와 짝함수의 성질:
> 
> $$\cos(-\theta) = \cos(\theta)$$
> 
> $$\sin(-\theta) = -\sin(\theta)$$
> 
> $\tan$ 함수는 빗변과 무관하게 밑변과 높이의 관계만을 나타낸다   
> 
> $$\tan \theta = \frac{b}{a}$$
> 
> 밑변과 높이를 모두 빗변 값으로 각각 나누면 $\cos$과 $\sin$으로 $\tan$ 함수를 표현할 수 있다
> 
> $$\tan \theta = \frac{\frac{b}{c}}{\frac{a}{c}} = \frac{\sin \theta}{\cos \theta}$$
> 
> 분모의 값은 0이 될 수 없기 때문에 분모에 해당하는 $\cos$ 함수 값이 0이 되는 $90^\circ, 270^\circ, -90^\circ, -270^\circ$에서는 $\tan$ 값이 존재하지 않는다      
> 때문에 $\tan$ 함수의 정의역에는 해당 구간이 포함되지 않는다     
> $\sin$ 함수와 동일하게 홀함수의 성질을 지닌다

* * *

[본문](README-ORIGIN.md#61-삼각함수의-성질)

# 6.2. 각의 측정법
### 선요약

> - 각도법(Degree): 일상 생활에서 각(Angle)의 크기를 잴 때 0에서 360까지의 수를 사용하는 방법       
> 각도법에서 기준으로 삼는 360이라는 수는 약수가 많아 원을 다양한 방법으로 쪼개어 활용할 수 있지만 일상생활에서의 편리를 위한 것일 뿐, 표준으로 사용하기에는 큰 수다
> - 호도법(Radian): 호의 길이를 기준으로 각을 측정하는 방법       
> 호도법은 호의 길이가 1이 되는 부채꼴의 각을 기준으로 각을 측정한다      
> $180^\circ$에 해당하는 반원의 호 길이는 파이($\pi$)이고 호의 길이가 1인 부채꼴의 중심각은 $180^\circ$를 $\pi$로 나누어 약 $57.2958^\circ$의 무리수가 된다        
> 이 부채꼴의 각이 호도법에서 사용하는 각의 기준인 $1rad$(라디안)이다
> 
> 반원의 중심각은 호 길이가 $\pi$이므로 라디안을 기준으로 $\pi$배만큼 크다        
> 따라서 각도법과 호도법 사이에는 다음의 대응 관계가 성립한다
> 
> $$\pi(rad) = 180^\circ$$
> 
> $$1^\circ = \frac{\pi}{180}(rad)$$
> 
> $$1(rad) = (\frac{180}{\pi})^\circ$$
> 
> 가장 흔히 사용하는 각의 각도와 호도:
> 
> |각도법|호도법|
> |---|---|
> |$30^\circ$|$\frac{\pi}{6}$|
> |$45^\circ$|$\frac{\pi}{4}$|
> |$60^\circ$|$\frac{\pi}{3}$|
> |$90^\circ$|$\frac{\pi}{2}$|
> |$180^\circ$|$\pi$|
> |$360^\circ$|$2\pi$|

* * *

[본문](README-ORIGIN.md#62-각의-측정법)

# 7. 삼각함수를 활용한 물체의 회전
### 선요약

> 물체를 이동시키고 크기를 늘리는 동작은 서로 수직인 $x$축과 $y$축이 서로 독립적으로 적용된다.        
> 따라서 $x$축과 $y$축을 분리해 따로따로 계산한 후 두 결과를 결합한 것과 동일하다.
> 
> 회전이라는 동작은 $x$와 $y$값이 함께 영향을 미치기 때문에 $x$축과 $y$축을 독립적으로 계산할 수 없다.        
> 회전을 위해 실벡터 공간 $R^2$ 전체를 각 $\theta$만큼 회전시키면, 두 표준기저벡터 $e_1$과 $e_2$의 좌표는 다음과 같이 변화한다.
> 
> $$e_1' = (\cos \theta, \sin \theta)$$
> 
> $$e_2' = (-\sin \theta, \cos \theta)$$
> 
> 좌표 $(1, 1)$의 값을 가진 벡터 $\vec{v}$를 각 $\theta$만큼 회전한 벡터 $\vec{v'}$는 다음과 같이 회전된 표준기저벡터 $e_1'$과 $e_2'$를 선형 결합하여 얻을 수 있다.       
> 
> $$\vec{v'} = 1 \cdot (\cos \theta, \sin \theta) + 1 \cdot (-\sin \theta, \cos \theta)$$
> 
> 따라서 좌표 $(1, 1)$이 각 $\theta$만큼 회전한 벡터 $\vec{v'}$의 좌표는 다음과 같다.
> 
> $$\vec{v'} = (\cos \theta - \sin \theta, \sin \theta + \cos \theta)$$
> 
> 임의의 벡터 $\vec{u} = (x, y)$에 대해 각 $\theta$만큼 회전한 벡터 $\vec{u'} = (x', y')$을 구할 수 있는 일반적인 수식은 다음과 같이 정리된다.
> 
> $$\vec{u} = (x, y) = x \cdot e_1 + y \cdot e_2 = x \cdot (1, 0) + y \cdot (0, 1)$$
> 
> $$\vec{u'} = (x', y') = x \cdot (\cos \theta, \sin \theta) + y \cdot (-\sin \theta, \cos \theta) \\
> = (x \cos \theta - y \sin \theta, x \sin \theta + y \cos \theta)$$
> 
> 임의의 벡터 $(x, y)$가 각 $\theta$만큼 회전된 결과 $(x', y')$는 다음과 같다.
> 
> $$x' = x \cos \theta - y \sin \theta$$
> 
> $$y' = x \sin \theta + y \cos \theta$$

* * *

[본문](README-ORIGIN.md#7-삼각함수를-활용한-물체의-회전)

# 8. 삼각함수의 역함수
### 선요약

> 주어진 벡터의 좌표로부터 이에 대응하는 각도를 얻어내기 위해선 삼각함수의 역함수에 대해 알아야 한다.     
> $\sin$ 함수가 가진 $x$와 $y$ 사이의 대응 관계를 살펴보면 정의역의 여러 요소가 공역의 한 요소에 대응된다.        
> 만일 공역의 범위를 실수 집합 전체가 아닌 $|-1, 1|$ 구간으로 한정해 정의하면, $\sin$ 함수는 전사함수의 성질을 띤다.      
> 여기서 정의역의 범위를 $|-90^\circ, 90^\circ|$로 좁혀 정의역의 한 요소가 공역의 한 요소에 대응되는 전단사함수의 성질을 띠게 만든다.     
> $\sin$ 함수의 정의역과 공역의 범위를 좁혀 전단사함수로 만들면, $\sin x$값이 주어졌을 때 거꾸로 각 $x$를 구할 수 있는 역함수가 존재하게 된다.        
> 
> $\sin$ 함수와 동일하게 $\cos$ 함수의 정의역을 $|0^\circ, 180^\circ|$, 공역을 $|-1, 1|$로 좁혀 전단사함수로 만들고 역함수를 구할 수 있다.
> 
> $\tan$ 함수의 치역은 실수 영역 전체인데 반해, 정의역이 존재하지 않는 구간이 존재한다.       
> 따라서 $\tan$ 함수의 정의역 구간을 제한해서 한정해야 한다.      
> $\tan$ 함수는 $x$값이 $-90^\circ$와 $90^\circ$일 때의 $y$값이 존재하지 않으므로 전단사함수가 되기 위한 정의역 구간은 $-90^\circ$와 $90^\circ$ 값을 제외한 $(-90^\circ, 90^\circ)$ 범위가 되어야 한다.
> 
> - $\arcsin$(아크사인): 정의역과 공역의 범위를 제한시켜 얻은 $\sin$ 함수의 역함수
> - $\arccos$(아크코사인): 정의역과 공역의 범위를 제한시켜 얻은 $\cos$ 함수의 역함수
> - $\arctan$(아크탄젠트): 정의역 범위를 제한시켜 얻은 $\tan$ 함수의 역함수
> 
> $\arctan$ 함수는 벡터의 각도를 구하는 데 유용하게 사용된다.     
> 임의의 벡터를 $\vec{v} = (x, y)$라고 할 때 분수식 $\frac{y}{x}$를 계산해 벡터로부터 $\tan$ 함수 값을 얻을 수 있다.      
> 이 $\tan$ 값을 $\arctan$ 함수에 넣으면 해당 벡터가 $x$축과 이루는 사잇각을 얻어낼 수 있다.
> 
> $\arctan$ 함수의 치역은 $(-90^\circ, 90^\circ)$ 구간이므로 $\arctan$ 함수로 얻을 수 있는 각의 범위에는 한계가 있다.     
> 하지만 인자에 분수 $\frac{y}{x}$ 값을 넣지 않고 $x$와 $y$의 두 값을 분리해 전달하면 4분면 전체에 해당하는 각의 정보를 얻을 수 있다.
> 
> $x$와 $y$를 따로 전달하는 $\arctan$ 함수를 $atan2$ 함수라고 부르며, 이는 분수 $\frac{y}{x}$를 연상하기 쉽게 $y$값에 이어 $x$값을 전달하도록 설계된다.       
> $atan2$를 사용하면 평면의 모든 사분면에 대응하는 각도를 얻을 수 있다.

* * *

[본문](README-ORIGIN.md#8-삼각함수의-역함수)

# 9. 극좌표계
### 선요약

> 데카르트 좌표계로 회전을 구현하면 회전에 따른 $x$와 $y$의 변화를 매번 계산하는 번거로움이 발생한다.     
> 
> - 극좌표계(Polar coordinate system): 편리하게 회전을 관리하고 구현하기 위해 회전 동작을 기반으로 설계된 좌표계다.    
> 극좌표계는 원점으로부터의 거리 $r$과 각 $\theta$의 두 요소로 구성되며 극좌표계의 좌표는 $(r, \theta)$로 표시한다.
> 
> 데카르트 좌표계로 표현된 벡터 $(x, y)$는 벡터의 크기와 $\arctan$ 함수를 사용해 다음과 같이 극좌표계 $(r, \theta)$로 변환할 수 있다.
> 
> $$r = \sqrt{x^2 + y^2}$$
> 
> $$\theta = atan2(y, x)$$
> 
> 반대로 극좌표계의 좌표 $(r, \theta)$를 데카르트 좌표계 $(x, y)$로 변환하는 식은 삼각함수를 사용해 구한다.
> 
> $$x = r \cdot \cos \theta$$
> 
> $$y = r \cdot \sin \theta$$
> 
> 극좌표계가 지니는 원형 공간의 성질은 회전에 관련된 여러 효과를 줄 때 유용하게 사용된다.     
> 예를 들어 게임에서 사용되는 스킬 아이콘의 쿨타임 효과가 대표적이다.

* * *

[본문](README-ORIGIN.md#9-극좌표계)

# 10. 선형성: 예측 가능한 비례 관계
### 선요약

> - 선형성(Linerity): 직선의 형태를 띠는 성질, 가법성과 1차 동차성 두 가지 조건을 모두 만족하는 함수의 성질을 의미한다.
> - 가법성(Additivity): $f(x_1 + x_2) = f(x_1) + f(x_2)$
> - 1차 동차성(Homogeneity of degree 1): $f(k \cdot x) = k \cdot f(x)$

* * *

[본문](README-ORIGIN.md#10-선형성-예측-가능한-비례-관계)

# 10.1. 선형 함수
### 선요약

> 입력에 사용하는 요소 $x$와 출력이 모두 실수면서 선형성을 지니는 함수의 예시:
> 
> $$f(x) = ax$$
> 
> 가법성을 만족하는 수식 $f(x_1 + x_2) = f(x_1) + f(x_2)$에 대입했을 때 $a, x_1, x_2$가 모두 체의 성질을 가지는 실수라면 분배법칙에 의해 $a(x_1 + x_2) = ax_1 + ax_2$가 성립한다.     
> 따라서 함수 $f(x) = ax$는 가법성을 만족한다.
> 
> 1차 동차성을 만족하는 수식 $f(k \cdot x) = k \cdot f(x)$에 대입했을 때 $a, x, k$가 모두 체의 성질을 가지는 실수라면 곱셈에 대한 결합법칙과 교환법칙이 성립하므로, $a(kx) = k(ax)$가 성립한다.       
> 따라서 함수 $f(x) = ax$는 1차 동차성을 만족한다.
> 
> $y = x^2$와 $y = ax + b$는 선형성을 만족하지 못한다.     
> 선형성이란 단지 곧게 뻗은 직선의 성질을 뜻하는 것이 아니라, 두 집합의 순수한 비(Ratio)로 구성된 1차적 대응 관계를 의미한다.     

* * *

[본문](README-ORIGIN.md#101-선형-함수)

# 10.2. 벡터 공간의 선형 변환
### 선요약

> 2차원 벡터를 입력받고 2차원 벡터를 출력하는 함수에서 선형성을 가지는 함수를 설계하기 위해선 입력에 사용한 2차원 벡터가 $(x, y)$로 구성된 경우, $x$와 $y$는 서로 독립된 관계를 형성해야 한다.        
> 선형성을 가지는 함수는 순수한 비의 형태로 구성되어 있기 때문에 $x$와 $y$는 각각에 대해 선형성을 유지하기 위해 $ax$와 $by$ 같은 단순 비의 형태를 사용하고, 이를 섞은 최종 결과는 각 비의 결과를 더한 $ax + by$의 형태가 된다.        
> 따라서 2차원 벡터를 입출력으로 사용하는 선형성을 가지는 함수는 다음과 같이 설계된다.
> 
> $$f(\vec{v}) = f(x, y) = (ax + by, cx + dy)$$
> 
> 위 함수는 가법성과 1차 동차성을 모두 만족하므로 선형 함수다.
> 
> - 변환(Transformation): 두 공간이 동일한 구조를 지닐 때 두 공간의 대응 관계     
> 예를 들어 표준기저벡터의 선형 결합으로 형성된 벡터 공간은 선형성을 지니고 이 벡터 공간을 선형 함수로 변화시킨 새로운 공간도 기저벡터의 선형 결합으로 형성되므로 선형성을 지닌다
> - 선형 변환(Linear transformation): 선형성을 유지시켜주는 선형 함수
> 예를 들어 $f(x, y) = (ax + by, cx + dy)$
> 
> 임의의 벡터 $\vec{v}$의 크기를 $k$배 늘리는 작업은 다음과 같이 스칼라 곱셈으로 표현이 가능하다.
> 
> $$f(\vec{v}) = f(x, y) = (kx, ky)$$
> 
> 이는 $(ax + by, cx + dy)$의 형식에 $a = k, b = 0, c = 0, d = k$를 대입한 결과와 동일하므로 선형 변환이다.
> 
> 임의의 벡터 $\vec{v}$를 각 $\theta$만큼 회전시키는 작업은 다음과 같은 함수로 표현이 가능하다.
> 
> $$f(\vec{v}) = f(x, y) = (\cos \theta x - \sin \theta y, \sin \theta x + \cos \theta y)$$
> 
> 이는 $(ax + by, cx + dy)$의 형식에 $a = \cos \theta, b = -\sin \theta, c = \sin \theta, d = \cos \theta$를 대입한 결과와 동일하므로 선형 변환이다.
> 
> 벡터 공간에서의 선형 변환은 단순한 비례 관계로 구성된 선형 함수 $f(x) = ax$처럼 두 집합의 순수한 비를 통해 예측할 수 있는 형태로 변환되며, 역함수를 통해 변환 후의 벡터로부터 변환 전의 벡터를 파악할 수 있다.

* * *

[본문](README-ORIGIN.md#102-벡터-공간의-선형-변환)

# 11. 행렬
### 선요약

> - 행렬(Matrix): 수를 사각형의 형태로 행과 열을 맞춰 배열한 테이블       
> n개의 행과 m개의 열로 구성된 반듯한 사각형의 형태를 띤다        
> 선형 변환과 벡터를 나타내는 데 사용된다
> - 벡터를 행렬로 표현: 한 줄로 구성된 행렬로 표현        
> 가로와 세로 두 가지 표현 방식이 존재하며 $(x, y)$로 구성된 2차원의 벡터는 $A$(열벡터) 혹은 $B$(열벡터) 행렬로 표기할 수 있다
> 
> $$
A = 
\begin{bmatrix}
x \\
y \\
\end{bmatrix}$$
> 
> $$
B = 
\begin{bmatrix}
x & y \\
\end{bmatrix}$$
> 
> - 정방행렬(Square matrix): 행과 열이 크기가 같은 행렬       
> 선형 변환을 표현할 때 사용      
> 2차원 벡터 공간의 선형 변환 $f(x, y) = (ax + by, cx + dy)$는 다음과 같은 $2 \times 2$ 크기의 정방행렬로 표현한다      
> 정방행렬 $A$는 2개의 행벡터 또는 2개의 열벡터로 구성된다고 할 수 있다
> 
> $$
A = 
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix}$$
> 

* * *

[본문](README-ORIGIN.md#11-행렬)

# 11.1. 행렬의 기본 연산
### 선요약

> 행렬의 주요 연산 4가지:
> - 행렬과 행렬의 덧셈
> - 행렬과 스칼라의 곱셈
> - 행렬의 전치(Transpose of a matrix)
> - 행렬과 행렬의 곱셈 (행렬 곱)
> 
> 행렬과 행렬의 덧셈: 행렬의 크기가 같은 경우에만 성립되며, 같은 위치의 원소끼리 더한다
> 
> $$
A + B = 
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix} + 
\begin{bmatrix}
e & f \\
g & h \\
\end{bmatrix} = 
\begin{bmatrix}
a + e & b + f \\
c + g & d + h \\
\end{bmatrix}$$
> 
> 행렬과 스칼라의 곱셈: 행렬을 구성하는 모든 원소에 스칼라를 곱한다
> 
> $$
k \cdot A = k \cdot 
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix} =
\begin{bmatrix}
k \cdot a & k \cdot b \\
k \cdot c & k \cdot d \\
\end{bmatrix}$$
> 
> 행렬의 전치: 첨자 $T$로 표시하며, 행과 열을 바꾸는 작업을 수행한다      
> 예를 들어 $3 \times 2$ 행렬의 전치연산은 $2 \times 3$ 행렬이 된다       
> 정방행렬의 전치연산은 행과 열의 정보가 동일한 대각 성분의 원소는 그대로 유지되고, 나머지 원소는 대각성분을 중심으로 대칭된 행렬을 만든다
> 
> $$
\begin{bmatrix}
a & d \\
b & e \\
c & f \\
\end{bmatrix}^T = 
\begin{bmatrix}
a & b & c \\
d & e & f \\
\end{bmatrix}$$
> 
> $$
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix}^T =
\begin{bmatrix}
a & c \\
b & d \\
\end{bmatrix}$$
>

* * *

[본문](README-ORIGIN.md#111-행렬의-기본-연산)

# 11.2. 행렬의 곱셈
### 선요약

> 행렬의 곱셈: 앞에 위치한 행렬의 행벡터와 뒤에 위치한 행렬의 열벡터를 각각 곱하는 방식으로 진행      
> 
> $$
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix} \cdot
\begin{bmatrix}
e & f \\
g & h \\
\end{bmatrix} =
\begin{bmatrix}
ae + bg & af + bh \\
ce + dg & cf + dh \\
\end{bmatrix}$$
> 
> 행렬 곱셈의 연산 법칙 성립 여부:
> 
> |법칙|성립|
> |---|---|
> |교환법칙|X|
> |결합법칙|O|
> 
> 행렬 곱을 전치한 결과는 순서를 바꾼 후 각각 전치해 곱한 결과와 동일하다
> 
> $$(A \cdot B)^T = 
\begin{bmatrix}
ae + bg & af + bh \\
ce + dg & cf + dh \\
\end{bmatrix}^T = 
\begin{bmatrix}
ae + bg & ce + dg \\
af + bh & cf + dh \\
\end{bmatrix}$$
> 
> $$B^T \cdot A^T = 
\begin{bmatrix}
e & g \\
f & h \\
\end{bmatrix} \cdot
\begin{bmatrix}
a & c \\
b & d \\
\end{bmatrix} =
\begin{bmatrix}
ea + gb & ec + gd \\
fa + hb & fc + hd \\
\end{bmatrix}$$
> 
> $$\therefore (A \cdot B)^T = B^T \cdot A^T$$
> 
> $a, b, c, d$ 네 개의 원소로 구성된 $2 \times 2$ 정방행렬과 2차원 벡터 $(x, y)$를 열벡터로 설정한 두 행렬의 곱은 다음과 같이 전개된다        
> 행렬 곱의 결과는 2차원 벡터 공간의 선형 변환 $f(x, y) = (ax + by, cx + dy)$와 동일하다      
> 따라서 $2 \times 2$ 정방행렬 $A$는 2차원 공간의 선형 변환에 대응되는 함수를 의미하고, 이 수식은 $f(x, y) = (ax + by, cx + dy)$ 2차원 벡터에 선형 변환을 적용해 새로운 벡터를 생성하는 작업으로 해석할 수 있다       
> 벡터에 선형 변환을 적용하기 위한 연산 순서는 오른쪽에서 왼쪽 방향으로 이뤄진다
> 
> $$
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix} \cdot 
\begin{bmatrix}
x \\
y \\
\end{bmatrix} = 
\begin{bmatrix}
ax + by \\
cx + dy \\
\end{bmatrix}$$
> 

* * *

[본문](README-ORIGIN.md#112-행렬의-곱셈)

# 11.3. 정방행렬의 곱셈
### 선요약

> $2 \times 2$ 정방행렬이 2차원 벡터 공간의 선형 변환에 대응된다면, $2 \times 2$ 정방행렬 간의 곱은 합성함수에 대응되는 연산이다
> 
> 합성함수는 결합법칙을 만족하고, 합성함수에 대응하는 행렬의 곱셈 역시 결합법칙을 만족한다        
> 따라서 행렬의 연산 순서를 바꿔도 최종 계산된 벡터 $\vec{w}$ 값은 동일하다
> 
> 이처럼 결합법칙이 성립하는 행렬 곱의 성질은 컴퓨터 그래픽 연산에서 아주 유용하게 활용된다       
> 예를 들어 100개의 점으로 구성된 물체가 모니터에 표현되기까지 5번의 선형 변환이 발생한다는 가정하면 각 점마다 5번의 행렬 곱이 수행되므로 100개 점에 대한 행렬 곱의 총 횟수는 500이 된다
> 
> 결합법칙이 성립하는 행렬 연산의 특징을 사용하면 계산량을 줄이되 동일한 결과를 얻을 수 있다      
> 행렬 곱을 4번 수행해서 합성함수에 해당하는 행렬 $F$를 미리 만들어 각 점에 대해 미리 계산된 행렬 $F$만 곱하면 동일한 결과가 나온다       
> 이 경우 100개 점에 대한 행렬 곱의 총 횟수는 최초 합성 변환을 만들기 위한 4번의 행렬 곱과 벡터마다 1번의 행렬 곱이 수행되므로 104가 된다     
> 
> 이 결과는 앞서 구한 500번의 행렬 곱 연산과 동일하다     
> 가상 공간의 한 캐릭터를 표현하는 데 보통 10만 개의 점이 사용되므로, 컴퓨터 그래픽에서 행렬은 가상 세계를 구축하는 데 필요한 계산량을 크게 줄여주는 중요한 역할을 수행한다는 걸 알 수 있다

* * *

[본문](README-ORIGIN.md#113-정방행렬의-곱셈)

# 12. 행렬의 설계
### 선요약

> $2 \times 2$ 정방행렬=2차원 벡터 공간의 선형 변환       
> 
> 원 벡터 공간 $V$의 벡터 $\vec{v} = (x, y)$는 다음과 같은 표준기저벡터의 선형 결합을 통해 생성된다
> 
> $$\vec{v} = (x, y) = x \cdot (1, 0) + y \cdot (0, 1)$$
> 
> 같은 방법으로 벡터 $\vec{v}$가 선형 변환되는 경우에는 동일한 선형 결합식을 사용해 벡터 $\vec{w}$는 다음과 같이 계산된다
> 
> $$\vec{w} = x(a, c) + y(b, d) = (ax + by, cx + dy)$$
> 
> 이는 $a, b, c, d$로 만들어진 정방행렬에 벡터 $(x, y)$를 곱한 결과와 동일하다
> 
> $$
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix} \cdot 
\begin{bmatrix}
x \\
y \\
\end{bmatrix} =
\begin{bmatrix}
ax + by \\
cx + dy \\
\end{bmatrix}$$
> 
> 위의 정방행렬과 표준기저벡터가 변화된 두 벡터 $(a, c)$와 $(b, d)$와의 관계를 분석하면 이들은 정방행렬을 구성하는 열벡터로 해석할 수 있다

* * *

[본문](README-ORIGIN.md#12-행렬의-설계)

# 12.1. 크기 변환행렬
### 선요약

> - 크기 변환: 각 표준기저벡터를 동일한 방향으로 지정한 크기만큼 늘리는 변환
> - 크기 변환행렬(Scale transformation matrix): 물체의 크기를 변경하는 행렬
> - 표준기저벡터 $e_1$을 $a$배만큼 늘리거나 줄인 벡터: $a \cdot (1, 0) = (a, 0)$
> - 표준기저벡터 $e_2$를 $b$배만큼 늘리거나 줄인 벡터: $b \cdot (0, 1) = (0, b)$
> 
> 변환된 두 표준기저벡터 $(a, 0)$과 $(0, b)$를 열벡터로 설정해 생성한 크기 변환행렬:
> 
> $$S = 
\begin{bmatrix}
a & 0 \\
0 & b \\
\end{bmatrix}$$
>

* * *

[본문](README-ORIGIN.md#121-크기-변환행렬)

# 12.2. 회전 변환행렬
### 선요약

> - 회전 변환행렬(Rotation transformation matrix): 주어진 각 $\theta$로 벡터 공간을 회전시키는 행렬
> - 표준기저벡터 $e_1$을 $90^\circ$ 회전한 벡터: $(0, 1)$
> - 표준기저벡터 $e_2$를 $90^\circ$ 회전한 벡터: $(-1, 0)$
> 
> $90^\circ$ 회전 변환을 수행하는 행렬:
> 
> $$R_{90^\circ} = R_\frac{\pi}{2} = 
\begin{bmatrix}
0 & -1 \\
1 & 0 \\
\end{bmatrix}$$
> 
> - 표준기저벡터 $e_1$을 $-90^\circ$ 회전한 벡터: $(0, -1)$
> - 표준기저벡터 $e_2$을 $-90^\circ$ 회전한 벡터: $(1, 0)$
> 
> $-90^\circ$ 회전 변환을 수행하는 행렬:
> 
> $$R_{90^\circ} = R_{-\frac{\pi}{2}} = 
\begin{bmatrix}
0 & 1 \\
-1 & 0 \\
\end{bmatrix}$$
> 
> - 표준기저벡터 $e_1$을 $\theta$만큼 회전한 벡터: $(\cos \theta, \sin \theta)$
> - 표준기저벡터 $e_2$를 $\theta$만큼 회전한 벡터: $(-\sin \theta, \cos \theta)$
> 
> 각 $\theta$에 대한 회전 변환행렬:
> 
> $$R_\theta =
\begin{bmatrix}
\cos \theta & -\sin \theta \\
\sin \theta & \cos \theta \\
\end{bmatrix}$$
>

* * *

[본문](README-ORIGIN.md#122-회전-변환행렬)

# 12.3. 전단 변환행렬
### 선요약

> - 전단 변환행렬(Shear transformation matrix): 표준기저벡터 $e_1$을 고정한 상태에서 표준기저벡터 $e_2$를 $x$축 방향으로 미는 변환처럼 대각선으로 밀리는 형태의 변환 행렬
> - 표준기저벡터 $e_1$의 변환 결과: $(1, 0)$ (변화 없음)
> - 표준기저벡터 $e_2$의 변환 결과: $(1, 1)$
> 
> 표준기저벡터 $e_2$를 $x$축 방향으로 1만큼 밀어내는 전단 변환행렬:
> 
> $$S = 
\begin{bmatrix}
1 & 1 \\
0 & 1 \\
\end{bmatrix}$$
> 
> 전단 변환에서 미는 크기는 1행 2열에 위치한 원소 값을 변경해 조절이 가능하다     
> $x$축 방향으로 $a$만큼 민다면 각 표준기저벡터 $e_1$과 $e_2$는 다음과 같이 변환된다
> - 표준기저벡터 $e_1$의 변환 결과: $(1, 0)$ (변화 없음)
> - 표준기저벡터 $e_2$의 변환 결과: $(a, 1)$
> 
> $x$축 방향으로 $a$만큼 미는 전단 변환행렬:
> 
> $$S = 
\begin{bmatrix}
1 & a \\
0 & 1 \\
\end{bmatrix}$$
>

* * *

[본문](README-ORIGIN.md#123-전단-변환행렬)

# 12.4. 삼각함수의 덧셈 정리
### 선요약

> 삼각함수를 응용할 때 유용하게 사용되는 삼각함수의 덧셈:
> - $\cos(\alpha + \beta) = \cos \alpha \cos \beta - \sin \alpha \sin \beta$
> - $\sin(\alpha + \beta) = \sin \alpha \cos \beta + \cos \alpha \sin \beta$
> 
> 회전행렬의 원리를 사용해 덧셈 정리를 유도할 수 있다     
> 회전 변환에 사용하는 두 각 $\alpha$와 $\beta$가 있을 때, 이 둘을 합한 $\alpha + \beta$ 만큼 회전한 변환은 두 각에 대한 회전 변환을 순서대로 적용한 결과와 동일하다      
> 각 $\alpha$에 대한 회전 변환행렬과 각 $\beta$에 대한 회전 변환행렬을 행렬 곱하면 삼각함수의 덧셈 정리를 얻을 수 있다
> 
> 삼각함수의 배각 공식: 삼각함수의 덧셈 정리를 응용한 삼각함수의 배각 공식은 각 $\beta$ 대신 $\alpha$를 대입해 얻을 수 있다
> - $\cos 2 \alpha = \cos(\alpha + \alpha)$       
> $\qquad = \cos^2\alpha - \sin^2\alpha$      
> $\qquad = 1 - 2\sin^2\alpha$
> - $\sin 2 \alpha = \sin(\alpha + \alpha)$     
> $\qquad = 2 \sin \alpha \cos \alpha$

* * *

[본문](README-ORIGIN.md#124-삼각함수의-덧셈-정리)

# 13. 역행렬
### 선요약

> - 항등행렬(Indentity matrix): 항등행렬은 원 공간의 변화없이 동일한 공간으로 유지하는 변환을 의미      
> 항등행렬은 $I$로 표기한다       
> 
> $$I = 
\begin{bmatrix}
1 & 0 \\
0 & 1 \\
\end{bmatrix}$$
> 
> - 역행렬(Inverse matrix): 행렬 곱의 결과가 항등행렬이 나오는 특별한 행렬   
> 벡터 공간 $V$가 선형 변환된 벡터 공간 $W$에서 원 벡터 공간 $V$로 되돌리는 선형 변환이라고 해석할 수 있다            
> 역함수와 동일하게 위 첨자 $^{-1}$을 사용해 표시하며 임의의 행렬을 $A$라고 했을 때  다음의 수식이 성립한다      
> 
> $$A \cdot A^{-1} = A^{-1} \cdot A = I$$

* * *

[본문](README-ORIGIN.md#13-역행렬)

# 13.1. 역행렬의 존재를 판별하는 행렬식
### 선요약

> - 어떤 함수가 역함수를 갖기 위한 조건: 전단사함수여야한다       
> 행렬도 함수이므로 두 공간의 변환이 전단사로 대응될 때만 역행렬이 존재함
> - 행렬식(Determination): 어떤 행렬에 대해 역행렬이 존재하는지 파악할 수 있는 특별한 수식        
> 행렬식은 $det()$의 기호로 표시하며, 일반적인 $2 \times 2$ 정방행렬 $A$의 행렬식은 다음과 같이 계산한다      
> 
> $$A = 
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix}$$
> 
> $$det(A) = ad - bc$$
> 
> 행렬식 $det(A)$의 값이 0인 선형 변환은 전단사 대응이 성립하지 않아 역행렬이 존재하지 않는다     
> 행렬식의 값이 0인 경우, 공간적으로 행렬 $A$의 두 기저벡터의 기울기가 같아지며 2차원의 평면 영역이 1차원의 직선 영역으로 압축됐다고 볼 수 있다(두 기저벡터가 선형종속이다)
> 
> 차원이 줄어들어 원 공간의 정보가 소멸되면, 거꾸로 벡터 공간 $W$에서 벡터 공간 $V$로 변환되는 것은 불가능하다        
> 따라서 역행렬이 존재할 수 없다
> 
> 행렬식 값이 음수가 나오는 경우 평면이 뒤집혔다고 해석할 수 있다

* * *

[본문](README-ORIGIN.md#131-역행렬의-존재를-판별하는-행렬식)

# 13.2. 크기 변환행렬의 역행렬
### 선요약

> - 크기 변환행렬의 역행렬: 변화된 크기만큼 거꾸로 크기를 변화시키는 방법으로 구할 수 있다        
> 크기 변환에 사용한 두 원소의 역수를 사용해 크기 변환을 설계하면 변환된 두 기저벡터는 다시 표준기저벡터로 돌아온다
> 
> 원 공간에서 $x$축을 $a$배, $y$축을 $b$배만큼 크기를 변화시킨 크기 변환행렬 $S$의 역행렬 $S^{-1}$는 다음과 같이 $a$와 $b$의 역수를 대입해 구할 수 있다
> 
> $$S^{-1} = 
\begin{bmatrix}
\frac{1}{a} & 0 \\
0 & \frac{1}{b} \\
\end{bmatrix}$$
>

* * *

[본문](README-ORIGIN.md#132-크기-변환행렬의-역행렬)

# 13.3. 전단 변환행렬의 역행렬
### 선요약

> - 전단 변환행렬의 역행렬: 표준기저벡터 $e_1$을 고정한 상태에서 민 방향의 반대 방향으로 밀면 밀린 공간은 원래대로 돌아온다       
> 
> 원 공간에서 $x$축으로 $a$만큼 민 전단 변환행렬 $S$의 역행렬 $S^{-1}$는 $a$의 반대수를 대입해 다음과 같이 구한다
> 
> $$S^{-1} = 
\begin{bmatrix}
1 & -a \\
0 & 1 \\
\end{bmatrix}$$
>

* * *

[본문](README-ORIGIN.md#133-전단-변환행렬의-역행렬)

# 13.4. 회전 변환행렬의 역행렬
### 선요약

> - 회전 변환행렬의 역행렬: 회전각 $\theta$에 대한 회전 변환행렬의 역행렬은 반대방향의 회전각 $-\theta$에 대한 회전 변환을 의미한다
> 
> $$R_{\theta}^{-1} = R_{(-\theta)}$$
> 
> $\sin$ 함수와 $\cos$ 함수의 성질:
> 
> $$\cos(-\theta) = \cos(\theta)$$
> 
> $$\sin(-\theta) = -\sin(\theta)$$
> 
> 이를 활용하면 회전행렬의 역행렬은 다음과 같이 정리할 수 있다
> 
> $$R_{\theta}^{-1} = R_{(-\theta)} = 
\begin{bmatrix}
\cos \theta & \sin \theta \\
-\sin \theta & \cos \theta \\
\end{bmatrix}$$
> 
> 역행렬에서 부호가 변하지 않는 $\cos$ 함수는 대각선 영역에만 위치하므로 회전행렬과 이것의 역행렬은 서로 전치 관게에 있다
> 
> $$R_\theta = 
\begin{bmatrix}
\cos \theta & -\sin \theta \\
\sin \theta & \cos \theta \\
\end{bmatrix}$$
> 
> $$R_{\theta}^{-1} = 
\begin{bmatrix}
\cos \theta & \sin \theta \\
-\sin \theta & \cos \theta \\
\end{bmatrix}$$
> 
> 따라서 회전행렬의 역행렬은 별도로 삼각함수를 사용하지 않아도 기존 행렬에 전치연산을 적용하는 방법으로 쉽게 구할 수 있다
> 
> $$R_\theta^{-1} = R_\theta^T$$

* * *

[본문](README-ORIGIN.md#134-회전-변환행렬의-역행렬)

# 13.5. 행렬 곱의 역행렬
### 선요약

> 합성함수에 해당하는 두 행렬 곱의 역행렬은 다음의 수식이 성립한다
> 
> $$(A \cdot B)^{-1} = B^{-1} \cdot A^{-1}$$

* * *

[본문](README-ORIGIN.md#135-행렬-곱의-역행렬)

# 14. 이동 변환을 위한 아핀 공간
### 선요약

> - 이동 선형 변환: $2 \times 2$ 정방 행렬의 곱셈으로는 2차원 평면에서의 이동을 구현할 수 없다        
> 임의의 벡터 $(x, y)$를 지정한 크기 $(a, b)$만큼 이동시키는 기능은 행렬의 덧셈으로 구할 수 있다
> 
> $$
\begin{bmatrix}
x \\
y \\
\end{bmatrix} + 
\begin{bmatrix}
a \\
b \\
\end{bmatrix} =
\begin{bmatrix}
x + a \\
y + b \\
\end{bmatrix}$$
> 
> 하지만 다음의 행렬 곱을 만족하는 정방행렬 $A$는 존재하지 않는다
> 
> $$A \cdot 
\begin{bmatrix}
x \\
y \\
\end{bmatrix} =
\begin{bmatrix}
x + a \\
y + b \\
\end{bmatrix}$$
> 
> 표준기저벡터의 원점을 이동시키는 변환이 행렬이 되기 위해서는 선형성을 만족해야 하는데, 선형성이 되기 위해서는 기저벡터는 원점에서부터 출발해야 한다는 조건을 만족해야 한다
> 
> 공간의 차원을 하나 더 늘린다면 이를 구현하는 것이 가능하다      
> 물체를 표현하는데 두 개의 차원을 사용하고, 차원 하나를 더 추가해 선형 변환을 위한 원점과의 연결고리로 활용한다면 선형 변환의 형태로 이동을 구현할 수 있다
> 
> 2차원 이동 변환을 구현하기 위해 차원을 한 개 늘리고 마지막 차원 $z$의 값을 1로 조건을 고정한 전단 변환을 설계하면 다음과 같다
> 
> $$
\begin{bmatrix}
1 & 0 & a \\
0 & 1 & b \\
0 & 0 & 1 \\
\end{bmatrix} \cdot 
\begin{bmatrix}
x \\
y \\
1 \\
\end{bmatrix} =
\begin{bmatrix}
x + a \\
y + b \\
1 \\
\end{bmatrix}$$
> 
> 이는 $z = 1$의 조건에서 임의의 벡터 $(x, y)$를 지정한 크기 $(a, b)$만큼 이동시키는 2차원의 이동 변환을 만든다
> 
> - 이동 변환행렬(Translate transformation matrix): 마지막 차원의 값이 1이라는 특정 조건을 가지는 전단 변환을 활용한 이동 기능 행렬
> 
> $$T = 
\begin{bmatrix}
1 & 0 & a \\
0 & 1 & b \\
0 & 0 & 1 \\
\end{bmatrix}$$
> 
> - 아핀 공간(Affine space): 벡터 공간에서 이동을 위해 마지막 차원 값을 1로 한정한 부분 공간
> - 아핀 변환(Affine transformation): 행렬 곱의 장점을 살리기 위해 한 차원을 높여 설계한 선형 변환        
> 
> 임의의 벡터 $(x, y, 1)$과 아핀 변환행렬의 결과는 아핀 공간에 닫혀 있다

* * *

[본문](README-ORIGIN.md#14-이동-변환을-위한-아핀-공간)

# 15. 아핀 공간의 구성 요소
### 선요약

> 이동 기능을 아핀 변환으로 구현해야 하는 이유: 행렬 곱의 장점을 활용하기 위해서
> 
> 아핀 공간에 속한 물체의 마지막 차원 값은 언제나 1이 되어야 한다

* * *

[본문](README-ORIGIN.md#15-아핀-공간의-구성-요소)

# 15.1. 점
### 선요약

> - 아핀 공간의 점(Point): 마지막 차원 값이 1인 아핀 공간의 원소      
> 행렬 곱을 사용해 이동이 가능하다        
> 가상 공간이 이동하려면 물체는 점으로 구성되어야 한다        
> 2차원 공간에서 점은 항상 $(x, y, 1)$의 형태여야 한다

* * *

[본문](README-ORIGIN.md#151-점)

# 15.2. 이동 벡터
### 선요약

> - 아핀 공간의 벡터(변위 벡터 / Displacement vector): 벡터는 아핀 공간 내의 이동을 지정하기 위해 사용됨       
> 아핀 공간의 점 $P_1, P_2$와 이동 벡터 $\vec{v}$에 대해 다음의 식이 성립한다     
> $P_1 + \vec{v} = P_2$, $\vec{v} = P_2 - P_1$, $P_1 - P_2 = -\vec{v}$        
> 점 $P_1$의 좌표를 $(x_1, y_1, 1)$로 $P_2$의 좌표를 $(x_2, y_2, 1)$로 지정할 때 두 점을 빼서 만든 이동 벡터의 마지막 차원 값은 $x, y$값과 무관하게 항상 0이 된다     
> $(x_1 - x_2, y_1 - y_2, 0)$     
> 따라서 이동 벡터들이 모이면 마지막 차원 $z$의 값이 항상 0인 영역을 형성한다

* * *

[본문](README-ORIGIN.md#152-이동-벡터)

# 15.3. 아핀 공간의 성질
### 선요약

> - 아핀 공간의 원점 $O$: $(0, 0, 1)$
> - 아핀 공간에 속한 임의의 점 $P$로 향하는 이동벡터 $\vec{v}$: $\vec{v} = P - O = (x, y, 1) - (0, 0, 1) = (x, y, 0)$
> 
> 점과 벡터의 덧셈 연산은 아핀 공간에 대해 닫혀 있다      
> 따라서 점과 이동 벡터를 구분하는 마지막 차원값을 생략해도 2차원 평면에서 아핀 공간의 점을 점으로, 이동 벡터를 화살표로 표시하면 둘을 구분할 수 있다
> 
> - 유클리드 공간(Euclidean space): 물리적인 관점에서 바라본 현실 세계의 3차원 공간       
> - 유클리드 벡터(Euclidean vector): 유클리드 공간에서 작용하는 힘        
> 이에 대응되는 개념이 각각 아핀 공간과 이동 벡터다
> 
> - 점: 물체를 표현하고 위치를 지정하는 데 사용한다. 마지막 차원의 값은 항상 1이다
> - 이동 벡터(이하 벡터): 물체를 움직이는 데 사용한다. 마지막 차원의 값은 항상 0이다
> 
> 점과 벡터의 마지막 차원 값을 토대로 두 요소 사이에는 다음과 같은 연산 규칙이 성립된다       
> 이때 점과 점을 더하는 수식은 성립하지 않는데, 점과 점을 더하면 마지막 차원 값이 2가 되어 아핀 공간 영영을 벗어나기 때문이다
> 
> - $점 - 점 = 벡터$ (예: $1 - 1 = 0$)
> - $점 + 벡터 = 점$ (예: $1 + 0 - 1$)
> - $벡터 + 벡터 = 벡터$ (예: $0 + 0 = 0$)
> - $점 + 점 \neq 점$ (예: $1 + 1 \neq 1$)

* * *

[본문](README-ORIGIN.md#153-아핀-공간의-성질)

# 16. 아핀 결합
### 선요약

> 일반적으로 아핀 공간을 다룰 때 점과 점을 더한 결과는 사용할 수 없다     
> 점과 점을 더할 때 그대로 더하는 것이 아닌 선형 결합의 형태로 점에 스칼라(계수)를 곱해 더한다면, 특정 조건에서 새로운 점을 생성하는 것이 가능하다
> 
> 2차원 평면상 임의의 두 점의 선형 결합의 식:
> 
> $$a \cdot P_1 + b \cdot P_2 = (ax_1 + bx_2, ay_1 + by_2, a + b)$$
> 
> 두 점의 선형 결합 결과가 언제나 점이 되려면 마지막 차원 값 $a + b$가 1이 되어야 한다        
> $x$와 $y$ 값과 무관하게 $a + b = 1$의 조건을 유지한다면 점과 점을 결합해 새로운 점을 만들 수 있다       
> 세 점에 대해서도 동일한 원리가 적용된다
> 
> - 아핀 결합(Affine combination): 여러 개의 점을 결합해 새로운 점을 생성하는 수식

* * *

[본문](README-ORIGIN.md#16-아핀-결합)

# 16.1. 두 점의 결합
### 선요약

> 두 점의 아핀 결합이 성립하려면 점에 곱한 두 스칼라의 합이 $a + b = 1$을 만족해야 하는데, $b$를 $1 - a$로 치환하면 계수 $a$에 대한 식을 얻게 되며 이는 언제나 점의 생성을 보장한다       
> 
> 아핀 결합으로 생성된 점 $P'$의 수식:
> 
> $$a \cdot P_1 + (1 - a) \cdot P_2 = P'$$
> 
> 스칼라 $a$ 값의 변화에 따라 생성되는 점:
> 
> $$1 \cdot P_1 + 0 \cdot (x_2, y_2, 1) = P_1$$
> 
> $$0 \cdot (x_1, y_1, 1) + P_2 = P_2$$
> 
> $$\frac{1}{2} \cdot (x_1, y_1, 1) + \frac{1}{2} \cdot (x_2, y_2, 1) = (\frac{x_1 + x_2}{2}, \frac{y_1 + y_2}{2}, 1)$$
> 
> 두 점 $P_1$과 $P_2$의 아핀 결합을 통해 새로운 점을 생성하면, $a$ 값이 양의 방향으로 커질수록 $P_1$의 바깥쪽 방향에 점이 생성되고, $a$ 값이 음의 방향으로 커질수록 $P_2$의 바깥쪽 방향에 점이 생성된다       
> 이러한 점을 모두 모으면 두 점 $P_1$과 $P_2$를 지나는 무한한 긴 선이 만들어진다
> 
> 아핀 결합으로 생성되는 점의 수식에 모든 실수 $a$를 대입하면 두 점을 이은 양 끝으로 무한히 뻗은 선을 얻을 수 있다        
> 이 수식을 직선의 방정식이라고 한다
> 
> 직선의 방정식:
> 
> $$L(a) = a \cdot P_1 + (1 - a) \cdot P_2$$
> 
> $a$의 범위에 따른 선의 종류:
> 
> |종류|범위|설명|
> |---|---|---|
> |직선(Line)|$-\infty < a < \infty$|두 점의 양쪽 방향으로 무한히 뻗어나가는 선의 형태. 추상적인 선의 성질을 표현할 때 사용한다.|
> |반직선(Ray)|$0 \leq a \leq \infty$|지정한 위치에서 한쪽 방향으로만 뻗어나가는 선을 뜻한다. 게임 제작에서 전방에 물체가 있는지 탐지하기 위해 사용하는 기능에 레이캐스팅(Raycasting)이 있다.|
> |선분(Line segment)|$0 \leq a \leq 1$|시작점과 끝점의 위치가 정해져 있는 선을 말한다. 프로그래밍을 활용해 화면에 선을 그리기 위해선 무한이라는 추상적인 개념을 배제하고 명확하게 시작점과 끝점을 정해주어 선분의 형태로 정보가 제공되어야 한다.|

* * *

[본문](README-ORIGIN.md#161-두-점의-결합)

# 17. 벡터의 내적
### 선요약

> - 내적(Dot product): 같은 차원의 두 벡터가 주어졌을 때, 벡터를 구성하는 각 성분을 곱한 후 이들을 더해 스칼라를 만들어내는 연산      
> 내적은 곱셈 기호와 동일한 가운뎃점($\cdot$)을 사용한다
> 
> $$\vec{u} = (a, b)$$
> 
> $$\vec{v} = (c, d)$$
> 
> $$\vec{u} \cdot \vec{v} = a \cdot c + b \cdot d$$

* * *

[본문](README-ORIGIN.md#17-벡터의-내적)

# 17.1. 내적의 성질
### 선요약

> 내적의 연산 법칙 성립:
> 
> |법칙|성립 여부|이유|
> |---|---|---|
> |교환법칙|O|내적은 스칼라의 곱셈과 덧셈으로 구성되어 있음|
> |결합법칙|X|내적의 결과가 벡터가 아닌 스칼라로 나오기 때문에 성립하지 않음|
> |분배법칙|O|덧셈에 대한 분배법칙이 성립함|
> 
> 같은 벡터의 내적: 벡터의 크기를 제곱한 결과가 나온다        
> 이 내적의 성질은 모든 차원의 벡터에 동일하게 적용된다
> 
> $$(x, y) \cdot (x, y) = x^2 + y^2$$
> 
> $$\therefore \vec{v} \cdot \vec{v} = |\vec{v}|^2$$

* * *

[본문](README-ORIGIN.md#171-내적의-성질)

# 17.2. 내적과 삼각함수의 관계
### 선요약

> - 벡터의 내적 특징: 두 벡터의 사잇각에 대한 $\cos$ 함수와 비례한다
> 
> $$\vec{u} \cdot \vec{v} = |\vec{u}||\vec{v}| \cos \theta$$
> 
> 내적의 성질은 덧셈과 곱셈만 사용해 $\cos$ 함수 값을 빠르게 계산할 수 있어 유용하게 활용된다     
> 위 식에서 영벡터가 아닌 경우, 내적 값이 0이 되기 위한 조건은 $\cos$ 함수 값이 0이 되는 경우뿐인데, 이는 두 벡터의 사잇각이 $90^\circ$ 혹은 $270(-90^\circ)$처럼 두 벡터가 서로 직교하는 경우다
> 
> 따라서 두 벡터의 내적이 0이면 두 벡터는 직교한다고 결론내릴 수 있으며 이는 두 벡터의 직교성을 판별하는 데 활용된다

* * *

[본문](README-ORIGIN.md#172-내적과-삼각함수의-관계)

# 17.3. 행렬의 곱셈을 내적으로 표현하기
### 선요약

> 행렬과 벡터의 곱셈은 행렬을 구성하는 두 개의 행벡터 $(a, b), (c, d)$와 벡터를 구성하는 열벡터 $(x, y)$의 내적으로 표현할 수 있다
> 
> $$
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix}
\begin{bmatrix}
x \\
y \\
\end{bmatrix} =
\begin{bmatrix}
ax + by \\
cx + dy \\
\end{bmatrix} =
\begin{bmatrix}
(a, b) \cdot (x, y) \\
(c, d) \cdot (x, y) \\
\end{bmatrix}$$
> 
> 행렬의 곱셈 또한 벡터의 내적으로 바꿔 표현할 수 있다
> 
> $$
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix}
\begin{bmatrix}
e & f \\
g & h \\
\end{bmatrix} =
\begin{bmatrix}
ae + bg & af + bh \\
ce + dg & cf + dh \\
\end{bmatrix} =
\begin{bmatrix}
(a, b) \cdot (e, g) & (a, b) \cdot (f, h) \\
(c, d) \cdot (e, g) & (c, d) \cdot (f, h) \\
\end{bmatrix}$$
> 
> - 직교행렬(Orthogonal matrix): 정방행렬을 구성하는 모든 행벡터와 열벡터의 크기가 1이고 벡터들이 서로 직교하는 행렬      
> $a, b, c, d$로 구성된 직교행렬을 $Q$로 지정하면 열벡터와 행벡터를 구성하는 $(a, b), (b, d), (a, c), (c, d)$의 크기는 1이고 $(a, b)$와 $(c, d)$는 서로 직교한다      
> 
> $$Q = 
\begin{bmatrix}
a & c \\
b & d \\
\end{bmatrix}$$
> 
> 직교행렬의 전치행렬은 역행렬이 된다     
> 때문에 직교행렬 $Q$와 이의 전치행렬 $Q^T$의 곱은 항등행렬이 된다
> 
> $$Q \cdot Q^T = I$$
> 
> - 강체 변환(Rigid Transformation): 물체의 형태가 그대로 유지되는 선형 변환
> 
> 강체 변환 조건:
> 1. 변환된 기저벡터의 크기는 모두 1이어야 한다
> 2. 모든 기저벡터는 서로 직교해야 한다
> 3. 행렬식 값이 1이어야 한다

* * *

[본문](README-ORIGIN.md#173-행렬의-곱셈을-내적으로-표현하기)

# 18. 시야 판별
# 18.1. 앞뒤 판별
### 선요약

> - 목표물의 앞뒤 판별: 내적의 부호를 통해 파악할 수 있다
> 
> 벡터 내적의 부호는 $\cos$ 함수가 결정한다       
> $\cos$ 함수는 $(-90^\circ, 90^\circ)$ 영역에 대해 양의 부호를 가지고 $-90^\circ$와 $90^\circ$에서는 0, 나머지 범위에서는 음의 부호를 가진다     
> 따라서 벡터 내적의 부호는 두 벡터가 이루는 사잇각의 범위에 따라 결정된다
> 
> - 벡터 내적의 결과가 양수: 두 벡터는 같은 방향을 향하고 있다
> - 벡터 내적의 결과가 음수: 두 벡터는 다른 방향을 향하고 있다        
> 벡터는 위치의 개념이 없으므로 두 벡터는 서로 마주보고 있다로도 해석할 수 있다
> - 벡터 내적의 결과가 0: 두 벡터는 서로 직교한다
> 
> 캐릭터가 바라보는 방향을 시선 벡터 $\vec{f}$로 설정하고 목표물의 위치에서 캐릭터의 위치를 빼서 캐릭터에서 목표물로 향하는 벡터 $\vec{v}$를 설정하면 둘의 상관 관계는 아래와 같다
> 
> - $\vec{f} \cdot \vec{v}$ 결과의 부호가 양수: 캐릭터 앞에 목표물이 있다
> - $\vec{f} \cdot \vec{v}$ 결과의 부호가 음쉬: 캐릭터 뒤에 목표물이 있다
> - $\vec{f} \cdot \vec{v}$ 결과가 0: 캐릭터 바로 옆에 목표물이 있다

* * *

[본문](README-ORIGIN.md#181-앞뒤-판별)

# 18.2. 시야 판별
### 선요약

> - 시야각: 캐릭터에 부여한 시야각이 $\beta$라면 양쪽으로 균등하게 $\frac{\beta}{2}$의 시야각이 설정된다
> 
> 내적으로 캐릭터의 시야에 목표물이 탐지되는지는 사잇각 $a$가 시야각의 절반인 $\frac{\beta}{2}$보다 작거나 같은지 비교하여 알 수 있다
> 
> 1. 시야각을 절반 나눈 각의 $\cos\frac{\beta}{2}$를 미리 계산해둔다
> 2. 캐릭터의 시선 벡터를 구하고 이의 크기를 1로 정규화시킨다     
> 이를 단위 벡터 $\hat{f}$로 지정한다
> 3. 캐릭터에서 목표물로 향하는 벡터를 정규화한다     
> 이를 단위 벡터 $\hat{v}$로 지정한다
> 4. 내적 $\hat{f} \cdot \hat{v}$의 계산 결과는 $\cos a$가 된다       
> 이를 앞서 계산해 둔 $\cos \frac{\beta}{2}$ 값과 비교한다
> 
> - $\hat{f} \cdot \hat{v} \geq \cos\frac{\beta}{2}$: 목표물이 시야 범위 안에 있음
> - $\hat{f} \cdot \hat{v} < \cos\frac{\beta}{2}$: 목표물이 시야 범위 밖에 있음
> 
> $atan2$ 함수를 활용해 두 벡터가 이루는 각 $a$를 구한 후 이를 $\frac{\beta}{2}$와 비교해도 동일한 결과를 얻을 수 있지만 단위 벡터를 구한 후 내적을 계산하는 방식이 더 효율적이다

* * *

[본문](README-ORIGIN.md#182-시야-판별)

# 19. 조명 효과의 구현
### 선요약

> - 램버트 반사(Lambertian reflection): 현실 세계와 비슷한 조명 효과를 만들기 위해 고안된 방법        
> 컴퓨터 그래픽스에서 표면에서의 조명 모델 계산을 위해 쓰인다     
> 램버트 반사 모델은 계산량이 적어 속도가 빠르지만 그럴듯한 조명 효과를 줄 수 있어 실시간 조명 구현이 필요한 게임 제작에 널리 사용된다        
> 빛을 받아 표면에서 반사되는 빛의 세기는 두 벡터가 만드는 사잇각의 $\cos$ 함수에 비례한다        
> 표면이 향하는 단위 벡터를 $\hat{N}$으로 지정하고 표면에서 광원으로 향하는 단위 벡터를 $\hat{L}$로 지정하여 두 벡터의 내적을 사용하면 램버트 반사 모델에 필요한 사잇각의 $\cos$ 값을 얻을 수 있다
> 
> $$\hat{N} \cdot \hat{L} = \cos \theta$$

* * *

[본문](README-ORIGIN2.md#19-조명-효과의-구현)

# 20. 투영 벡터
### 선요약

> 벡터 내적은 어떤 벡터를 다른 벡터에 직교 투영하는 용도로 사용된다       
> 예를 들어 카메라가 만드는 공간을 분석할 때 카메라와 물체 사이의 거리 외에도 카메라에서 물체까지의 깊이 값이 필요한 경우가 있는데, 이 경우 내적을 활용한 투영 벡터를 구하는 공식이 활용된다
> 
> 투영한 벡터 $\vec{v'}$의 크기를 알고 있다면 $\vec{v}$를 정규화시킨 단위 벡터 $\hat{v}$를 구하고 그 크기를 곱하여 투영된 벡터를 얻을 수 있다
> 
> $$\vec{v'} = |\vec{v'}| \cdot \hat{v}$$
> 
> 내적을 활용해 $\vec{u}$로부터 $\vec{v'}$를 구할 수 있다
> 
> $$\vec{v'} = \frac{(\vec{u} \cdot \vec{v})}{(\vec{v} \cdot \vec{v})} \cdot \vec{v}$$

* * *

[본문](README-ORIGIN2.md#20-투영-벡터)

# 21. 세 점의 결합
### 선요약

> 아핀 결합식에 사용하는 스칼라(계수) 값의 범위에 따라 직선, 반직선, 선분 등 다양한 종류의 선을 만들 수 있다      
> 세 점 $P_1, P_2, P_3$를 결합하는 경우 스칼라는 2개에서 3개로 늘어나고 세 스칼라의 합은 1이 되어야 하므로 아핀 결합 식은 다음과 같이 전개된다
> 
> $$P' = s \cdot P_1 + t \cdot P_2 + (1 - s - t) \cdot P_3$$
> 
> 점에서 점을 빼는 수식으로 바꿔 전개하면 다음과 같다
> 
> $$(P' - P_3) = s(P_1 - P_3) + t(P_2 - P_3)$$
> 
> 각 괄호를 $\vec{u}, \vec{v}, \vec{w}$의 벡터로 치환하면 다음과 같이 벡터로 구성된 수식이 만들어진다
> 
> $$\vec{w} = s \cdot \vec{u} + t \cdot \vec{v}$$
> 
> 벡터 $\vec{u}$와 $\vec{v}$가 서로 선형 독립의 관계라면 벡터 $\vec{w}$는 2차원 벡터 공간 $R^2$에 존재하는 모든 벡터를 생성할 수 있다     
> 따라서 세 점의 아핀 결합은 평면의 모든 점을 만들어낸다
> 
> 선분이 만들어지는 조건과 동일하게 $s$와 $t$의 값을 $|0, 1|$ 범위로 고정시키고 스칼라 $s$와 $t$의 값을 몇 가지 지정하면 해당 영역은 삼각형이 된다
> 
> 아핀 결합식에서 스칼라 값을 $|0, 1|$ 범위로 제한하면 시작과 끝의 범위가 명확해지므로 선분과 동일하게 그릴 수 있는 도형이 만들어진다
> 
> - 컨벡스 결합(Convex combination): 아핀 결합에서 모든 스칼라 값을 $|0, 1|$ 범위로 한정한 결합       
> 컨벡스 결합은 아핀 결합식에 각 스칼라의 범위를 $|0, 1|$로 제한하는 조건을 추가해 다음과 같이 표현할 수 있다다
> 
> $$\sum^{n}_{i=0} c_i \cdot P_i \qquad (s.t. \quad \sum^{n}_{i=0} c_i = 1, 0 \geq c_i \geq 1)$$
> 
> - 컨벡스 영역(Convex region): 선분이나 삼각형처럼 컨벡스 결합으로 만든 영역     
> 컨벡스의 사전적 의미는 '볼록한'을 뜻한다        
> 수학에서 정의한 '볼록함'이란, 영역 내 임의의 두 점을 연결한 선분을 만들었을 때 그 선분은 언제나 해당 컨벡스 영역 안에 속하는 성질을 의미한다
> - 컨케이브(Concave): 컨벡스의 반대되는 오목한 모양      
> 컨케이브 영역은 임의의 두 점을 이은 선분이 영역 밖으로 벗어나는 경우가 발생한다
> 
> 컨벡스 결합으로 만들어지는 1차원의 선분, 2차원의 삼각형, 3차원의 삼각뿔 중에서 가상 공간의 물체를 표현하는 데 가장 적합한 도형은 삼각형이다     
> 삼각형으로는 2차원의 물체를 효과적으로 표현할 수 있으며, 3차원 물체도 표면만을 다루기 때문에 삼각형만으로 표현하는 것이 가장 효과적이다

* * *

[본문](README-ORIGIN2.md#21-세-점의-결합)

# 22. 메시
### 선요약

> 3차원 공간의 입체적인 물체는 삼각형을 이어붙여서 표현이 가능하다        
> 
> - 메시(Mesh): 삼각형을 중심으로 물체에 관련된 정보를 기록한 데이터      
> 물체를 표현하기 위해 삼각형 데이터를 체계적으로 읽고 쓰는 방법이다      
> 메시는 다수의 삼각형으로 구성되고, 메시를 이루는 삼각형은 다시 3개의 점으로 구성된다        
> 메시는 다수의 점으로 구성된다고 정리할 수 있다
> - 정점(Vertex): 메시는 삼각형을 이용해 물체의 외형을 표현하기 때문에, 삼각형을 이루는 각 점의 위치를 가지고 있어야 한다     
> 위치 정보만 담지 않고, 물체를 표현하는 데 활용할 수 있는 색상이나 방향과 같은 다양한 부가 정보를 묶은 특별한 점
> - 정점 버퍼(Vertex buffer): 컴퓨터에서 메시를 읽어 물체를 표현할 때에는 메시의 정점 정보를 빠르게 읽기 위해서 메모리에 정점 정보를 일렬로 나열하는 배열의 형태로 관리한다
> - 인덱스 버퍼(Index buffer): 정점 버퍼의 정보만으로는 어떤 세 정점이 모여 삼각형을 구성하는지 알 수 없기 때문에 삼각형을 구성하는 정점의 인덱스(순번)만 기록한 배열을 별도로 만들어 관리한다        
> 인덱스 정보는 삼각형의 수만큼 필요하기 때문에 인덱스 버퍼의 크기는 항상 3의 배수다
> - 와이어프레임(Wireframe): 삼각형의 외곽선만 그려 메시를 표현하는 방법

* * *

[본문](README-ORIGIN2.md#22-메시)

# 23. 무게중심좌표
### 선요약

> - 무게중심좌표(Barycentric coordinate): 세 점의 아핀 결합에 사용되는 스칼라 $s, t, 1 - s - t$를 묶어 만든 좌표        
> 삼각형에 관련된 정보를 담고 있다

* * *

[본문](README-ORIGIN2.md#23-무게중심좌표)

# 23.1. 무게중심좌표의 계산
### 선요약

> 세 점의 아핀 결합이 삼각형이 되려면 모든 스칼라의 값이 $|0, 1|$ 범위 내에 있어야 한다       
> 무게중심좌표를 구성하는 스칼라 값이 하나라도 $|0, 1|$ 범위를 벗어난다면 아핀 결합으로 생성된 점은 삼각형 외부에 있다고 할 수 있다       
> 이러한 성질을 활용하면 주어진 점이 삼각형 영역의 내부에 있는지 외부에 있는 판단할 수 있다
> 
> - 퇴화삼각형(Degenerate triangle): 선형 종속의 관계를 이루는 세 점의 결합으로 만들어진 선분     
> 퇴화삼각형이 검출되면 그리기에서 제외한다

* * *

[본문](README-ORIGIN2.md#231-무게중심좌표의-계산)

# 24. 텍스처 매핑
### 선요약

> - 텍스처(Texture): 메시에 이미지를 입히기 위해 변환된 데이터
> - 텍스처 매핑(Texture mapping): 메시에 이미지를 입히는 작업
> - UV 좌표계: 텍스처를 구성하는 2차원 좌표계     
> 사진이나 그림을 저장한 이미지는 가로와 세로의 픽셀 수에 따른 고유한 해상도를 가지지만, 이미지를 메시에 입히기 위해 텍스처로 변환하면 관리 방식을 통일하기 위해 이미지의 원본 해상도에 관계없이 텍스처의 가로, 세로 크기는 1로 정규화된다        
> 따라서 렌더링 과정에서 텍스처를 사용할 때에는 $|0, 1|$ 범위로 구성된 UV 좌표계를 사용한다       
> UV 좌표계는 2차원 벡터로 구성되며 가로 정보는 U, 세로 정보는 V로 지정된다       
> UV 좌표계가 형성됐다면 텍스처 매핑을 위해 삼각형의 세 정점에 UV 좌표를 추가해야 한다        
> 삼각형을 구성하는 각 픽셀의 무게중심좌표를 계산하고 이를 정점의 UV 좌표와 선형 보간하면 해당 픽셀의 UV 값을 얻어낼 수 있다      
> 이에 대응하는 텍스처의 색상 정보를 얻은 후 이를 최종 픽셀의 색상으로 지정하면 텍스처 매핑이 완성된다

* * *

[본문](README-ORIGIN2.md#24-텍스처-매핑)

# 25. 3차원 공간의 설계
### 선요약

> - 데카르트 좌표계: 우리가 보는 모니터 화면이 데카르트 좌표계로 표현된다
> - 오른손 좌표계(Right-handed coordinate system): 나머지 한 축이 모니터가 바라보는 방향과 일치하는 체계
> - 왼손 좌표계(Left-handed coordinate system): 나머지 한 축이 모니터 뒤편을 향하는 체계

* * *

[본문](README-ORIGIN2.md#25-3차원-공간의-설계)

# 26. 3차원 공간의 트랜스폼
### 선요약

> 3차원 공간의 회전 변환은 3차원 공간을 구성하는 세 표준기저벡터가 동일한 크기와 직교성을 유지한 상태로 함께 움직여야 한다        
> 회전 변환으로 달라진 세 표준기저벡터값을 알 수 있다면 이를 열벡터로 꽂아넣어 회전 변환행렬 $R$을 만들어낼 수 있다       
> 하지만 3차원 공간의 회전을 지정한다는 것은 매번 3개의 변화된 표준기저벡터 값을 계산해야 하기 때문에 까다로운 작업이다       
> 따라서 회전을 지정할 때는 일반적으로 회전하는 중심축과 각으로 표현된 회전량을 지정하는 방식을 사용한다      
> 2차원 공간은 하나의 평면만 존재하기 때문에 각으로 회전량을 지정하면 원하는 회전을 설계할 수 있었지만, 3차원 공간은 무수한 많은 평면으로 구성되기 때문에 새로운 방식이 필요하다      
> 3차원 공간의 회전을 표현하는 대표적인 방법엔 오일러 각(Euler's angle)이 있다

* * *

[본문](README-ORIGIN2.md#26-3차원-공간의-트랜스폼)

# 26.1. 오일러 각
### 선요약

> - 오일러 각(Euler's angle): 3차원 공간에서 물체가 놓인 방향을 3개의 각을 사용해 표시하는 방법       
> 오일러 각은 직관적으로 이해하기 쉽기 때문에 3차원 공간을 사용하는 프로그램에서 자주 사용된다        
> 게임 엔진에서 오일러 각을 사용해 물체의 방향을 표시할 때는 표준기저벡터를 사용한다      
> 그래서 오일러 각은 표준기저벡터를 중심으로 회전하는 각의 크기로 지정된다    
> 세 표준기저벡터를 중심으로 회전하는 각을 모으면 다음의 3차원 벡터로 표현할 수 있다
> 
> $$(\theta_x, \theta_y, \theta_z)$$
> 
> - 오일러 각 범용 사용의 문제: 소프트웨어마다 $x, y, z$축의 용도가 다르기 때문에 $x, y, z$축 대신 회전의 움직임으로 회전 동작을 구분하고 각을 지정하는 방법을 사용한다
> - 요, 롤, 피치(Yaw, Roll, Pitch): 표준기저벡터를 축으로 하는 회전의 움직임

* * *

[본문](README-ORIGIN2.md#261-오일러-각)

# 26.2. 회전행렬의 유도
### 선요약

> 각 기저 축의 회전행렬을 구했다면, 이를 순서대로 적용해 최종 회전행렬을 만들어야 한다        
> 세 번이 연속적인 회전으로 구성된 오일러 각 회전 방법은 총 6가지의 경우가 발생한다

* * *

[본문](README-ORIGIN2.md#262-회전행렬의-유도)

# 26.3. 3차원 모델링 행렬
### 선요약

> 3차원 공간의 트랜스폼을 구성하는 크기(S), 회전(R), 이동(T) 변환행렬은 다음과 같다
> 
> $$S = 
\begin{bmatrix}
s_x & 0 & 0 & 0 \\
0 & s_y & 0 & 0 \\
0 & 0 & s_z & 0 \\
0 & 0 & 0 & 1 \\
\end{bmatrix}$$
> 
> $$R = 
\begin{bmatrix}
x_x & y_x & z_x & 0 \\
x_y & y_y & z_y & 0 \\
x_z & y_z & z_z & 0 \\
0 & 0 & 0 & 1 \\
\end{bmatrix}$$
> 
> $$T =
\begin{bmatrix}
1 & 0 & 0 & t_x \\
0 & 1 & 0 & t_y \\
0 & 0 & 1 & t_z \\
0 & 0 & 0 & 1 \\
\end{bmatrix}$$
> 
> 세 행렬을 $TRS$ 연산 순서에 따라 곱해 만든 모델링 행렬 $M$은 다음과 같이 계산된다
> 
> $$M = T \cdot R \cdot S =
\begin{bmatrix}
x_xs_x & y_xs_y & z_xs_z & t_x \\
x_ys_x & y_ys_y & z_ys_z & t_y \\
x_zs_x & y_zs_y & z_zs_z & y_z \\
0 & 0 & 0 & 1 \\
\end{bmatrix}$$
>

* * *

[본문](README-ORIGIN2.md#263-3차원-모델링-행렬)

* * *
 
[다음 페이지](README2.md/#27-카메라-공간)