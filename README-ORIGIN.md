# 게임 수학 정리 문서
게임 개발에 필요한 수학 개념에 대해 정리한 문서입니다.

# 목차
* [1. 수와 집합](#1-수와-집합)
    * [1.1. 연산과 수의 구조](#11-연산과-수의-구조)
    * [1.2. 수의 구조](#12-수의-구조)
    * [1.3. 수의 표현](#13-수의-표현)
* [2. 함수](#2-함수)
    * [2.1. 함수의 개념과 종류](#21-함수의-개념과-종류)
    * [2.2. 합성함수](#22-합성함수)
    * [2.3. 항등함수와 역함수](#23-항등함수와-역함수)
    * [2.4. 곱집합을 활용한 좌표 평면으로의 확장](#24-곱집합을-활용한-좌표-평면으로의-확장)
* [3. 데카르트 좌표계](#3-데카르트-좌표계)
* [4. 벡터 공간과 벡터](#4-벡터-공간과-벡터)
    * [4.1. 스칼라와 벡터](#41-스칼라와-벡터)
    * [4.2. 벡터 공간의 연산](#42-벡터-공간의-연산)
    * [4.3. 벡터의 크기와 이동](#43-벡터의-크기와-이동)
* [5. 벡터의 결합과 생성](#5-벡터의-결합과-생성)
* [6. 삼각함수](#6-삼각함수)
    * [6.1. 삼각함수의 성질](#61-삼각함수의-성질)
    * [6.2. 각의 측정법](#62-각의-측정법)
* [7. 삼각함수를 활용한 물체의 회전](#7-삼각함수를-활용한-물체의-회전)
* [8. 삼각함수의 역함수](#8-삼각함수의-역함수)
* [9. 극좌표계](#9-극좌표계)
* [10. 선형성: 예측 가능한 비례 관계](#10-선형성-예측-가능한-비례-관계)
    * [10.1. 선형 함수](#101-선형-함수)
    * [10.2. 벡터 공간의 선형 변환](#102-벡터-공간의-선형-변환)
* [11. 행렬](#11-행렬)
    * [11.1. 행렬의 기본 연산](#111-행렬의-기본-연산)
    * [11.2. 행렬의 곱셈](#112-행렬의-곱셈)
    * [11.3. 정방행렬의 곱셈](#113-정방행렬의-곱셈)
* [12. 행렬의 설계](#12-행렬의-설계)
    * [12.1. 크기 변환행렬](#121-크기-변환행렬)
    * [12.2. 회전 변환행렬](#122-회전-변환행렬)
    * [12.3. 전단 변환행렬](#123-전단-변환행렬)
    * [12.4. 삼각함수의 덧셈 정리](#124-삼각함수의-덧셈-정리)
* [13. 역행렬](#13-역행렬)
    * [13.1. 역행렬의 존재를 판별하는 행렬식](#131-역행렬의-존재를-판별하는-행렬식)
    * [13.2. 크기 변환행렬의 역행렬](#132-크기-변환행렬의-역행렬)
    * [13.3. 전단 변환행렬의 역행렬](#133-전단-변환행렬의-역행렬)
    * [13.4. 회전 변환행렬의 역행렬](#134-회전-변환행렬의-역행렬)
    * [13.5. 행렬 곱의 역행렬](#135-행렬-곱의-역행렬)
* [14. 이동 변환을 위한 아핀 공간](#14-이동-변환을-위한-아핀-공간)
* [15. 아핀 공간의 구성 요소](#15-아핀-공간의-구성-요소)
    * [15.1. 점](#151-점)
    * [15.2. 이동 벡터](#152-이동-벡터)
    * [15.3. 아핀 공간의 성질](#153-아핀-공간의-성질)
* [16. 아핀 결합](#16-아핀-결합)
    * [16.1. 두 점의 결합](#161-두-점의-결합)
* [17. 벡터의 내적](#17-벡터의-내적)
    * [17.1. 내적의 성질](#171-내적의-성질)
    * [17.2. 내적과 삼각함수의 관계](#172-내적과-삼각함수의-관계)
    * [17.3. 행렬의 곱셈을 내적으로 표현하기](#173-행렬의-곱셈을-내적으로-표현하기)
* [18. 시야 판별](#18-시야-판별)
    * [18.1. 앞뒤 판별](#181-앞뒤-판별)
    * [18.2. 시야 판별](#182-시야-판별)
* [19. 조명 효과의 구현](#19-조명-효과의-구현)
* [20. 투영 벡터](#20-투영-벡터)
* [21. 세 점의 결합](#21-세-점의-결합)
* [22. 메시](#22-메시)
* [23. 무게중심좌표](#23-무게중심좌표)
    * [23.1. 무게중심좌표의 계산](#231-무게중심좌표의-계산)
* [24. 텍스처 매핑](#24-텍스처-매핑)
* [25. 3차원 공간의 설계](#25-3차원-공간의-설계)
* [26. 3차원 공간의 트랜스폼](#26-3차원-공간의-트랜스폼)
    * [26.1. 오일러 각](#261오일러-각)
    * [26.2. 회전행렬의 유도](#262-회전행렬의-유도)
    * [26.3. 3차원 모델링 행렬](#263-3차원-모델링-행렬)
* [27. 카메라 공간](#27-카메라-공간)
* [28. 오일러 각의 특징](#28-오일러-각의-특징)
    * [28.1 짐벌락 현상](#281-짐벌락-현상)
    * [28.2 회전 보간의 계산](#282-회전-보간의-계산)
* [29. 벡터의 외적](#29-벡터의-외적)
    * [29.1. 평행성 판별](#291-평행성-판별)
    * [29.2. 법선 벡터](#292-법선-벡터)
    * [29.3. 좌우 방향 판별](#293-좌우-방향-판별)
* [30. 벡터로부터 회전행렬 생성](#30-벡터로부터-회전행렬-생성)
* [31. 렌더링 계산량을 줄여주는 백페이스 컬링](#31-렌더링-계산량을-줄여주는-백페이스-컬링)
* [32. 오일러 각의 문제를 해결하는 로드리게스 회전 공식](#32-오일러-각의-문제를-해결하는-로드리게스-회전-공식)
* [33. 삼중곱](#33-삼중곱)
    * [33.1. 스칼라 삼중곱](#331-스칼라-삼중곱)
    * [33.2. 벡터 삼중곱](#332-벡터-삼중곱)
* [34. 원근 투영 변환의 원리](#34-원근-투영-변환의-원리)
* [35. 동차 좌표계](#35-동차-좌표계)
* [36. 깊이 값](#36-깊이-값)
* [37. 원근 보정 매핑](#37-원근-보정-매핑)
* [38. 깊이 버퍼](#38-깊이-버퍼)
* [39. 절두체 컬링](#39-절두체-컬링)
    * [39.1. 평면의 방정식](#391-평면의-방정식)
    * [39.2. 평면의 방정식의 정규화](#392-평면의-방정식의-정규화)
    * [39.3. 평면의 방정식을 활용한 절두체 표현](#393-평면의-방정식을-활용한-절두체-표현)
    * [39.4. 원근 투영 행렬로부터 평면의 방정식 만들기](#394-원근-투영-행렬로부터-평면의-방정식-만들기)
* [40. 바운딩 볼륨](#40-바운딩-볼륨)
    * [40.1. 구 바운딩 볼륨의 판정](#401-구-바운딩-볼륨의-판정)
    * [40.2. aabb와의 판정](#402-aabb와의-판정)
* [41. 삼각형 클리핑](#41-삼각형-클리핑)
* [42. 복소수](#42-복소수)
    * [42.1. 허수](#421-허수)
    * [42.2. 복소수의 구조](#422-복소수의-구조)
* [43. 복소평면](#43-복소평면)
    * [43.1. 단위 복소수와의 곱](#431-단위-복소수와의-곱)
    * [43.2. 켤레 복소수의 회전 변환](#432-켤레-복소수의-회전-변환)
* [44. 복소수와 행렬의 관계](#44-복소수와-행렬의-관계)
* [45. 자연지수함수](#45-자연지수함수)
    * [45.1. 무리수 e](#451-무리수-e)
    * [45.2. 자연지수함수](#452-자연지수함수)
* [46. 미분](#46-미분)
    * [46.1. 도함수](#461-도함수)
    * [46.2. 자연지수함수의 도함수)](#462-자연지수함수의-도함수)
    * [46.3. sin 함수와 cos 함수의 도함수)](#463-sin-함수와-cos-함수의-도함수)
* [47. 급수](#47-급수)
    * [47.1. 등비수열](#471-등비수열)
    * [47.2. 급수](#472-급수)
    * [47.3. 매클로린 급수](#473-매클로린-급수)
* [48. 오일러 공식](#48-오일러-공식)
* [49. 사원수 대수](#49-사원수-대수)
    * [49.1. 사원수를 구성하는 세 허수](#491-사원수를-구성하는-세-허수)
    * [49.2. 사원수의 구조](#492-사원수의-구조)
    * [49.3. 사원수와 벡터](#493-사원수와-벡터)
* [50. 사원수의 회전](#50-사원수의-회전)
    * [50.1. 사원수와 오일러 공식](#501-사원수와-오일러-공식)
    * [50.2. 회전 사원수를 이용한 3차원 공간에서의 회전](#502-회전-사원수를-이용한-3차원-공간에서의-회전)
* [51. 사원수의 변환](#51-사원수의-변환)
    * [51.1. 오일러 각에서 사원수로의 변환](#511-오일러-각에서-사원수로의-변환)
    * [51.2. 사원수에서 오일러 각으로의 변환](#512-사원수에서-오일러-각으로의-변환)
    * [51.3. 사원수에서 회전 변환행렬로의 변환](#513-사원수에서-회전-변환행렬로의-변환)
    * [51.4. 회전 변환행렬에서 사원수로의 변환](#514-회전-변환행렬에서-사원수로의-변환)
* [52. 사원수의 보간](#52-사원수의-보간)

# 1. 수와 집합
게임을 구성하는 가상 세계를 이해하기 위한 첫걸음은 ***집합(Set)*** 이라는 개념으로 수를 이해하는 것이다.   
의무교육에서 배운 집합은 서로 구분되는 ***원소(Element)*** 로 구성된 묶음을 의미한다.  
이러한 집합론을 ***소박한 집합론(Native set theory)*** 이라고 한다.

소박한 집한론의 관점에서는 용도에 따라 수집합을 정의하여 구분하는데, 대표적으로는 자연수, 정수, 유리수, 실수, 복소수, 사원수 등이 있다.     
각 수집합은 [표 1-1](#표-1-1-다양한-수집합에-대응하는-기호)와 같이 인간의 언어를 통해 대상 집합을 구분할 수 있게 정의하고, 각 집합마다 고유한 기호를 사용한다.

###### 표 1-1 다양한 수집합에 대응하는 기호
|분류|정의|기호|
|---|---|---|
|자연수|물건을 세거나 순서를 지정하기 위해 사용하는 수의 집합|N|
|정수|자연수와 자연수의 음수 0을 포함하는 수의 집합|Z|
|유리수|분모가 0이 아닌 두 정수의 비율 혹은 분수로 나타낼 수 있는 집합|Q|
|무리수|두 정수 비 혹은 분수로 나타낼 수 있는 수의 집합|I|
|실수|유리수와 무리수를 포함하는 수의 집합|R|
|복소수|실수와 제곱하면 -1이 되는 허수 단위 $i$를 조합해 $a + bi$ ($a, b$는 실수) 형태로 표현하는 수의 집합|C|
|사원수|실수와 제곱하면 -1이 되는 세 허수 단위 $i, j, k$를 조합해 $a + bi + cj + dk$ ($a, b, c, d$는 실수) 형태로 표현하는 수의 집합|H|

이렇게 소박한 집합론으로 정의한 수집합의 관계는 다음 [그림 1-1](#그림-1-1-집합과-원소의-관계)과 같이 벤 다이어그램으로 도식화할 수 있다.

###### 그림 1-1 집합과 원소의 관계
![집합과 원소의 관계](/img/1-1집합과원소의관계.jpg)

소박한 집합론은 인간의 언어로 집합을 정의하기 때문에, ***보편적인 관념에 의존할 수밖에 없다***.   
예를 들어 자연수를 사용해 일상 생활에서 물건을 셀 때는 아무 불편함이 없지만, 자연수의 체계는 어떻게 구성되어 있고 집합의 특징이 무엇인지 분석하고 싶다면 물건을 센다는 개념부터 명확하게 정의해야 한다.  
수가 가지는 특징을 분석하고 이를 확장해 가상 공간이라는 고차원의 체계를 만들 수 있다.

이러한 작업을 위해서는 집합의 성질을 참과 거짓으로 명확하게 구분해 줄 수 있는 ***명제***가 필요하다.  
명제 중에서 ***증명할 필요가 없는 기본 명제***를 ***공리(Axiom)*** 라고 하는데, ***공리를 기반으로 대상을 구분하는 집합론***을 ***공리적 집합론(Axiomatic set theory)*** 이라고 한다.  
공리적 집합론에서는 ***수가 가지는 연산에 대한 공리를 기반으로 수를 분류한다***.  

# 1.1. 연산과 수의 구조
***수집합의 고유한 특징***은 ***원소를 이용해 연산***을 한다는 점이다.  
대표적인 연산으로는 덧셈, 뺄셈, 곱셈, 나눗셈의 사칙연산이 있으며, 이들은 두 개의 원소를 사용해 새로운 원소를 만들어내기 때문에 ***이항연산(Binary operation)*** 이라고도 한다.   
이항연산의 개념은 [그림 1-2](#그림-1-2-이항연산의-개념)과 같이 표현할 수 있다.

###### 그림 1-2 이항연산의 개념
![이항연산의 개념](/img/1-2이항연산의개념.jpg)

같은 집합에 속한 두 수를 투입한 이항연산의 결과가 항상 투입한 집합에 속한다면, 그 이항연산은 해당 ***집합에 대해 닫혀 있다(Closure)*** 고 한다.  
그리고 이항연산은 ***교환법칙(Commutative law)*** , ***결합법칙(Associative law)*** , ***분배법칙(Distributive law)*** 이라는 3가지 성질을 지닌다.

첫 번째로 교환법칙은 임의의 두 수 $a$와 $b$를 연산할 때 ***순서에 관계없이 항상 동일한 결과가 나오는 성질***을 말한다.
$$a + b = b + a$$

$$a \cdot b = b \cdot a$$

두 번째로 결합법칙은 ***연산이 두 번 이상 연속될 때, 앞의 연산을 먼저 계산한 결과와 뒤의 연산을 계산한 결과가 같은 성질***을 의미한다.
$$(a + b) + c = a + (b + c)$$

$$(a \cdot b) \cdot c = a \cdot (b \cdot c)$$

세 번째로 분배법칙은 ***서로 다른 2가지 연산***에 대해 다음의 규칙이 성립되는 것이다.
$$a \cdot (b + c) = a \cdot b + a \cdot c$$

$$(b + c) \cdot a = b \cdot a + c \cdot a$$

여기서 1번 식은 ***좌분배법칙***, 2번 식은 ***우분배법칙***이라고 하는데, 이 두 가지를 모두 만족하면 분배법칙을 만족한다고 한다.

닫혀 있다는 개념과 세 가지 연산의 성질에 이어, 이항연산이 가지는 특징은 ***항등원(Identity)*** 과 ***역원(Inverse)*** 이다.   
항등원이란 ***임의의 수와의 연산 결과를 항상 동일한 수로 만들어주는 특별한 수다***.     
[그림 1-3](#그림-1-3-항등원의-개념)에서 원소 $b$는 항등원이다.

###### 그림 1-3 항등원의 개념
![항등원의 개념](/img/1-3항등원의개념.jpg)

실수 집합 R에서의 덧셈 연산을 예로 들어보자.    
실수 집합에서 덧셈의 항등원이란 다음 식 1과 같이 미지수 $a$에 항등원 $b$를 더했을 때 결괏값이 $a$ 그대로 나오는 수를 의미하므로, ***덧셈의 항등원은 0***이 된다.  
그렇다면 실수 집합에서 ***곱셈의 항등원은 1***이 되는 것도 유추할 수 있다.
$$a + 0 = a$$

$$a \cdot 1 = a$$

역원이란 ***임의의 수와의 연산 결과를 항상 항등원으로 만들어주는 특별한 수다***.    
항등원과 역원의 개념을 비교하면 [그림 1-4](#그림-1-4-항등원과-역원-개념의-비교)와 같다.

###### 그림 1-4 항등원과 역원 개념의 비교
![항등원과 역원 개념의 비교](/img/1-4항등원과역원개념의비교.jpg)

이항연산에 사용하는 임의의 수를 $a$로 지정했을 때, 결과가 항등원이 되는 덧셈과 곱셈의 역원은 각각 다음과 같다.
$$a + (-a) = 0$$

$$a \cdot \frac{1}{a} = 1$$

***항등원은 덧셈이나 곱셈에 대해 각각 0과 1로 고정***되어 있지만 ***역원은 덧셈이나 곱셈에 주어진 수에 따라 그 값이 달라진다***.    
이러한 역원은 연산에 따라 일정한 패턴을 보인다.     
즉 덧셈 역원은 주어진 수에서 항상 부호가 반대인 수가 되므로 ***반대수(Opposite number)*** 라고 부른다. 
또한 곱셈 역원은 분자가 1이고 분모는 주어진 수가 되므로 ***역수(Reciprocal)*** 라고도 일컫는다.    
단 ***분모가 0이 되는 분수는 존재하지 않으므로 0의 곱셈 역원은 없다***.

이항연산의 성질을 정리하면 [표 1-2](#표-1-2-이항연산의-성질)와 같다.

###### 표 1-2 이항연산의 성질
|성질|정의|
|---|---|
|닫혀 있음|어떤 집합에서 두 원소를 사용한 이항연산의 결과가 항상 그 집합에 속하는 성질|
|교환법칙|두 원소의 좌우 순서를 바꿔도 결과가 동일한 성질|
|결합법칙|세 원소의 연산 순서를 바꿔도 결과가 동일한 성질|
|분배법칙|두 이항연산에 대해 $a \cdot (b + c) = a \cdot b + a \cdot c$와 $(b + c) \cdot a = b \cdot a + c \cdot a$의 결과가 나오는 성질|
|항등원|주어진 원소와의 이항연산 결과가 언제나 주어진 원소가 되는 특별한 원소. 실수에서 덧셈의 항등원은 0이고 곱셈의 항등원은 1이다.|
|역원|주어진 원소와의 이항연산 결과가 언제나 항등원이 되는 특별한 원소. 실수에서 덧셈의 역원은 반대수. 곱셈의 역원은 역수라고 부른다.|

# 1.2. 수의 구조
이항연산의 성질을 바탕으로 공리를 구축하고, 공리를 사용해 기존의 수집합을 새롭게 분류한다.

1. 연산에 대해 닫혀 있다.
2. 연산에 대해 결합법칙이 성립한다.
3. 연산에 대한 항등원이 존재한다.
4. 연산에 대한 역원이 존재한다.
5. 연산에 대해 교환법칙이 성립한다.

정수 집합 Z의 구조를 이와 같은 공리 체계에서 분석하면, 정수의 덧셈(+)은 위 공리를 모두 만족한다.    
정수끼리 더한 결과는 항상 정수에 속하고, 결합법칙이 성립하면서 항등원 0과 임의의 수 $a$에 대한 역원 $-a$가 언제나 존재하기 때문이다.    
그러나 정수의 뺄셈(-)은 위 공리를 모두 만족하지 못한다.     
뺄셈은 교환법칙이 성립하지 않기 때문이다.

연산을 하나 더 추가해, 두 개의 연산에 대한 공리를 생각해보자.

6. 두 번째 연산에 대해 닫혀 있다.
7. 두 번째 연산에 대해 결합법칙이 성립한다.
8. 첫 번째 연산과 두 번째 연산에 대해 분배법칙이 성립한다.
9. 두 번째 연산에 대해 교환법칙이 성립한다.
10. 두 번째 연산에 대해 항등원이 존재한다.
11. 두 번째 연산에 대해 역원이 존재한다(단 0은 제외).

정수 집합 Z에 곱셈 연산을 추가하고 이와 같은 공리를 만족하는지 살펴보자.    
정수 집합은 곱셈에 닫혀 있고, 결합법칙과 분배법칙이 성립하며 교환법칙도 성립한다.   
하지만 정수 집합의 원소 $a$에 대한 곱셈의 역원은 $\frac{1}{a}$인데 이는 정수가 아니기 때문에 11번의 공리를 만족하지 못한다.     
따라서 정수 집합의 덧셈과 곱셈은 이들 공리를 모두 만족하지 못한다.

덧셈과 곱셈 연산에 대해 11가지 공리를 모두 만족하는 수 집합은 어떤 것이 있는지 생각해보자.  
***덧셈에 대한 역원이 존재하지 않는 자연수(N)*** 와 ***곱셈에 대한 역원이 존재하지 않는 정수(Z)*** 는 이를 만족하지 못한다.   
하지만 ***유리수(Q)*** , ***실수(R)*** 는 ***곱셈의 역원이 존재***하기 때문에 덧셈과 곱셈 두 연산에 대해 앞서 열거한 11가지 공리를 모두 만족한다.

***공리적 집합론에서 두 연산에 대해 1번부터 11번까지의 공리를 모두 만족하는 수 집합은 체(Field)의 구조를 지닌다고 표현한다***.    
유리수(Q), 실수(R)와 같이 ***체의 구조를 가지는 수 집합은 특별한 예외 상황 없이 덧셈과 곱셈을 안전하고 자유롭게 사용할 수 있다***고 볼 수 있다.   
콘텐츠를 담는 가상 세계를 구축하기 위해서 특정한 수 집합을 지정해 사용하는 것이 아닌, 체의 구조를 기반으로 체계를 확장해 공간의 구조를 생성한다.

사칙 연산을 구성하는 나머지 연산인 뺄셈과 나눗셈은 체의 구조를 만족하는지 살펴보자.     
***뺄셈과 나눗셈은 교환법칙을 만족하지 않기 때문에 체의 구조를 지니지 못한다***.
$$a - b \neq b - a$$

$$a \div b \neq b \div a$$

이에 대한 해결책은 ***뺄셈 대신 덧셈의 역원을 사용***하고 ***나눗셈 대신 곱셈의 역원을 사용***하는 것이다.

실수 집합에서 덧셈의 역원은 반대수, 곱셈의 역원은 역수였다.     
뺄셈과 나눗셈 대신 덧셈과 곱셈의 역원을 사용하면 교환법칙이 성립하면서 같은 결과를 만들어낸다.
$$a + (-b) = (-b) + a$$

$$a \cdot \frac{1}{b} = \frac{1}{b} \cdot a$$

그렇기 때문에 수 집합의 구조를 분석할 때는 덧셈과 곱셈의 두 가지 연산에 대해서만 살펴보는 것으로 충분하다.

정리하면, ***체는 사칙연산이 자유로이 시행될 수 있고 산술의 잘 알려진 규칙들을 만족하는 수의 구조다***.     

# 1.3. 수의 표현
실수(R)를 대응시켜 표현한 직선을 수직선(Number line)이라 하며 [그림 1-5](#그림-1-5-수직선의-예)과 같이 표현한다.    
> 참고: 수를 표현하는 수직선(Number line)은 직각으로 만나는 직선을 의미하는 수직선(Perpendicular line)과 동음이의어다.

###### 그림 1-5 수직선의 예
![수직선의 예](/img/1-5수직선의예.jpg)

실수의 모든 요소는 상호 간에 크기를 비교할 수 있다.     
***더 큰 수는 오른쪽에 표시하는 규칙을 사용해 실수의 모든 원소는 수직선 상에 자신의 고유한 위치를 갖게 된다***.   
따라서 하나의 실수를 시각화할 때는 그 수의 고유한 위치에 점을 찍어 표현한다.    
[그림 1-6](#그림-1-6-점으로-수를-표현하는-방법)에서는 -2보다 큰 수 2가 수직선에서 오른쪽에 위치함을 알 수 있다.

###### 그림 1-6 점으로 수를 표현하는 방법
![점으로 수를 표현하는 방법](/img/1-6점으로수를표현하는방법.jpg)

***수직선은 0을 기준으로 양수와 음수라는 두 개의 체계가 서로 대칭되어 있는 것으로 해석할 수 있다***.  
이러한 관점에서 하나의 수는 [그림 1-7](#그림-1-7-화살표로-수를-표현하는-방법)과 같이 원점에서부터 크기와 방향을 가진 화살표로도 표현할 수 있다.

###### 그림 1-7 화살표로 수를 표현하는 방법
![화살표로 수를 표현하는 방법](/img/1-7화살표로수를표현하는방법.jpg)

이와 같이 수가 지니는 방향의 속성은 부호를 사용해 나타내며 크기의 속성은 원점으로부터의 거리를 의미한다.    
***어떤 수의 원점으로부터의 거리는 수직 막대(Vertical bar) 기호를 써서 나타내는데, 이를 절댓값(Absolute value)이라고 한다***.
$$|-3| = 3$$

***물체에 힘을 가해 이동하거나, 크기를 늘리는 작업은 덧셈과 곱셈 연산으로 해석할 수 있다***.  
이항연산에서 왼쪽 항의 수를 물체를 구성하는 점으로 보고, 오른쪽 항의 수를 점을 이동시키는 힘으로 보면 덧셈 연산은 [그림 1-8](#그림-1-8-점의-이동으로-표현하는-덧셈-연산)과 같이 점을 평행 이동시키는 작업으로 해석할 수 있다.    
예를 들면 어떤 수와 -5와의 합은 수의 위치를 왼쪽 방향으로 5칸만큼 이동시키는 작업이고, 2와의 합은 오른쪽 방향으로 2칸만큼 이동시키는 작업이다.

###### 그림 1-8 점의 이동으로 표현하는 덧셈 연산
![점의 이동으로 표현하는 덧셈 연산](/img/1-8점의이동으로표현하는덧셈연산.jpg)

그리고 곱셈 연산은 [그림 1-9](#그림-1-9-크기와-방향의-변화로-표현하는-곱셈-연산)와 같이 원점을 기준으로 점의 위치를 지정된 배율만큼 늘리고 대칭시키는 작업으로 해석할 수 있다.  
예를 들면 어떤 수와 2의 곱은 원점으로부터 거리를 같은 방향으로 2배로 키우는 작업이고, -2와의 곱은 원점으로부터 거리를 2배로 늘린 후 반대쪽으로 대칭시키는 작업으로 볼 수 있다.  
왼쪽 항의 수가 가진 크기를 오른쪽 수가 가진 크기의 배율로 늘리거나 줄인 후 오른쪽 수의 부호가 양의 부호인 경우 원 방향을 유지하고, 음수인 경우 반대 방향으로 대칭시키는 작업이 곱셈 연산이다.

###### 그림 1-9 크기와 방향의 변화로 표현하는 곱셈 연산
![크기와 방향의 변화로 표현하는 곱셈 연산](/img/1-9크기와방향의변화로표현하는곱셈연산.jpg)

# 2. 함수
***함수(Function)란 두 집합에서 첫 번째 집합의 모든 원소가 빠짐없이 두 번째 집합의 어떤 원소에 대응하는 관계를 의미한다***.

# 2.1. 함수의 개념과 종류
두 집합을 $X$와 $Y$라는 기호로 지정하고, 집합 $X$의 원소를 $x$, 집합 $Y$의 원소를 $y$라 할 때 $X$에서 $Y$로 대응되는 함수를 $y = f(x)$로 나타낸다.  
두 집합의 대응 관계는 [그림 1-10](#그림-1-10-함수의-개념과-기호)과 같다.

###### 그림 1-10 함수의 개념과 기호
![함수의 개념과 기호](/img/1-10함수의개념과기호.jpg)

두 집합의 요소가 서로 대응된다고 모두 함수로 인정받는 것은 아니고, 다음 두 규칙이 성립돼야 한다.

1. 첫 번째 집합의 모든 원소에 대한 대응 관계가 존재해야 함
2. 첫 번째 집합의 원소는 두 번째 집합의 원소에만 대응되어야 함

[그림 1-11](#그림-1-11-함수가-아닌-두-집합의-대응-관계)을 예시로 보면, 집합 $X$의 원소 중 3과 4는 대응 관계가 없고 원소 2는 집합 $Y$의 두 원소($B$와 $C$)에 대응된다.     
따라서 예시에서 나타난 두 집합의 대응 관계는 함수가 아니다.

###### 그림 1-11 함수가 아닌 두 집합의 대응 관계
![함수가 아닌 두 집합의 대응 관계](/img/1-11함수가아닌두집합의대응관계.jpg)

왼쪽의 집합과 오른쪽의 집합이 가져야 하는 조건이 다르기 때문에 함수에서 정의된 용어를 사용해 두 집합이 가진 대응 관계를 명확하게 전달해야 한다.     
***함수에서 왼쪽에 위치한 첫 번째 집합을 정의역(Domain)이라고 하고, 오른쪽에 위치한 두 번째 집합을 공역(Codomain)이라 한다***.

함수 용어를 사용해 대응 관계를 표현한다면, ***정의역의 모든 원소는 공역의 원소에 대응되어야 한다***.  
하지만 ***공역의 모든 원소가 정의역에 대응할 필요는 없다***.  
그렇기 때문에 ***정의역에 대응되는 공역의 원소만 따로 모아 부분집합(Subset)을 형성할 수 있는데, 이를 치역(Range)이라고 부른다***.     
[그림 1-12](#그림-1-12-정의역-공역-치역의-개념)는 정의역, 공역, 치역의 개념과 관계를 표현한다.

###### 그림 1-12 정의역, 공역, 치역의 개념
![정의역, 공역, 치역의 개념](/img/1-12정의역,공역,치역의개념.jpg)

또한 ***함수에 사용하는 정의역의 요소를 입력(Input), 입력에 대응하는 공역의 요소를 출력(Output)이라고 한다***.    
이러한 함수의 개념은 [그림 1-13](#그림-1-13-함수의-개념을-기계로-표현하기)과 같은 형태로도 표현할 수 있다.

###### 그림 1-13 함수의 개념을 기계로 표현하기
![함수의 개념을 기계로 표현하기](/img/1-13함수의개념을기계로표현하기.jpg)

정의역과 공역이 서로 대응되는 형태에 따라 함수를 여러 종류로 구분할 수 있다.

## 전사함수
***전사함수(Surjection)는 공역의 모든 요소가 정의역에 대응되는 함수를 의미한다***.    
[그림 1-14](#그림-1-14-전사함수의-예시)와 같이 공역과 치역이 동일한 함수다.   
> 참고: 위로의 함수(Onto)라고도 부름

###### 그림 1-14 전사함수의 예시
![전사함수의 예시](/img/1-14전사함수의예시.jpg)

[그림 1-15](#그림-1-15-전사함수가-아닌-예시)는 공역과 치역이 서로 다르므로 전사함수가 아니다.

###### 그림 1-15 전사함수가 아닌 예시
![전사함수가 아닌 에시](/img/1-15전사함수가아닌예시.jpg)

## 단사함수
***단사함수(Injection)는 정의역과 공역의 요소가 일대일로 대응되는 함수를 의미한다***.     
[그림 1-16](#그림-1-16-단사함수-예시)은 정의역의 모든 요소가 공역의 요소에 일대일로 대응되므로 단사함수다.
> 참고: 일대일 함수(One-to-One)라고도 부름

###### 그림 1-16 단사함수 예시
![단사함수 예시](/img/1-16단사함수예시.jpg)

[그림 1-17](#그림-1-17-단사함수가-아닌-예시)은 정의역의 두 요소가 공역의 한 요소에 대응되기 때문에 일대일 대응이 아니므로 단사함수가 아니다.

###### 그림 1-17 단사함수가 아닌 예시
![단사함수가 아닌 예시](/img/1-17단사함수가아닌예시.jpg)

## 전단사함수
***전단사함수(Bijection, One-to-One and Onto)는 정의역과 공역의 모든 요소가 빠짐없이 일대일로 대응되는 함수를 의미한다***.    
[그림 1-18](#그림-1-18-전단사함수-예시)과 같이 전사함수와 단사함수의 두 가지 성질을 모두 만족하면 전단사함수라 할 수 있다.

###### 그림 1-18 전단사함수 예시
![전단사함수 예시](/img/1-18전단사함수예시.jpg)

# 2.2. 합성함수
함수의 대응 관계를 확장해 다수 집합의 대응 관계로 발전시킬 수도 있다.   
***2개의 함수를 연쇄적으로 이어서 하나의 함수로 만드는 연산을 함수의 합성(Function composition)이라 한다***.  
[그림 1-19](#그림-1-19-합성함수의-예시)와 같이 세 집합 $X, Y, Z$ 사이에 두 함수 $f(x)$와 $g(y)$가 존재하는 상황을 가정해보자.

###### 그림 1-19 합성함수의 예시
![합성함수의 예시](/img/1-19합성함수의예시.jpg)

두 함수 $f(x)$와 $g(y)$를 연쇄적으로 이어 합성함수를 만들면, [그림 1-20](#그림-1-20-합성함수의-결과)과 같이 중간에 위치한 집합 $Y$를 생략하고 집합 $X$와 $Z$의 직접적인 대응 관계를 표현할 수 있다.   
이러한 합성함수는 $g \circ f$ 혹은 $g(f(x))$로 표시한다.    
***먼저 실행되는 함수 $f$가 합성함수 기호($\circ$)의 오른쪽에 놓인다는 점에 유의해야 한다***.     
> 참고: 합성함수는 $g \circ f$는 $g$ 써클 $f$로 부르는데, 대응 순서에 맞춰서 $g$ 애프터 $f$라고도 부른다.

###### 그림 1-20 합성함수의 결과
![합성함수의 결과](/img/1-20합성함수의결과.jpg)

이번에는 [그림 1-21](#그림-1-21-4개-집합과-3개-함수로-구성된-대응-관계)과 같이 집합과 함수를 하나씩 더 추가한 대응 관계를 생각해보자.

###### 그림 1-21 4개 집합과 3개 함수로 구성된 대응 관계
![4개 집합과 3개 함수로 구성된 대응 관계](/img/1-21-4개집합과3개함수로구성된대응관계.jpg)

이 상황에서는 두 합성함수에 대한 경우의 수를 [그림 1-22](#그림-1-22-세-함수로부터-만들어지는-두-합성함수에-대한-경우의-수)의 (a)와 (b)와 같이 생각할 수 있다.

###### 그림 1-22 세 함수로부터 만들어지는 두 합성함수에 대한 경우의 수
![세 함수로부터 만들어지는 두 합성함수에 대한 경우의 수](/img/1-22세함수로부터만들어지는두합성함수에대한경우의수.jpg)

[그림 1-22](#그림-1-22-세-함수로부터-만들어지는-두-합성함수에-대한-경우의-수)의 (a)와 (b)의 두 합성함수가 남은 함수와 다시 합성하는 경우는 각각 [그림 1-23](#그림-1-23-합성함수의-합성-결과)의 (a)와 (b)와 같이 전개될 것이다.

###### 그림 1-23 합성함수의 합성 결과
![합성함수와의 합성 결과](/img/1-23합성함수와의합성결과.jpg)

[그림 1-23](#그림-1-23-합성함수의-합성-결과)의 (a)와 (b)의 결과는 동일한 대응 관계를 가짐을 볼 수 있다.  
***합성 함수를 이항연산으로 규정하면, 합성 함수는 결합법칙이 성립한다***.

# 2.3. 항등함수와 역함수
수의 연산에서 다룬 항등원, 역원과 동일한 개념이 함수에도 존재한다.  
[그림 1-24](#그림-1-24-항등함수의-예시)와 같이 ***정의역과 공역이 동일한 값으로 대응되는 함수를 항등함수(Identity function)라고 하며 기호 $id$로 나타낸다***.

###### 그림 1-24 항등함수의 예시
![항등함수의 예시](/img/1-24항등함수의예시.jpg)

항등함수는 [1.1. 연산과 수의 구조](#11-연산과-수의-구조)에서 배운 연산의 항등원과 동일한 역할을 수행한다.  
합성함수를 사용해 함수에 연산의 개념을 도입하면 세 집합의 대응 관계는 [그림 1-25](#그림-1-25-항등함수를-사용한-합성함수)와 같이 표현할 수 있다.

###### 그림 1-25 항등함수를 사용한 합성함수
![항등함수를 사용한 합성함수](/img/1-25항등함수를사용한합성함수.jpg)

(a)를 수식으로 나타내면 $id \circ f = f$이고 (b)를 수식으로 나타내면 $f \circ id = f$가 되는데 ***항등함수는 어느 위치에 있든지 합성의 결과는 원 함수와 동일한 대응 관계를 나타낸다***.

수의 역원 개념과 동일하게 합성함수의 대응 결과가 항등함수가 되는 경우를 생각해 보자.    
[그림 1-26](#그림-1-26-합성함수의-결과가-항등함수가-되는-경우)의 (a)와 같은 대응 관계가 있다고 생각한다면, 이를 합성해 간추린 결과는 (b)와 같이 서로 동일한 원소끼리 대응될 것이다.

###### 그림 1-26 합성함수의 결과가 항등함수가 되는 경우
![합성함수의 결과가 항등함수가 되는 경우](/img/1-26합성함수의결과가항등함수가되는경우.jpg)

[그림 1-26](#그림-1-26-합성함수의-결과가-항등함수가-되는-경우)의 (a)의 $g(y)$와 같은 함수를 역함수(Inverse function)라고 한다.     
***역함수는 위 첨자를 붙여 $f^{-1}$로 표기***하며 어떤 함수와 역함수를 합성한 결과는 (b)와 같이 언제나 항등함수가 된다.   
이를 수식으로 나타내면 다음과 같다.
$$f^{-1} \circ f = id$$

$$f \circ f^{-1} = id$$

***역함수는 두 집합의 대응 관계를 뒤집어 공역 $Y$에서 정의역 $X$로 대응하는 함수로도 생각할 수 있다***.   
이 개념을 도식화하면 [그림 1-27](#그림-1-27-역함수의-개념과-기호)과 같다.

###### 그림 1-27 역함수의 개념과 기호
![역함수의 개념과 기호](/img/1-27역함수의개념과기호.jpg)

***역함수에서 주의할 점은 모든 함수가 역함수를 갖지는 않는다는 사실이다***.   
[그림 1-28](#그림-1-28-전사함수와-단사함수의-역함수)의 (a)에서 보여지는 전사함수는 하나의 원소가 두 개의 원소에 대응되기 때문에 함수의 기본 조건을 만족하지 못하고, (b)의 단사함수는 정의역의 모든 원소가 대응하지 않기 때문에 이들의 역함수는 함수의 조건을 만족하지 못한다.

###### 그림 1-28 전사함수와 단사함수의 역함수
![전사함수와 단사함수의 역함수](/img/1-28전사함수와단사함수의역함수.jpg)

하지만 전단사함수의 경우에는 [그림 1-29](#그림-1-29-전단사함수의-역함수)과 같이 모든 경우에서 함수의 조건을 만족하기 때문에 역함수가 보장된다.    
***어떤 함수가 역함수를 가지기 위해서는 반드시 전단사함수의 형태가 되어야 한다***.

###### 그림 1-29 전단사함수의 역함수
![전단사함수의 역함수](/img/1-29전단사함수의역함수.jpg)

합성함수에 역함수의 개념을 적용해보자.  
[그림 1-30](#그림-1-30-합성함수의-예시)의 (a)에 세 집합 $X, Y, Z$ 대상으로 생성된 두 전단사함수 $f, g$를 나타냈다.    
이를 합성한 결과는 (b)가 될 것이다.

###### 그림 1-30 합성함수의 예시
![합성함수의 예시](/img/1-30합성함수의예시.jpg)

여기서 [그림 1-30](#그림-1-30-합성함수의-예시)의 (b)의 합성함수 $g \circ f$를 거꾸로 뒤집은 역함수 $(g \circ f)^{-1}$는 [그림 1-31](#그림-1-31-합성함수의-역함수)과 같은 대응관계를 가진다고 볼 수 있다.

###### 그림 1-31 합성함수의 역함수
![합성함수의 역함수](/img/1-31합성함수의역함수.jpg)

이는 [그림 1-32](#그림-1-32-합성함수의-역함수의-분석)와 같이 두 함수의 역함수 $f^{-1}$과 $g^{-1}$ 반대 순서로 합성한 결과로 볼 수 있다.

###### 그림 1-32 합성함수의 역함수의 분석
![합성함수의 역함수의 분석](/img/1-32합성함수의역함수의분석.jpg)

이러한 합성함수의 역함수가 가지는 성질은 아래와 같은 식으로 정리된다.
$$(g \circ f)^{-1} = f^{-1} \circ g^{-1}$$

# 2.4. 곱집합을 활용한 좌표 평면으로의 확장
***곱집합(Cartesian product 혹은 Product set)이란 두 집합의 원소를 순서쌍으로 묶은 원소의 집합을 의미한다***.     
두 집합 $A$와 $B$가 있고 각 집합에 속한 원소를 $a$와 $b$라고 했을 때 집합 $A$와 $B$의 곱집합은 다음과 같이 표현한다.
$$A \times B$$

***곱집합은 두 집합 $A$와 $B$의 요소를 서로 수직으로 배치해 묶는다***.    
[그림 1-33](#그림-1-33-곱집합의-예시)은 무늬 집합 $A$와 순위 집합 $B$를 곱집합으로 묶은 카드 배열을 나타낸 예시다.

###### 그림 1-33 곱집합의 예시
![곱집합의 예시](/img/1-33곱집합의예시.png)

곱집합의 요소는 각 집합의 원소 $a$와 $b$를 다음의 순서쌍으로 묶어 표현한다.
$$(a, b)$$

곱집합의 개념은 앞서 설명한 수의 이항연산 개념을 설명하는 데에도 사용할 수 있다.    
두 실수 집합의 곱집합 $R \times R$을 구성하고 [그림 1-34](#그림-1-34-이항연산의-함수-표현)와 같이 정의역으로 설정해 입력 요소를 2개로 지정하면, 수의 이항연산을 함수로 표현하는 것이 가능해진다.

###### 그림 1-34 이항연산의 함수 표현
![이항연산의 함수 표현](/img/1-34이항연산의함수표현.jpg)

또한 두 집합을 서로 수직으로 배치하는 곱집합의 성질을 응용하면, 하나의 직선으로 표현한 실수 집합 $R$을 확장해 두 실수 집합의 곱집합 $R \times R$을 [그림 1-35](#그림-1-35-직선으로-표현되는-수를-곱집합을-사용해-평면으로-확장한-결과)와 같이 평면으로 나타낼 수 있다.

###### 그림 1-35 직선으로 표현되는 수를 곱집합을 사용해 평면으로 확장한 결과
![직선으로 표현되는 수를 사용해 평면으로 확장한 결과](/img/1-35직선으로표현되는수를사용해평면으로확장한결과.jpg)

두 실수 집합의 곱집합으로 형성된 평면에 다시 실수 집합을 곱집합으로 설정하면 3차원 공간이 된다.

# 3. 데카르트 좌표계
실수와 실수의 곱집합을 사용해 직선으로 표현되는 영역을 평면으로 확장해 표현할 수 있었다.    
***이렇게 직선의 수 집합을 수직으로 배치해 평면을 표기하는 방식을 데카르트 좌표계(Cartesian coordinate system)라고 부른다***. 

데카르트 좌표계는 [그림 2-1](#그림-2-1-데카르트-좌표계)과 같이 수평으로 배치한 첫 번째 실수 집합의 미지수를 $x$, 수직으로 배치한 두 번째 실수 집합의 미지수를 $y$로 표기하고 원점을 기준으로 $x$축의 오른편, $y$축의 위편은 양의 영역을 나타낸다.  
이렇게 배치된 두 실수 집합으로 평면을 가르면 평면의 영역은 총 4개의 분면으로 나뉘는데, 오른쪽 상단에서부터 반시계 반향으로 [그림 2-1](#그림-2-1-데카르트-좌표계)과 같이 이름을 붙인다.

###### 그림 2-1 데카르트 좌표계
![데카르트 좌표계](/img/2-1데카르트좌표계.jpg)

***데카르트 좌표계의 한 원소는 곱집합과 동일하게 순서쌍으로 표현하며 좌표(Coordinate)라고 부른다***.
$$(x, y)$$

일반적으로 좌표는 수와 동일하게 [그림 2-2](#그림-2-2-좌표의-시각화-방법)와 같이 점 또는 원점으로부터의 화살표로 표현한다.     
***좌표는 크기와 방향 두 가지 속성을 지닌다***.

###### 그림 2-2 좌표의 시각화 방법
![좌표의 시각화 방법](/img/2-2좌표의시각화방법.jpg)

# 4. 벡터 공간과 벡터
# 4.1. 스칼라와 벡터
평면의 좌표 $(x, y)$는 두 실수 $x$와 $y$를 결합해 만들어진다.   
그렇기 때문에 ***좌표의 연산은 실수가 지니는 연산의 성질을 바탕으로 설계돼야 한다***.     
***실수의 연산 성질은 체의 구조를 띤다***.    
이를 기반으로 새로운 공리를 덧붙여서 평면을 대표하는 집합을 규정하고, 해당 집합에서 이뤄지는 덧셈과 곱셈 연산 체계를 만들어야 평면에서의 움직임을 표현할 수 있다.

***두 개 이상의 실수를 곱집합으로 묶어 형성된 집합을 공리적 집합론의 관점에서 규정한 것***을 ***벡터 공간(Vector space)*** 이라고 하며, ***벡터 공간의 원소를 벡터(Vector)라고 한다***.    
공리적 집합론의 관점에서는 ***특정한 수 집합을 지칭하지 않고 연산이 갖는 성질***만 다루기 때문에, 좌푯값으로 사용하는 $x$와 $y$를 실수로 규정하기보다는 ***체의 구조를 지니는 집합, 즉 체 집합의 원소로 규정한다***.    
이렇게 ***체의 구조를 가지는 수 집합의 원소를 스칼라(Scalar)라고 부른다***.   
즉 좌표로 사용하는 실수 $x$와 $y$는 모두 공리적 집합론의 관점에서 스칼라인 것이다.   
집합의 개념인 벡터 공간을 표기할 때에는 주로 대문자 $V$를 사용하고, 이의 원소인 벡터는 소문자 $\vec{v}$로 표기한다.     
벡터는 다음과 같이 좌표와 동일한 방법으로 표기한다.
$$\vec{v} = (x, y)$$

# 4.2. 벡터 공간의 연산
공리적 집합론의 관점에서 정의된 벡터 공간은 두 가지 기본 연산이 존재한다.   
다음의 수식에서 사용되는 수 $a, x, y$는 모두 체 집합의 원소인 스칼라다.

1. 벡터와 벡터의 덧셈(줄여서 벡터의 합으로 부름)
$$\vec{v_1} + \vec{v_2} = (x_1, y_1) + (x_2, y_2) = (x_1 + x_2, y_1 + y_2)$$
2. 스칼라와 벡터의 곱셈(줄여서 스칼라 곱셈이라 부름)
$$a \cdot \vec{v} = a \cdot (x, y) = (a \cdot x, a \cdot y)$$

체가 갖는 연산의 성질에 기반해 벡터 공간의 연산이 갖는 성질은 [표 2-1]과 같이 8가지로 정리할 수 있다.   
이를 '벡터 공간의 공리'라고 한다.

###### 표 2-1 벡터 공간의 8가지 공리
|No|분류|공리|수식|
|---|---|---|---|
|1|벡터의 합|벡터의 합의 결합법칙|$\vec{u} + (\vec{v} + \vec{w}) = (\vec{u} + \vec{v}) + \vec{w}$|
|2|벡터의 합|벡터의 합의 교환법칙|$\vec{u} + \vec{v} = \vec{v} + \vec{u}$|
|3|벡터의 합|벡터의 합의 항등원|$\vec{v} + \vec{0} = \vec{v}$|
|4|벡터의 합|벡터의 합의 역원|$\vec{v} + (-\vec{v}) = \vec{0}$|
|5|스칼라 곱셈|스칼라 곱셈의 호환성|$a(b\vec{v}) = (ab)\vec{v}$|
|6|스칼라 곱셈|스칼라 곱셈의 항등원|$1 \cdot \vec{v} = \vec{v}$|
|7|스칼라 곱셈|벡터의 합에 대한 분배법칙|$a(\vec{u} + \vec{v}) = a\vec{u} + a\vec{v}$|
|8|스칼라 곱셈|스칼라 덧셈에 대한 분배법칙|$(a + b)\vec{v} = a\vec{v} + b\vec{v}$|

> 참고: 벡터와 스칼라의 곱을 표현하기 위해 스칼라 곱셈은 스칼라배(Scalar倍)라고도 불린다.   
스칼라곱은 스칼라 곱셈과 다른 연산이며 내적을 의미한다.

[표 2-1](#표-2-1-벡터-공간의-8가지-공리)에 열거한 ***벡터 공간의 공리***는 모두 ***체의 공리***를 기반으로 하기 때문에 해당 공리가 참임을 바로 파악할 수 있다.  
예를 들어 ***벡터의 합이 교환법칙을 만족하는 까닭은 두 스칼라의 덧셈이 교환법칙을 만족하기 때문이다***.
$$\vec{v_1} + \vec{v_2} = (x_1, y_1) + (x_2, y_2) = (x_1 + x_2, y_1 + y_2)$$

$$\vec{v_2} + \vec{v_1} = (x_2, y_2) + (x_1, y_1) = (x_2 + x_1, y_2 + y_1)$$

$$\therefore \vec{v_1} + \vec{v_2} = \vec{v_2} + \vec{v_1}$$

벡터의 이항 연산에서 왼쪽의 벡터는 물체를 구성하는 점으로, 오른쪽의 벡터는 점을 이동시키는 힘으로 연산을 시각화하면 [그림 2-3](#그림-2-3-벡터의-합-연산을-시각화한-예시)과 같다.    
벡터의 합 연산은 평면의 점을 각 축에 대해 독립적으로 평행 이동시키는 작업으로 해석할 수 있다.

###### 그림 2-3 벡터의 합 연산을 시각화한 예시
![벡터의 합 연산을 시각화한 예시](/img/2-3벡터의합연산을시각화한예시.jpg)

***스칼라 곱셈으로 생성된 벡터는 원점을 지나고 벡터와 평행한 직선상에 위치한다***.    
따라서 스칼라 곱셈의 결과는 항상 [그림 2-4](#그림-2-4-스칼라-곱셈-연산을-시각화한-예시)에서 붉은색으로 표현한, 원점을 지나는 직선상의 벡터를 만들어낸다.

###### 그림 2-4 스칼라 곱셈 연산을 시각화한 예시
![스칼라 곱셈 연산을 시각화한 예시](/img/2-4스칼라곱셈연산을시각화한예시.jpg)

# 4.3. 벡터의 크기와 이동
[1.3. 수의 표현](#13-수의-표현)에서 수의 크기는 원점으로부터의 거리를 의미하며 절댓값 기호($| |$)를 사용해 구할 수 있었다.  
***벡터의 크기***도 동일하게 ***원점으로부터의 최단 거리***를 의미한다.     
이를 측정하려면 [그림 2-5](#그림-2-5-벡터-4-3의-크기-측정)와 같이 ***원점과 벡터를 연결해 직각삼각형을 그린 후, 피타고라스 정리를 사용해 거리를 측정한다***.
$$c^2 = a^2 + b^2$$

$$\therefore c = \sqrt{a^2 + b^2}$$

###### 그림 2-5 벡터 (4, 3)의 크기 측정
![벡터 (4, 3)의 크기 측정](/img/2-5벡터(4,3)의크기측정.jpg)

이렇게 측정된 ***벡터의 크기 역시 절댓값 기호와 동일하게 수직 막대($| |$)를 사용한다***.  
벡터 $(x, y)$의 크기를 구하는 공식은 다음과 같다.
$$||\vec{v}|| = |\vec{v}| = \sqrt{x^2 + y^2}$$

> 참고: 일반적으로 벡터의 크기는 두 개의 수직 막대 기호 $||$로 표기한다.

벡터의 크기는 ***노름(Norm)*** 이라는 용어로 부르기도 한다.    
***크기가 1인 벡터를 단위 벡터(Unit Vector)라고 한다***.  
단위 벡터는 벡터의 크기를 측정하는 기준이 되며, 벡터와 관련된 다양한 응용식을 전개하는 데 자주 사용된다.     
단위 벡터는 다음과 같이 ***모자 기호(Hat)*** 을 씌워 $\hat{v}$의 형태로 표시한다.  
***스칼라 곱셈의 성질을 이용해 임의의 벡터 $\vec{v}$를 이의 크기인 $|\vec{v}|$로 나누면 단위 벡터 $\hat{v}$를 얻을 수 있다***.    
이를 그림으로 나타내면 [그림 2-6](#그림-2-6-벡터의-크기를-1로-만드는-연산)과 같다.

###### 그림 2-6 벡터의 크기를 1로 만드는 연산
![벡터의 크기를 1로 만드는 연산](/img/2-6벡터의크기를1로만드는연산.jpg)

이와 같이 임의의 벡터 $\vec{v}$를 크기가 1인 단위 벡터 $\hat{v}$로 다듬는 작업을 ***정규화***한다(Normalize)고 부르며 수식은 다음과 같다.
$$\hat{v} = \frac{\vec{v}}{|\vec{v}|}$$

# 5. 벡터의 결합과 생성
***벡터 공간의 벡터의 합과 스칼라 곱셈 연산은 선형성이 있어 선형 연산이라고도 한다***.    
선형 연산을 사용해 $n$개의 스칼라 $a_1, ..., a_n$과 $n$개의 벡터 $\vec{v_1}, ..., \vec{v_n}$를 결합해 새로운 벡터 $\vec{v'}$을 생성하는 수식을 ***선형 결합(Linear combination)*** 이라고 한다.    
선형 결합의 수식은 다음과 같다.
$$a_1\vec{v_1} + a_2\vec{v_2} + a_3\vec{v_3} + ... + a_n\vec{v_n} = \vec{v'}$$

여기서 벡터의 모든 원소가 0으로 구성된 영벡터 $\vec{0}$을 생각했을 때 선형 결합의 결과가 $\vec{0}$이 나오는 수식을 생각해보면 다음과 같다.
$$a_1\vec{v_1} + a_2\vec{v_2} + a_3\vec{v_3} + ... + a_n\vec{v_n} = \vec{0}$$

***벡터에 곱하는 모든 스칼라 값이 0이면 선형 결합의 결과는 항상 영벡터가 된다***.     
$a$값이 0이 아닌 경우에도 영벡터는 나올 수 있다.
$$2 \cdot (1, 1) + (-1) \cdot (2, 2) = (0, 0)$$

이 식과 같이 ***모든 $a$가 0이 아님에도 영벡터를 만들 수 있다***면, 선형 결합에 사용된 벡터는 서로 '***선형 종속의 관계***'를 가진다라고 표현한다.  
따라서 $(1, 1)$과 $(2, 2)$의 두 벡터는 선형 종속인 관계를 갖는다.

반면 ***영벡터가 나오기 위해서 모든 $a$값이 0이어야 한다***면 선형 결합에 사용된 벡터들은 서로 '***선형 독립의 관계***'를 가진다라고 표현한다.  
다음 수식에서 $(1, 2)$와 $(2, 1)$ 두 벡터가 결합할 때 영벡터가 나오려면 모든 스칼라 $a$의 값은 0이어야 한다.    
따라서 $(1, 2)$와 $(2, 1)$의 두 벡터는 선형 독립의 관계를 갖는다.
$$0 \cdot (1, 2) + 0 \cdot (2, 1) = (0, 0)$$

벡터 간의 선형적 관계는 벡터 공간을 다룰 때 중요하게 사용된다.  
***선형 독립의 관계를 가지는 벡터를 선형 결합하면 벡터 공간에 속한 모든 벡터를 생성***할 수 있기 때문이다.    
두 벡터 $\vec{u}, \vec{v}$와 두 스칼라 $a, b$를 결합해 새로운 벡터 $\vec{w}$를 생성하는 수식은 다음과 같이 나타낼 수 있다.
$$\vec{w} = a \cdot \vec{u} + b \cdot \vec{v}$$

두 벡터 $\vec{u}$와 $\vec{v}$가 선형 독립의 관계를 가진다면 이 선형 결합식으로 2차원 벡터 공간에 속한 모든 벡터를 생성할 수 있다.   
벡터 $\vec{w}$의 값이 $(5, 5)$라고 가정해보면, 이 벡터를 생성하는 두 벡터의 결합으로는 $x$축과 $y$축에 일치하는 두 단위 벡터 $(1, 0)$과 $(0, 1)$을 사용한 선형 결합식을 생각할 수 있다.
$$(5, 5) = 5 \cdot (1, 0) + 5 \cdot (0, 1)$$

이 수식을 그림으로 나타내면 [그림 2-7](#그림-2-7-두-단위-벡터의-선형-결합으로-벡터를-생성한-예시)과 같다.

###### 그림 2-7 두 단위 벡터의 선형 결합으로 벡터를 생성한 예시
![두 단위 벡터의 선형 결헙으로 벡터를 생성한 예시](/img/2-7두단위벡터의선형결합으로벡터를생성한예시.jpg)

[그림 2-8](#그림-2-8-벡터-2-1과-1-3을-활용한-선형-결합으로-벡터-5-5를-생성한-예시)과 같이 벡터 $(5, 5)$를 생성할 수 있는 선형 결합식은 이 밖에도 얼마든지 다양하게 존재한다.
$$(5, 5) = 2 \cdot (2, 1) + 1 \cdot (1, 3)$$

###### 그림 2-8 벡터 (2, 1)과 (1, 3)을 활용한 선형 결합으로 벡터 (5, 5)를 생성한 예시
![벡터 (2, 1)과 (1, 3)을 활용한 선형 결합으로 벡터 (5, 5)를 생성한 예시](/img/2-8벡터(2,1)과(1,3)을활용한선형결합으로벡터(5,5)를생성한예시.jpg)

벡터 $(2, 1)$과 $(1, 3)$을 결합했을 때 $(5, 5)$가 아닌 다른 벡터도 생성할 수 있는지 확인해보자.     
순서쌍 $(w_x, w_y)$로 구성된 임의의 벡터 $\vec{w}$를 생성하는 수식은 다음과 같다.
$$(w_x, w_y) = a \cdot (2, 1) + b \cdot (1, 3)$$

$x$값과 $y$값을 분리해 위 식을 전개하면 다음과 같다.
$$2a + b = w_x$$

$$a + 3b = w_y$$

두 식을 $a$와 $b$에 대한 연립방정식으로 보고 풀어보면 그 값은 벡터 $\vec{w}$의 좌푯값인 $w_x, w_y$값에 따라 결정되며, ***언제나 해가 존재함***을 알 수 있다.
$$a = \frac{3w_x - w_y}{5}, b = \frac{2w_y - w_x}{5}$$

따라서 벡터 $(2, 1)$과 벡터 $(1, 3)$을 결합해 ***평면에 속한 모든 벡터를 생성할 수 있음***을 알 수 있다.  
그리고 벡터 $\vec{w}$ 값이 영벡터가 되는 $a$와 $b$의 해는 모두 0인 경우뿐이다.
$$a = \frac{3 \cdot 0 - 0}{5}, b = \frac{2 \cdot 0 - 0}{5}$$

벡터 $(2, 1)$과 벡터 $(1, 3)$은 서로 선형 독립의 관계를 가진다.

다른 두 벡터 $(1, 2)$와 $(2, 4)$를 결합했을 때 벡터 $(5, 5)$를 생성할 수 있는지 알아보자.
$$(5, 5) = a \cdot (1, 2) + b \cdot (2, 4)$$

이 역시 $a$와 $b$의 연립방정식으로 보고 $a$와 $b$의 값을 구하는 문제로 귀결된다.
$$a + 2b = 5$$

$$2a + 4b = 5$$

하지만 이를 만족하는 $a$와 $b$의 값을 구할 수가 없다.
$$2a + 4b = 10$$

$$2a + 4b = 5$$

[그림 2-9](#그림-2-9-평행한-1-2와-2-4의-선형-결합-결과)를 살펴보면 두 벡터 $(1, 2)$와 $(2, 4)$는 평행하지만 $(5, 5)$와는 서로 평행하지 않다.

###### 그림 2-9 평행한 (1, 2)와 (2, 4)의 선형 결합 결과
![평행한 (1, 2)와 (2, 4)의 선형 결합 결과](/img/2-9평행한(1,2)와(2,4)의선형결합결과.jpg)

다음 식에서도 볼 수 있듯이, 평행한 두 벡터를 결합한 결과는 두 개의 벡터 결합이 아닌 하나의 벡터 $(1, 2)$에 스칼라 곱을 적용한 결과에 불과하다.
$$(x, y) = a(1, 2) + b(2, 4) = a(1, 2) + 2b(1, 2) = (a + 2b) \cdot (1, 2)$$

따라서 $a$와 $b$에 어떤 스칼라 값을 대입하더라도 선형 결합의 결과는 벡터 $(1, 2)$와 평행한 벡터만 생성될 뿐이고, 이와 평행하지 않은 벡터 $(5, 5)$를 생성하는 것은 불가능하다.   
$(1, 2)$와 $(2, 4)$의 관계를 선형 결합식으로 나타내면 다음과 같다.
$$2 \cdot (1, 2) + (-1) \cdot (2, 4) = (0, 0)$$

0이 아닌 임의의 계수 $a$와 $b$를 사용해 영벡터를 만들수 있으므로 두 벡터 $(1, 2)$와 $(2, 4)$는 선형 종속의 관계를 가진다.   
벡터와 스칼라 곱의 결과는 이들과 평행한 벡터를 생성하므로 결국에는 [그림 2-9](#그림-2-9-평행한-1-2와-2-4의-선형-결합-결과)의 붉은 선상에 위치한 벡터만 생성할 수 있다.  
이로써 ***평면의 모든 점을 생성하기 위한 선형 결합식에는 서로 평행하지 않은 2개의 벡터가 필요함***을 알 수 있으며, ***두 벡터는 서로 선형 독립의 관계를 가져야 함***을 확인할 수 있다.

벡터 3개의 선형 결합으로 평면의 모든 벡터를 만들어 낼 수 있는지 생각해보자.     
앞서 평행하지 않은 두 벡터를 결합해 평면의 모든 벡터를 만들어 낼 수 있음을 확인했다.    
그렇기에 세 번째 벡터는 없어도 되지만 이를 어떻게 수식으로 확인할 수 있을지 알아보자.   
선형 종속과 선형 독립의 관점에서 이를 분석해보면 두 벡터 $(2, 1)$과 $(1, 3)$은 선형 독립의 관계를 지니고 있다.
$$0 \cdot (2, 1) + 0 \cdot (1, 3) = (0, 0)$$

선형 독립인 두 벡터 $(2, 1)$과 $(1, 3)$에 스칼라 $a$와 $b$를 곱하고 새로운 스칼라 $c$와 임의의 벡터 $(x, y)$를 추가해 다음과 같이 세 개의 벡터로 구성된 선형 결합식을 만든다고 가정해보자.
$$a \cdot (2, 1) + b \cdot (1, 3) + c(x, y) = (0, 0)$$

세 벡터가 모두 선형 독립의 관계를 가지려면 위 식을 만족하는 모든 스칼라 $a, b, c$의 값은 0이어야 한다.  
그런데 앞에서 선형 독립인 두 벡터 $(2, 1)$과 $(1, 3)$을 결합해 평면의 모든 벡터를 생성할 수 있었으므로, 두 벡터를 결합해 임의의 벡터$(x, y)$에 $-c$를 곱한 $-c(x, y)$를 생성하는 것도 가능할 것이다.    
그렇다면 다음과 같이 0이 아닌 스칼라 $c$를 사용해 영벡터를 만들 수 있으므로 선형 독립의 관계를 더 이상 만족하지 못한다.
$$-c(x, y) + c(x, y) = (0, 0)$$

따라서 ***선형 독립의 관계가 유지되려면 2개의 벡터만 사용되어야 함***을 알 수 있다.

이러한 벡터의 선형적 관계를 사용해 벡터 공간에 관련된 몇 가지 새로운 용어를 학습해보자.     
예제에서 살펴본 두 벡터 $(2, 1)$과 $(1, 3)$과 같이 ***벡터 공간 내 모든 벡터를 생성할 수 있는 선형 독립 관계를 가지는 벡터의 집합을 기저(Basis)라고 한다***.  
두 벡터 $(1, 0)$과 $(0, 1)$도 선형 독립 관계를 가지므로 기저다.     
***집합의 개념인 기저에 속한 원소를 기저벡터(Basis vector)라고 한다***.   
벡터 $(2, 1)$은 기저 $B = {(2, 1), (1, 3)}$에 속한 기저벡터다.

기저벡터를 다른 값으로 변경하면 기저벡터로부터 세워진 벡터 공간의 모든 원소가 바뀐다고 볼 수 있는데, 이는 ***선형 변환***의 기본 원리가 된다.     
이러한 기저의 개념은 ***차원(Dimension)*** 이라는 새로운 용어를 정의하는데 사용된다.   
평면으로 구성된 벡터 공간을 생성하기 위한 ***기저는 수많은 경우의 수가 존재***하지만, ***기저 집합의 원소 수는 언제나 2개***뿐이다.     
따라서 명확한 정의에 의해 ***평면에 대응하는 벡터 공간***을 ***2차원***으로 정의할 수 있다.

벡터 공간은 두 개의 실수 집합을 결합해 생성한 벡터 공간이다.    
좀 더 구체적인 정보를 제공하기 위해 수 집합의 기호와 차원의 정보를 첨자로 결합해 $R^2$으로 나타내며 이를 ***2차원 실벡터 공간(Real vector space)*** 이라고 부른다.

***2차원을 구성하는 다양한 기저 중에서 한 축만 사용하는 단위 벡터 $(1, 0), (0, 1)$로 구성된 집합을 특별히 표준기저(Standard basis)라고 하며, 기저의 각 원소를 표준기저벡터(Standard basis vector)라고 한다***.     
표준기저벡터는 순서대로 $e_1, e_2$로 표기한다.
$$e_1 = (1, 0)$$

$$e_2 = (0, 1)$$

벡터 공간의 차원에는 제약이 없기 때문에 $R^3, R^4, ..., R^n$으로 무한 확장이 가능하다.  
3차원 실벡터 공간의 표준기저는 늘어난 차원만큼 다음과 같이 구성된다.
$$e_1 = (1, 0, 0)$$

$$e_2 = (0, 1, 0)$$

$$e_3 = (0, 0, 1)$$

# 6. 삼각함수
한 각이 직각(90도)인 직각삼각형을 이루는 세 변은 각 위치에 따라 ***빗변(직각의 대변), 밑변, 높이***라고 부른다.   
한 각이 직각이므로 나머지 두 각의 합이 90도가 되어야 한다.  
따라서 두 각은 모두 90도보다 작은 예각이다.     
빗변과 밑변의 사잇각은 $\theta$를 이용해 [그림 3-1](#그림-3-1-직각삼각형을-구성하는-세-변)과 같이 나타낸다.

###### 그림 3-1 직각삼각형을 구성하는 세 변
![직각삼각형을 구성하는 세 변](/img/3-1직각삼각형을구성하는세변.jpg)

***직각삼각형을 구성하는 세 변에서 두 변을 뽑아 각각의 비례관계를 나타낸 것을 삼각비(Trigonometric Ratio)라고 한다***.    
삼각비에는 여러 종류가 있지만 ***사인(Sine), 코사인(Cosine), 탄젠트(Tangent)*** 세 가지가 가장 대표적이다.    
밑변의 길이를 $a$, 높이의 길이를 $b$, 빗변의 길이를 $c$, 빗변과 밑변과의 사잇각을 $\theta$라고 할 때, 각 삼각비의 관계는 다음과 같이 분수식으로 표현할 수 있다.
$$\sin \theta = \frac{b}{c}$$

$$\cos \theta = \frac{a}{c}$$

$$\tan \theta = \frac{b}{a}$$

직각삼각형에서 측정할 수 있는 사잇각은 $0^\circ$보다 크거나 $90^\circ$보다 작아야 한다.     
이때 [그림 3-2](#그림-3-2-삼각함수의-개념)와 같이 ***직각삼각형을 데카르트 좌표계 상에 배치하고 사잇각의 범위를 실수 전체($R$ 집합)로 확장한 대응 관계를 삼각함수(Trigonometric function)라고 한다***.

###### 그림 3-2 삼각함수의 개념
![삼각함수의 개념](/img/3-2삼각함수의개념.jpg)

가장 많이 사용하는 삼각함수인 $\sin$ 함수와 $\cos$ 함수의 개념은 직각삼각형에서 출발했지만, 원점을 중심으로 반지름이 1인 평면 위의 ***단위 원(Unit circle)*** 을 사용해 나타내면 좀 더 쉽게 파악할 수 있다.    
데카르트 좌표계에서 원점에서부터 1사분면의 단위 원의 원주 위에 있는 임의의 점을 이어 [그림 3-3](#그림-3-3-길이가-1인-빗변과-사잇각-세타)과 같이 빗변을 그어보면 원의 반지름의 길이는 1이므로 이 빗변의 길이는 항상 1이다.     
$x$축과 해당 빗변이 이루는 각을 사잇각($\theta$)으로 지정한다.

###### 그림 3-3 길이가 1인 빗변과 사잇각 세타
![길이가 1인 빗변과 사잇각 세타](/img/3-3길이가1인빗변과사잇각세타.jpg)

[그림 3-4](#그림-3-4-단위-원의-빗변으로-생성한-직각삼각형)처럼 빗변에서 $x$축으로 수직선을 내려 직각삼각형을 그려보자.  
이 직각삼각형으로부터 삼각비를 계산할 수 있다.

###### 그림 3-4 단위 원의 빗변으로 생성한 직각삼각형
![단위 원의 빗변으로 생성한 직각삼각형](/img/3-4단위원의빗변으로생성한직각삼각형.jpg)

빗변 $c$의 길이가 1이므로 삼각비 $\sin \theta$의 값은 높이 $b$와 같고 $\cos \theta$ 값은 밑면 $a$와 같다.
$$\sin \theta = \frac{b}{1} = b$$

$$\cos \theta = \frac{a}{1} = a$$

따라서 데카르트 좌표계에서 빗변이 가리키는 단위 원의 좌표는 $(\cos \theta, \sin \theta)$ 로 표현할 수 있는데, 이를 삼각함수로 확장하면 원주 위의 모든 좌표는 [그림 3-5](#그림-3-5-단위-원의-빗변-좌표)와 같이 $(\cos \theta, \sin \theta)$에 대응한다고 할 수 있다.

###### 그림 3-5 단위 원의 빗변 좌표
![단위 원의 빗변 좌표](/img/3-5단위원의빗변좌표.jpg)

밑변 $a$의 $x$좌표는 $\cos \theta$가 되고 높이 $b$의 $y$좌표는 $\sin \theta$가 되는데 이를 피타고라스 정리 $a^2 + b^2 = c^2$에 대입하면 다음과 같은 공식을 얻을 수 있다.
$$\cos^2 \theta + \sin^2 \theta = 1$$

이번에는 단위 원의 반지름 길이를 $r$로 일반화시켜 생각해보자.   
[그림 3-6](#그림-3-6-길이가-r인-벡터의-x-y값)과 같이 반지름이 $r$인 원에서의 빗변은 벡터의 개념으로 보았을 때 길이가 1인 벡터와 평행하고 길이는 $r$배만큼 증가했으므로 스칼라 곱셈에 의해 $r \cdot (\cos \theta, \sin \theta)$라는 좌표를 갖게 된다.     
이로써 빗변의 길이가 $r$인 직각삼각형의 밑변의 길이는 $r \cdot \cos \theta$가 되고, 높이의 길이는 $r \cdot \sin \theta$가 됨을 알 수 있다.

###### 그림 3-6 길이가 r인 벡터의 x, y값
![길이가 r인 벡터의 x, y값](/img/3-6길이가r인벡터의x,y값.jpg)

앞서 구한 식은 반지름의 길이와 무관하게 동일하게 성립함을 알 수 있다.
$$r^2(\cos^2 \theta + \sin^2 \theta) = r^2$$

$$\therefore \cos^2 \theta + \sin^2 \theta = 1$$

이 식은 삼각함수의 기본을 이루는 중요한 공식으로, 회전과 관련된 계산에 유용하게 사용된다.

# 6.1. 삼각함수의 성질
***데카르트 좌표계에서 각도(角度)는 $x$축에서 원의 궤적을 따라 반시계 방향으로 회전한 크기를 의미한다***.     
반지름이 1인 단위 원에서 반시계 방향의 회전을 생각해보면, 아직 회전하지 않아 $x$축 상에 위치한 빗변 $\vec{v}$의 좌표는 $(1, 0)$인데, 이 각도는 $0^\circ$에 대응한다고 할 수 있다.   
따라서 각도 $0^\circ$에 대한 $\sin$ 함수와 $\cos$ 함수의 값은 다음과 같다.
$$\vec{v} = (v_x, v_y) = (\cos 0^\circ, \sin 0^\circ) = (1, 0)$$

$$\therefore \sin 0^\circ = 0, \cos 0^\circ = 1$$

각도를 $0^\circ$에서 $90^\circ$까지 서서히 증가시키면서 회전하는 빗변의 좌표 $v_x$와 $v_y$의 변화를 살펴보면 ***각도가 증가할수록 $v_x$값은 감소하고 $v_y$값은 증가한다***.   
그리고 목적지인 $90^\circ$에 도달하면 $y$축 상에 위치한 좌표 $(0, 1)$과 일치하는 벡터가 만들어진다.     
$v_x$값을 보라색으로, $v_y$값을 청록색으로 표시해 좌표의 $x$값과 $y$값의 변화를 추적하면 [그림 3-7](#그림-3-7-0-90-구간에서-sin-함수와-cos-함수의-변화)과 같은 부드러운 곡선이 만들어진다.

###### 그림 3-7 [0, 90] 구간에서 sin 함수와 cos 함수의 변화
![0, 90 구간에서 sin 함수와 cos 함수의 변화](/img/3-7[0,90]구간에서sin함수와cos함수의변화.jpg)

***각도가 $90^\circ$를 넘어서면 $v_x$값은 $0$을 지나 음수가 되고, $v_y$값은 다시 $0$을 향해 감소하기 시작한다***.     
계속해서 한바퀴에 해당하는 $360^\circ$까지 빗변의 좌표 변화를 계속 관찰하면, [그림 3-8](#그림-3-8-각도에-따라-변화하는-sin-함수와-cos-함수의-그래프)과 같이 $-1$에 도달할 때까지 계속 감소하다가 $-1$에 도달하면 방향을 바꿔서 $1$을 향해 증가하며, $1$에 도달하면 다시 $-1$을 향해 감소하는 패턴을 반복한다.    
이러한 값의 변화는 $[-1, 1]$ 범위 내에서 $360^\circ$마다 반복되는데, ***변화 값의 범위***를 ***진폭(Amplitude)*** , ***반복되는 각도***를 ***주기(Period)*** 라고 한다.

###### 그림 3-8 각도에 따라 변화하는 sin 함수와 cos 함수의 그래프
![각도에 따라 변화하는 sin 함수와 cos 함수의 그래프](/img/3-8각도에따라변화하는sin함수와cos함수의그래프.jpg)

$360^\circ$마다 이 패턴이 반복되므로 $\cos$ 함수에 대응하는 $v_x$값의 그래프는 [그림 3-9](#그림-3-9-a-cos-함수와-b-sin-함수-그래프)의 (a), $\sin$ 함수에 대응하는 $v_y$값의 그래프는 (b)의 형태를 가진다.

###### 그림 3-9 (a) cos 함수와 (b) sin 함수 그래프
![(a) cos 함수와 (b) sin 함수 그래프](/img/3-9(a)cos함수와(b)sin함수그래프.jpg)

[그림 3-9](#그림-3-9-a-cos-함수와-b-sin-함수-그래프)의 그래프로부터 $\sin$ 함수와 $\cos$ 함수의 성질을 정리하면 다음과 같다.

1. $\sin$ 함수와 $\cos$ 함수는 항상 $-1$에서 $1$ 사이를 일정하게 반복되는 패턴을 띈다.
2. $\sin$ 함수와 $\cos$ 함수의 값은 $360^\circ$ 주기로 반복된다.
3. $y$축을 기준으로 좌우를 접어 포갰을 때 ***$\cos$ 함수 그래프는 데칼코마니처럼 좌우 대칭***인 반면, ***$\sin$ 함수 그래프는 상하가 반전된 원점 대칭***의 형태를 띤다.     
$\cos$ 함수와 같이 좌우 대칭의 성질을 가진 함수를 ***짝함수(Even function)*** 또는 ***우함수*** 라고 부르며, $\sin$ 함수와 같이 원점 대칭의 성질을 가진 함수를 ***홀함수(Odd function)*** 또는 ***기함수*** 라고 부른다.

3번에서 언급한 $\sin$ 함수와 $\cos$ 함수 그래프가 지니는 홀함수와 짝함수의 성질은 다음 식과 같이 정리할 수 있다.    
이는 회전에 관련된 계산에 유용하게 사용된다.
$$\cos(-\theta) = \cos(\theta)$$

$$\sin(-\theta) = -\sin(\theta)$$

***$\tan$ 함수는 빗변과 무관하게 밑변과 높이의 관계만을 나타낸다***.
$$\tan \theta = \frac{b}{a}$$

이 식의 분자와 분모를 모두 빗변의 값으로 각각 나누면 다음 수식과 같이 ***$\cos$과 $\sin$으로 $\tan$ 함수를 표현할 수 있다***.
$$\tan \theta = \frac{\frac{b}{c}}{\frac{a}{c}} = \frac{\sin \theta}{\cos \theta}$$

분모의 값은 $0$이 될 수 없기 때문에 ***분모에 해당하는 $\cos$ 함수 값이 $0$이 되는 $90^\circ$에서는 $\tan$ 값이 존재하지 않는다***.   
이는 ***$270^\circ$인 경우에도 동일***하고 ***$-90^\circ$, $-270^\circ$인 경우***에도 마찬가지다.   
그렇기 때문에 ***$\tan$ 함수의 정의역에는 해당 구간이 포함되지 않는다***.     
[그림 3-10](#그림-3-10-tan-함수의-그래프)은 $\tan$ 함수의 그래프며 $\sin$ 함수와 동일하게 ***홀함수의 성질***을 지님을 알 수 있다.

###### 그림 3-10 tan 함수의 그래프
![tan 함수의 그래프](/img/3-10tan함수의그래프.jpg)

# 6.2. 각의 측정법
일반적으로 일상 생활에서 ***각(Angle)*** 의 크기를 잴 때 0에서 360까지의 수를 사용하는 ***각도법(Degree)*** 을 사용한다.  
각도법에서 기준으로 삼는 360이라는 수는 약수가 많아 원을 다양한 방법으로 쪼개어 활용할 수 있기 때문인데, 이는 일상생활에서의 편리를 위한 것일 뿐, 360이라는 값은 표준으로 사용하기에는 너무 큰 수다.

벡터의 경우 크기를 비교하기 용이하도록 크기 1의 단위 벡터를 정의한 것처럼, 각을 측정할 때도 단위량 1을 기반으로 상대적인 크기를 측정할 수 있도록 체계를 만들어야 합리적이다.    
실무 계산에서 삼각함수를 응용할 때에는 각도법 대신 ***호의 길이를 기준으로 각을 측정하는 방법***을 사용한다.  
이를 ***호도법(Radian)*** 이라 부른다.     
***호도법은 호의 길이가 1이 되는 부채꼴의 각을 기준으로 각을 측정한다***.     
[그림 3-11](#그림-3-11-반지름이-1인-반원)과 같이 원점에 중심을 둔 반지름이 1인 단위 반원을 그리고 반원의 호 길이를 비교하기 위해 $x$축에 원점에서 크기가 1인 벡터를 청록색으로 함께 배치한다.

###### 그림 3-11 반지름이 1인 반원
![반지름이 1인 반원](/img/3-11반지름이1인반원.jpg)

반원의 호 길이를 재기 위해 [그림 3-12](#그림-3-12-반원의-왼쪽-끝을-원점으로-이동한-결과)와 같이 반원의 왼쪽 끝점을 원점으로 평행이동시킨다.

###### 그림 3-12 반원의 왼쪽 끝을 원점으로 이동한 결과
![반원의 왼쪽 끝을 원점으로 이동한 결과](/img/3-12반원의왼쪽끝을원점으로이동한결과.jpg)

그러고 나서 반원의 왼쪽 끝(원점에 놓인 붉은색 점)을 고정한 후 $x$축의 양의 방향으로 반원의 오른쪽 끝점을 잡아당겨 $x$축 위에 쭉 펼친 후, 그 길이(보라색 선)를 $x$축 상의 단위 벡터(청록색)와 함께 비교해보면 펼친 결과는 [그림 3-13](#그림-3-13-반원호의-길이-측정)과 같을 것이다.

###### 그림 3-13 반원호의 길이 측정
![반원호의 길이 측정](/img/3-13반원호의길이측정.jpg)

반원의 호 길이는 단위 벡터의 길이 1보다 대략적으로 3.14배 더 큰데, 정확한 값을 구할 수는 없다.  
이것이 ***3.141592...로 이어지는 무리수인 원주율 파이($\pi$)*** 다.

$180^\circ$에 해당하는 반원의 호 길이가 파이($\pi$)임을 알았으니, 이번에는 거꾸로 호의 길이가 1인 부채꼴의 중심각은 몇 도인지 생각해보자.   
호의 길이를 1로 설정하면 [그림 3-14](#그림-3-14-1rad의-정의)와 같은 부채꼴이 나오는데, 이 부채꼴의 각이 바로 호도법에서 사용하는 각의 기준인 ***$1rad$(라디안)*** 이다.    
***1라디안은 각도로 환산하면 약 $57.2958^\circ$가 되며 이 역시 $\pi$와 같은 무리수다***.

###### 그림 3-14 1rad의 정의
![1rad의 정의](/img/3-14-1rad의정의.jpg)

$180^\circ$에 해당하는 반원의 각을 라디안으로 표현하면 얼마인지 알아보자.   
반원의 호 길이는 파이($\pi$)이므로 각 역시 라디안을 기준으로 $\pi$배만큼 클 것이다.     
따라서 각도법과 호도법 사이에는 다음의 대응 관계가 성립한다.
$$\pi(rad) = 180^\circ$$

이 수식을 응용해 다음의 변환식을 만들 수 있다.
$$1^\circ = \frac{\pi}{180}(rad)$$

$$1(rad) = (\frac{180}{\pi})^\circ$$

[표 3-1]은 수식에서 자주 사용하는 각도와 라디안 값을 대응시켜 정리한 표다.

###### 표 3-1 가장 흔히 사용하는 각의 각도와 호도 표기
|각도법|호도법|
|---|---|
|$30^\circ$|$\frac{\pi}{6}$|
|$45^\circ$|$\frac{\pi}{4}$|
|$60^\circ$|$\frac{\pi}{3}$|
|$90^\circ$|$\frac{\pi}{2}$|
|$180^\circ$|$\pi$|
|$360^\circ$|$2\pi$|

# 7. 삼각함수를 활용한 물체의 회전
벡터의 회전은 생각보다 까다롭다.    
물체를 이동시키고 크기를 늘리는 동작은 [그림 3-15](#그림-3-15-축마다-별도로-적용되는-이동-변환)의 (a)와 같이 ***서로 수직인 $x$축과 $y$축이 서로 독립적으로 적용***된다.   
따라서 (b)와 같이 $x$축과 $y$축을 분리해 따로따로 계산한 후 두 결과를 결합한 것과 동일하다.

###### 그림 3-15 축마다 별도로 적용되는 이동 변환
![축마다 별도로 적용되는 이동 변환](/img/)

하지만 회전이라는 동작은 $x$와 $y$의 값이 함께 영향을 미치기 때문에 [그림 3-15](#그림-3-15-축마다-별도로-적용되는-이동-변환)처럼 $x$축과 $y$축을 분리해 독립적으로 계산할 수 없다.   
***회전을 구현하기 위해 기저벡터의 개념을 활용할 수 있다***.  
실벡터 공간 $R^2$는 두 표준기저벡터 $e_1, e_2$를 기저로 둔 공간이고, 공간에 속한 모든 벡터는 $e_1$과 $e_2$의 선형 결합에 의해 생성된다.     
회전을 위해 실벡터 공간 $R^2$ 전체를 각 $\theta$만큼 회전시키면 두 표준기저벡터 $e_1$과 $e_2$의 좌표는 [그림 3-16](#그림-3-16-공간-변화에-따른-기저벡터의-변화)과 같이 변화될 것이다.

###### 그림 3-16 공간 변화에 따른 기저벡터의 변화
![공간 변화에 따른 기저벡터의 변화](/img/)

표준기저벡터 $e_1$이 각 $\theta$만큼 회전한 좌표는 [그림 3-5](#그림-3-5-단위-원의-빗변-좌표)에서 확인했듯이 $(\cos \theta, \sin \theta)$이 된다.    
이를 다음과 같이 $e_1'$으로 표시한다.
$$e_1' = (\cos \theta, \sin \theta)$$

표준기저벡터 $e_2$가 각 $\theta$만큼 변한 좌표를 확인해보자.    
[그림 3-16](#그림-3-16-공간-변화에-따른-기저벡터의-변화)을 관찰해보면 $e_1'$의 $y$좌표만큼 음의 $x$값을 가지고, $x$좌표만큼 양의 $y$값을 가지고 있음을 알 수 있다.  
이를 $e_2'$으로 표시하면 좌표는 다음과 같다.
$$e_2' = (-\sin \theta, \cos \theta)$$

실벡터 공간 $R^2$의 벡터가 각 $\theta$만큼 회전하면 어떻게 변화되는지 수식으로 확인해보자.  
이를 위해 좌표 $(1, 1)$의 값을 가진 벡터 $\vec{v}$를 사용한다.  
회전되기 전의 벡터 $\vec{v}$는 표준기저벡터 $e_1$과 $e_2$를 사용해 다음의 선형 결합식으로 표현할 수 있다.
$$\vec{v} = 1 \cdot e_1 + 1 \cdot e_2$$

여기서 벡터 $\vec{v}$가 각 $\theta$만큼 회전한 벡터 $\vec{v'}$는 위 선형 결합식의 $e_1$과 $e_2$를 회전된 표준기저벡터 $e_1'$과 $e_2'$으로 치환해 얻을 수 있다.
$$\vec{v'} = 1 \cdot (\cos \theta, \sin \theta) + 1 \cdot (-\sin \theta, \cos \theta)$$

따라서 좌표 $(1, 1)$이 각 $\theta$만큼 회전한 벡터 $\vec{v'}$의 좌표는 다음과 같이 얻을 수 있다.
$$\vec{v'} = (\cos \theta - \sin \theta, \sin \theta + \cos \theta)$$

좌표 $(1, 1)$의 벡터 $\vec{v}$가 각 $\theta$만큼 회전하는 과정을 정리하면 [그림 3-17](#그림-3-17-벡터-1-1을-각-세타만큼-회전한-결과)과 같다.

###### 그림 3-17 벡터 (1, 1)을 각 세타만큼 회전한 결과
![벡터 (1, 1)을 각 세타만큼 회전한 결과]

이와 동일한 원리로 임의의 벡터 $\vec{u} = (x, y)$에 대해 각 $\theta$만큼 회전한 벡터 $\vec{u'} = (x', y')$을 구할 수 있는 일반적인 수식을 전개할 수 있다.   
실벡터 공간 $R^2$의 두 표준기저벡터를 $e_1, e_2$라고 할 때 각 $\theta$만큼 회전한 벡터 $\vec{u'}$은 다음의 수식으로 정리할 수 있다.
$$\vec{u} = (x, y) = x \cdot e_1 + y \cdot e_2 = x \cdot (1, 0) + y \cdot (0, 1)$$

$$\vec{u'} = (x', y') = x \cdot (\cos \theta, \sin \theta) + y \cdot (-\sin \theta, \cos \theta) \\
= (x \cos \theta - y \sin \theta, x \sin \theta + y \cos \theta)$$

따라서 임의의 벡터 $(x, y)$가 각 $\theta$만큼 회전된 결과 $(x', y')$는 다음과 같다.
$$x' = x \cos \theta - y \sin \theta$$

$$y' = x \sin \theta + y \cos \theta$$

# 8. 삼각함수의 역함수
삼각함수를 사용해 주어진 각에 대응하는 벡터의 좌표를 얻을 수 있다.  
게임 제작 과정에서는 거꾸로 ***주어진 벡터의 좌표로부터 이에 대응하는 각도***를 얻어내는 작업도 필요하다.     
이를 계산하려면 삼각함수의 역함수와 이에 대한 성질을 알아야 한다.   
임의의 각 $x$에 대응되는 $sin$ 함수는 다음과 같이 표기할 수 있다.
$$y = f(x) = \sin(x)$$

$\sin$ 함수가 가진 $x$와 $y$ 사이의 대응 관계를 살펴보면 ***정의역의 여러 요소가 공역의 한 요소에 대응***되는 것을 알 수 있다.

###### 그림 3-18 sin 함수의 그래프
![sin 함수의 그래프](/img/)

만일 공역의 범위를 실수 집합 전체가 아닌 $[-1, 1]$ 구간으로 한정해 정의한다면, $\sin$ 함수는 전사함수의 성질을 띤다.     

###### 그림 3-19 영역을 제한시켜 전사함수의 성질을 가지게 된 sin 함수
![영역을 제한시켜 전사함수의 성질을 가지게 된 sin 함수](/img/)

여기서 정의역의 범위를 $[-90^\circ, 90^\circ]$ 구간으로 좁히면 정의역의 한 요소가 공역의 한 요소에 대응되는 전단사함수가 된다.

###### 그림 3-20 영역을 제한시켜 전단사함수의 성질을 가지게 된 sin 함수
![영역을 제한시켜 전단사함수의 성질을 가지게 된 sin 함수](/img/)

이렇게 어떤 함수를 ***전단사함수***로 만든다면, $\sin x$값이 주어졌을 때 거꾸로 각 $x$를 구할 수 있는 ***역함수***가 존재하게 된다.     
이와 같이 ***정의역과 공역의 범위를 제한***시켜 얻은 $\sin$ 함수의 역함수를 ***$\arcsin$(아크사인)*** 함수라고 부른다.
$$f^{-1}(x) = \sin^{-1}(x) = \arcsin(x)$$

$\arcsin$ 함수의 그래프는 [그림 3-21](#그림-3-21-arcsin-함수의-그래프)과 같다.

###### 그림 3-21 arcsin 함수의 그래프
![arcsin 함수의 그래프](/img/)

이와 동일하게 $\cos$ 함수의 역함수를 구하기 위해 $\cos$ 함수가 전단사함수가 되도록 정의역과 공역을 제한하면 정의역은 $[0^\circ, 180^\circ]$, 공역은 $[-1, 1]$이다.

###### 그림 3-22 cos 함수의 그래프
![cos 함수의 그래프](/img/)

이로부터 생성한 역함수를 $\arccos$(아크코사인) 함수라고 한다.   
$\arccos$ 함수의 그래프는 [그림 2-23](#그림-3-23-arccos-함수의-그래프)과 같다.

###### 그림 3-23 arccos 함수의 그래프
![arccos 함수의 그래프](/img/)

$\tan$ 함수의 역함수를 구하기 위해서는 $\tan$ 함수가 전단사함수가 되어야 한다.  
[그림 3-24](#그림-3-24-tan-함수의-그래프)에서 보듯이 ***$\tan$ 함수의 치역은 실수 영역 전체인데 반해, 정의역이 존재하지 않는 구간이 존재***하는 것이 문제다.    
따라서 $\tan$ 함수의 ***정의역 구간을 제한해서 한정***해야 할 것이다.

###### 그림 3-24 tan 함수의 그래프
![tan 함수의 그래프](/img/)

$\tan$ 함수는 $x$값이 $-90^\circ$와 $90^\circ$일 때의 $y$값이 존재하지 않으므로 전단사함수가 되기 위한 정의역 구간은 $-90^\circ$와 $90^\circ$ 값을 제외한 $(-90^\circ, 90^\circ)$ 범위가 되어야 한다.   
$\arctan$(아크탄젠트) 함수의 그래프는 [그림 3-25](#그림-3-25-arctan-함수의-그래프)와 같다.

###### 그림 3-25 arctan 함수의 그래프
![arctan 함수의 그래프](/img/)

***$\arctan$ 함수는 벡터의 각도를 구하는 데 유용하게 사용된다***.     
임의의 벡터를 $\vec{v} = (x, y)$라고 할 때 분수식$\frac{y}{x}$를 계산해 벡터로부터 $\tan$ 함수 값을 얻을 수 있다.   
이 $\tan$ 값을 $\arctan$ 함수에 넣으면 해당 벡터가 $x$축과 이루는 사잇각을 얻어낼 수 있다.

###### 그림 3-26 벡터의 각
![벡터의 각](/img/)

$\arctan$ 함수의 치역은 $(-90^\circ, 90^\circ)$ 구간이므로 $\arctan$ 함수로 얻을 수 있는 각의 범위에는 한계가 있다.     
이는 $\arcsin$ 함수와 $\arccos$ 함수도 동일한 상황이다.

###### 그림 3-27 삼각함수의 역함수로 얻을 수 있는 각의 범위
![삼각함수의 역함수로 얻을 수 있는 각의 범위](/img/)

하지만 $\arctan$ 함수의 경우, 인자에 분수 $\frac{y}{x}$ 값을 넣지 않고 $x$와 $y$의 두 값을 분리해 전달하면 4분면 전체에 해당하는 각의 정보를 얻을 수 있다.  
예를 들어 [그림 3-28](#그림-3-28-3사분면에-위치한-벡터의-사잇각)과 같이 3사분면에서 $x$값의 부호가 음이고, $y$의 부호도 음인 경우를 생각해보자.

###### 그림 3-28 3사분면에 위치한 벡터의 사잇각
![3사분면에 위치한 벡터의 사잇각](/img/)

분수값 $\frac{y}{x}$의 결과는 양수기 때문에, 이를 $\arctan$ 함수에 전달하면 3사분면의 정보는 사라지고 1사분면에 해당하는 각의 정보가 나와 처음에 사용한 벡터를 얻어낼 수 없다.

###### 그림 3-29 arctan 함수를 사용하는 경우의 문제점
![arctan 함수를 사용하는 경우의 문제점](/img/)

하지만 $\arctan$ 함수에 $x$와 $y$ 두 값을 따로 전달한다면 두 값이 가지는 부호를 파악해 벡터가 1사분면에 있었는지 3사분면에 있었는지를 파악할 수 있다.   
그래서 $\arctan$ 함수에는 분수값 $\frac{y}{x}$를 계산해 전달하는 함수와 $x$와 $y$를 따로 전달하는 함수의 두 종류가 있다.

$x$와 $y$를 따로 전달하는 $\arctan$ 함수를 $atan2$ 함수라고 부르며, 이는 분수 $\frac{y}{x}$를 연상하기 쉽게 $y$값에 이어 $x$값을 전달하도록 설계되어 있다.   
$atan2$를 사용하면 평면의 모든 사분면에 대응하는 각도를 얻을 수 있다.
$$atan2(y, x)$$

각의 크기를 $x$축으로 둔 $atan2$ 함수의 그래프는 [그림 3-30](#그림-3-30-atan2-함수의-그래프)과 같으며 이의 공역은 $(-180^\circ, 180^\circ)$ 범위를 가진다.

###### 그림 3-30 atan2 함수의 그래프
![atan2 함수의 그래프](/img/)

# 9. 극좌표계
***물체를 이동시키고 크기를 늘리는 동작은 $x$와 $y$가 독립적으로 적용되는 움직임***인 데 반해, ***회전은 $x$와 $y$가 함께 영향받는 동작***이다.   
따라서 데카르트 좌표계로 회전을 구현하면 회전에 따른 $x$와 $y$의 변화를 매번 계산하는 번거로움이 발생한다.

회전 동작을 기반으로 설계된 좌표계를 고안해 사용한다면, 이로부터 편리하게 회전을 관리하고 구현할 수 있다.   
이를 위해 고안된 좌표게가 바로 ***극좌표계(Polar coordinate system)*** 다.     
극좌표계는 원점으로부터의 거리 $r$과 각 $\theta$의 두 요소로 구성되며 극좌표계의 좌표는 $(r, \theta)$로 표시한다.

극좌표계는 [그림 3-31](#그림-3-31-극좌표계의-개념)과 같이 동심원의 형태로 평면의 모든 점을 표현하며, 주로 시간에 따른 회전의 움직임을 구현하거나 회전에 관련된 효과를 연출할 때 활용된다.

###### 그림 3-31 극좌표계의 개념
![극좌표계의 개념](/img/)

데카르트 좌표계로 표현된 벡터 $(x, y)$는 벡터의 크기와 $\arctan$함수를 사용해 다음과 같이 극좌표계 $(r, \theta)$로 변환할 수 있다.
$$r = \sqrt{x^2 + y^2}$$

$$\theta = atan2(y, x)$$

반대로 극좌표계의 좌표 $(r, \theta)$를 데카르트 좌표계 $(x, y)$로 변환하는 식은 삼각함수를 사용해 구할 수 있다.
$$x = r \cdot \cos \theta$$

$$y = r \cdot \sin \theta$$

# 10. 선형성: 예측 가능한 비례 관계
원점에서 시작하는 벡터와 스칼라 곱셈으로 생성된 벡터는 [그림 4-1](#그림-4-1-스칼라-곱셈-연산을-시각화한-예시)과 같이 그 벡터와 평행한 원점을 지나는 붉은 직선 상에 위치한다.

###### 그림 4-1 스칼라 곱셈 연산을 시각화한 예시
![스칼라 곱셈 연산을 시간화한 예시](/img/)

그림에서와 같이 붉은색으로 표현된 쭉 뻗은 직선이 지는 성질을 ***선형성(Linearity)*** 이라고 한다.  
즉 선형성은 ***직선의 형태를 띠는 성질***을 의미한다.     
수학에서는 선형성을 다음과 같은 ***가법성(Additivity)*** 과 ***1차 동차성(Homogeneity of degree 1)*** 두 가지 조건을 모두 만족하는 함수의 성질로 정의한다.   
- $f(x_1 + x_2) = f(x_1) + f(x_2)$ <- 가법성  
- $f(k \cdot x) = k \cdot f(x)$ <- 1차 동차성

# 10.1. 선형 함수
입력에 사용하는 요소 $x$와 출력이 모두 실수인 함수에서 원점을 지나는, 다음과 같은 직선의 함수를 생각할 수 있다.
$$f(x) = ax$$

출력의 원소를 $y$로 표시했을 때 위 함수는 $y = ax$로 표현되며, 이를 그래프로 나타내면 [그림 4-2](#그림-4-2-함수-y--ax-형태의-한-예시)와 같다.

###### 그림 4-2 함수 y = ax 형태의 한 예시
![함수 y = ax 형태의 한 예시](/img/)

직선 형태를 띠는 이 함수가 선형성을 만족하는지를 직접 수학적으로 확인하기 위해 선형성의 첫 번째 성질인 ***가법성***을 만족하는 수식 $f(x_1 + x_2) = f(x_1) + f(x_2)$에서 좌변 $f(x_1 + x_2)$과 우변 $f(x_1) + f(x_2)$의 값이 동일한지 확인하는 것으로 판별할 수 있다.     
그림으로 표현하면 [그림 4-3](#그림-4-3-가법성의-검증)과 같다.

###### 그림 4-3 가법성의 검증
![가법성의 검증](/img/)

함수 $f(x) = ax$에 두 미지수 $x_1, x_2$를 대입해 좌변과 우변을 계산한 결과는 다음과 같다.   
- 좌변: $f(x_1 + x_2) = a(x_1 + x_2)$     
- 우변: $f(x_1) + f(x_2) = ax_1 + ax_2$

$a, x_1, x_2$가 모두 ***체의 성질***을 가지는 실수라면 ***분배법칙***에 의해 $a(x_1 + x_2) = ax_1 + ax_2$가 성립한다.   
따라서 함수 $f(x) = ax$는 ***가법성***을 만족함을 알 수 있다.

선형성의 두 번째 성질인 ***1차 동차성***을 만족하는 수식 $f(k \cdot x) = k \cdot f(x)$의 검증 과정을 그림으로 나타내면 [그림 4-4](#그림-4-4-1차-동차성의-검증)와 같다.

###### 그림 4-4 1차 동차성의 검증
![1차 동차성의 검증](/img/)

***1차 동차성***을 만족하는 수식 $f(k \cdot x) = k \cdot f(x)$에 함수 $f(x) = ax$를 적용해 좌변과 우변을 계산한 결과는 다음과 같다.
- 좌변: $f(kx) = a(kx)$
- 우변: $kf(x) = k(ax)$

이때 $a, x, k$가 모두 ***체의 성질***을 가지는 실수라면 ***체는 곱셈에 대해 결합법칙과 교환법칙이 성립***하므로, $a(kx) = k(ax)$가 성립한다.    
따라서 함수 $y = ax$는 ***1차 동차성***을 만족함을 확인할 수 있다.

가법성과 1차 동차성, 두 가지 성질을 만족하는 함수 $y = ax$는 선형성을 만족한다는 사실을 알 수 있다.     
수식을 사용해 [그림 4-5](#그림-4-5-y--x2의-그래프)와 같이 곡선의 형태를 띠는 $f(x) = x^2$과 같은 함수는 선형성을 만족하는지 수학적으로 검증해보자.

###### 그림 4-5 y = x^2의 그래프
![y = x^2의 그래프](/img/)

가법성을 만족하는지 파악하기 위해 가법성을 만족하는 수식 $f(x_1 + x_2) = f(x_1) + f(x_2)$에 함수 $f(x) = x^2$를 적용해 양변을 전개하면 다음과 같다.
- 좌변: $f(x_1 + x_2) = (x_1 + x_2)^2 = x_1^2 + x_2^2 + 2x_1x_2$
- 우변: $f(x_1) + f(x_2) = x_1^2 + x_2^2$

좌변과 우변의 결과가 각기 다르므로 함수 $y = x^2$은 가법성을 만족하지 못하므로 ***선형성을 만족하는 함수가 아님***을 확인할 수 있다.

함수 $f(x) = ax$에 스칼라 $b$를 더한 $f(x) = ax + b$는 선형성을 만족하는지 확인하기 위해 [그림 4-6](#그림-4-6-y--ax--b의-그래프)과 같이 그래프로 그려보면 직선 형태를 띤다.

###### 그림 4-6 y = ax + b의 그래프
![y = ax + b의 그래프](/img/)

함수 $f(x) = ax + b$에 가법성을 판별하는 수식의 좌변과 우변에 두 미지수 $x_1, x_2$를 대입한 결과는 다음과 같다.
- 좌변: $f(x_1 + x_2) = a(x_1 + x_2) + b$
- 우변: $f(x_1) + f(x_2) = ax_1 + ax_2 + 2b$

두 변의 계산 결과는 $b$만큼 차이가 나게 되어 원점을 지나지 않는 함수 $f(x) = ax + b$는 가법성을 만족하지 못함을 확인할 수 있다.     
***선형성이란 단지 곧게 뻗은 직선의 성질을 뜻하는 것이 아니라, 두 집합의 순수한 비(Ratio)로 구성된 1차적 대응 관계를 의미한다***.     
함수 $f(x) = ax$에서 대응되는 ***두 집합***은 ***순수한 비***로 구성되어 있기 때문에 다른 입력값을 투여했을 때 어떤 출력값이 나올지 쉽게 예측할 수 있으며, 반대로 ***역함수*** $f(x) = \frac{1}{a}x$를 사용하면 ***출력값으로부터 입력값을 거꾸로 계산***하는 것이 가능하다.

# 10.2. 벡터 공간의 선형 변환
입력과 출력을 2차원 벡터 공간으로 설정한 상황에서 선형성을 가지는 함수에 대해 알아보자.     
정의역에 해당하는 벡터 공간을 $V$, 그 원소를 $\vec{v}$로, 공역에 해당하는 벡터 공간을 $W$, 그 원소 $\vec{w}$로 표시하고 두 벡터 공간의 대응관계를 표현하면 [그림 4-7](#그림-4-7-벡터를-입출력으로-하는-함수)과 같다.

###### 그림 4-7 벡터를 입출력으로 하는 함수
![벡터를 입출력으로 하는 함수](/img/)

2차원 벡터를 입력받고 2차원 벡터를 출력하는 함수에서 선형성을 가지는 함수를 설계해보자.     
입력에 사용한 2차원 벡터가 $(x, y)$로 구성되어 있는 경우, $x$와 $y$는 서로 독립된 관계를 형성한다.

***선형성을 가지는 함수는 순수한 비의 형태로 구성되어 있다***.    
따라서 $x$와 $y$ 각각에 대해 선형성을 유지하고자 한다면 이들은 $ax$와 $by$ 같은 ***단순 비의 형태를 사용***할 것이고, 이를 섞은 최종 결과는 ***각 비의 결과를 더한*** $ax + by$의 형태가 될 것이다.     
따라서 2차원 벡터를 입출력으로 사용하는 선형성을 가지는 함수는 다음과 같이 설계할 수 있다.
$$f(\vec{v}) = f(x, y) = (ax + by, cx + dy)$$

가법성 확인.
- 좌변의 식:

$$
\begin{matrix}
f(\vec{v_1} + \vec{v_2}) & = & f(x_1 + x_2, y_1 + y_2) \\
& = & (a(x_1 + x_2) + b(y_1 + y_2), c(x_1 + x_2) + d(y_1 + y_2))
\end{matrix}
$$

- 우변의 식:

$$
\begin{matrix}
f(\vec{v_1}) + f(\vec{v_2}) &=& (ax_1 + by_1, cx_1 + dy_1) + (ax_2 + by_2, cx_2 + dy_2) \\
&=& (ax_1 + ax_2 + by_1 + by_2, cx_1 + cx_2 + dy_1 + dy_2) \\
&\therefore& f(\vec{v_1} + \vec{v_2}) = f(\vec{v_1}) + f(\vec{v_2})
\end{matrix}
$$

1차 동차성 확인.
- 좌변의 식:
$$
kf(\vec{v}) = (kax + kby, kcx + kdy)
$$

- 우변의 식:
$$
f(k\vec{v}) = (akx + bky, ckx + dky) \\
\therefore kf(\vec{v}) = f(k\vec{v})
$$

함수 $f(x, y) = (ax + by, cx + dy)$는 ***가법성***과 ***1차 동차성***을 만족하므로 ***선형 함수***다.     
***표준기저벡터의 선형 결합으로 형성된 벡터 공간은 선형성을 지닌다***.    
이 벡터 공간을 ***선형 함수***로 ***변화***시킨 새로운 공간도 기저벡터의 선형 결합으로 형성되므로 선형성을 지닌다.  
이렇게 두 공간이 동일한 구조를 지닐 때 두 공간의 대응 관계를 ***변환(Transoformation)*** 이라고도 부른다.  
따라서 선형성을 유지시켜주는 선형 함수 $f(x, y) = (ax + by, cx + dy)$는 ***선형 변환(Linear transformation)*** 이라고 한다.

벡터 공간에서 발생하는 선형 변환의 원리는 ***크기 변환***이나 ***회전 변환***과 관련이 있다.    
임의의 벡터 $\vec{v}$의 크기를 $k$배 늘리는 작업은 다음과 같이 스칼라 곱셈으로 표현이 가능했다.
$$f(\vec{v}) = f(x, y) = (kx, ky)$$

이는 $(ax + by, cx + dy)$의 형식에 $a = k, b = 0, c = 0, d = k$를 대입한 결과와 동일하므로 선형 변환임을 알 수 있다.    
그리고 임의의 벡터 $\vec{v}$를 각 $\theta$만큼 회전시키는 작업은 다음과 같은 함수로 표현이 가능했다.
$$f(\vec{v}) = f(x, y) = (\cos \theta x - \sin \theta y, \sin \theta x + \cos \theta y)$$

이 역시 $(ax + by, cx + dy)$의 형식에서 $a = \cos \theta, b = -\sin \theta, c = \sin \theta, d = \cos \theta$ 값인 셈이므로 선형 변환이다.  
벡터 공간에서의 선형 변환은 앞서 살펴본 단순한 비례 관계로 구성된 선형 함수 $f(x) = ax$처럼 두 집합의 순수한 비를 통해 ***예측할 수 있는 형태로 변환***되며, ***역함수를 통해 변환 후의 벡터로부터 변환 전의 벡터를 파악할 수 있다***.

선형 변환의 계산 과정을 체계화하여 손쉽게 계산할 수 있는 편리한 도구를 발명했는데, 그것이 바로 ***행렬(Matrix)*** 이다.

# 11. 행렬
***행렬은 수를 사각형의 형태로 행과 열을 맞춰 배열한 테이블이다***.   
따라서 $n$개의 행과 $m$개의 열로 구성된 반듯한 사각형의 형태를 띤다.    
예를 들어 $2 \times 3$ 행렬은 다음과 같이 2행 3열의 형태를 띤다.

$$
\begin{bmatrix}
a & b & c \\
d & e & f \\
\end{bmatrix}
$$

행렬은 ***선형 변환***과 ***벡터***를 나타내는 데 사용된다.     
***벡터는 한 줄로 구성된 행렬로 표현***되며, 가로와 세로 두 가지 표현 방식이 존재한다.    
$(x, y)$로 구성된 2차원의 벡터는 다음과 같은 행렬로 표기할 수 있는데, $A$는 ***열벡터***, $B$는 ***행벡터***라고 부른다.

$$A = 
\begin{bmatrix} 
x \\
y \\
\end{bmatrix}
$$

$$B = 
\begin{bmatrix}
x & y
\end{bmatrix}
$$

***선형 변환***을 표현할 때는 행과 열이 크기가 같은 ***정방행렬(Square matrix)*** 을 사용한다.   
2차원 벡터 공간의 선형 변환 $f(x, y) = (ax + by, cx + dy)$는 $2 \times 2$ 크기의 정방행렬로 표현하는데, 이에 대응하는 행렬 $A$는 다음과 같다.

$$
A = 
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix}
$$

정방행렬 $A$는 ***2개의 행벡터 또는 2개의 열벡터로 구성***된다고 할 수 있다.  
정방행렬 $A$를 행벡터와 열벡터로 분석하면, 첫 번째 행벡터 $A_{row1}$은 $(a, b)$, 두 번째 행벡터 $A_{row2}$는 $(c, d)$이고, 첫 번째 열벡터 $A_{col1}$은 $(a, c)$, 두 번째 열벡터 $A_{col2}$는 $(b, d)$가 된다.
$$A_{row1} = (a, b)$$

$$A_{row2} = (c, d)$$

$$A_{col1} = (a, c)$$

$$A_{col2} = (b, d)$$

# 11.1. 행렬의 기본 연산
행렬은 사각형의 형태로 수를 배열한 것에 불과하지만 지정된 계산 방법을 통해 많은 문제를 해결할 수 있다.  
- 행렬과 행렬의 덧셈
- 행렬과 스칼라의 곱셈
- 행렬의 전치(Transpose of a matrix)
- 행렬과 행렬의 곱셈(줄여서 행렬 곱이라 부름)

***행렬과 행렬의 덧셈은 행렬의 크기가 같은 경우에만 성립***되며, 다음과 같이 ***같은 위치의 원소끼리 더한다***.

$$A + B = 
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix} +
\begin{bmatrix}
e & f \\
g & h \\
\end{bmatrix} =
\begin{bmatrix}
a + e & b + f \\
c + g & d + h \\
\end{bmatrix}
$$

행렬에 스칼라를 곱하는 연산은 다음과 같이 ***행렬을 구성하는 모든 원소에 스칼라를 곱한다***.

$$k \cdot A = k \cdot 
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix} =
\begin{bmatrix}
k \cdot a & k \cdot b \\
k \cdot c & k \cdot d \\
\end{bmatrix}
$$

행렬의 전치연산은 첨자 $T$로 표시하는데 ***행과 열을 바꾸는 작업을 수행***한다.   
예를 들어 $3 \times 2$ 행렬의 전치연산은 $2 \times 3$ 행렬이 된다.

$$
\begin{bmatrix}
a & d \\
b & e \\
c & f \\
\end{bmatrix}^{T} = 
\begin{bmatrix}
a & b & c \\
d & e & f \\
\end{bmatrix}
$$

행과 열의 크기가 같은 정방행렬의 전치연산은 행과 열의 정보가 동일한 ***대각 성분의 원소***는 그대로 유지되고, 나머지 원소는 대각 성분을 중심으로 대칭된 행렬을 만든다.    
아래 $2 \times 2$ 행렬의 전치연산을 살펴보면 대각 성분 $a$와 $d$는 동일하고 $b$와 $c$의 위치가 서로 바뀐 것을 볼 수 있다.

$$
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix}^{T} = 
\begin{bmatrix}
a & c \\
b & d \\
\end{bmatrix}
$$

# 11.2. 행렬의 곱셈
***행렬의 곱셈은 앞에 위치한 행렬의 행벡터와 뒤에 위치한 행렬의 열벡터를 각각 곱하는 방식으로 진행된다***.    
예를 들어 $2 \times 2$ 행렬의 곱셈은 [그림 4-8](#그림-4-8-행렬의-곱셈)에서의 화살표 방향으로 전개된다.

###### 그림 4-8 행렬의 곱셈
![행렬의 곱셈](/img/)

행렬 곱셈의 중요한 성질 중 하나는 ***교환법칙이 성립하지 않는다***는 점이다.  
실제로 두 행렬의 순서를 바꿔 곱셈을 하면 다른 결과가 나온다.

$$A \cdot B = 
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix} \cdot
\begin{bmatrix}
e & f \\
g & h \\
\end{bmatrix} =
\begin{bmatrix}
ae + bg & af + bh \\
ce + dg & cf + dh \\
\end{bmatrix}
$$

$$B \cdot A =
\begin{bmatrix}
e & f \\
g & h \\
\end{bmatrix} \cdot
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix} = 
\begin{bmatrix}
ae + cf & be + df \\
ag + ch & bg + dh \\
\end{bmatrix}
$$

$$\therefore A \cdot B \neq B \cdot A$$

한편, 행렬은 다음과 같이 ***결합법칙을 만족***한다.

$$
\begin{matrix}
A \cdot (B \cdot C) &=& 
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix} \cdot
(
    \begin{bmatrix}
    e & f \\
    g & h \\
    \end{bmatrix} \cdot
    \begin{bmatrix}
    i & j \\
    k & l \\
    \end{bmatrix}
) \\
&=&
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix} \cdot
\begin{bmatrix}
ei + fk & ej + fl \\
gi + hk & gj + hl \\
\end{bmatrix} \\
&=&
\begin{bmatrix}
aei + afk + bgi + bhk & aej + afl + bgj + bhl \\
cei + cfk + dgi + dhk & cej + cfl + dgj + dhl \\
\end{bmatrix}
\end{matrix}
$$

$$
\begin{matrix}
(A \cdot B) \cdot B &=&
(
    \begin{bmatrix}
    a & b \\
    c & d \\
    \end{bmatrix} \cdot
    \begin{bmatrix}
    e & f \\
    g & h \\
    \end{bmatrix}
) \cdot
\begin{bmatrix}
i & j \\
k & l \\
\end{bmatrix} \\
&=&
\begin{bmatrix}
ae + bg & af + bh \\
ce + dg & cf + dh \\
\end{bmatrix} \cdot
\begin{bmatrix}
i & j \\
k & l \\
\end{bmatrix} \\
&=&
\begin{bmatrix}
aei + bgi + afk + bhk & aej + bgj + afl + bhl \\
cei + dgi + cfk + dhk & cej + dgj + cfl + dhl \\
\end{bmatrix}
\end{matrix}
$$

$$\therefore (A \cdot B) \cdot C = A \cdot (B \cdot C)$$

행렬 곱의 특징 중 하나는, 행렬 곱을 전치한 결과는 순서를 바꾼 후 각각 전치해 곱한 결과와 동일하다는 것이다.

$$(A \cdot B)^{T} = 
\begin{bmatrix}
ae + bg & af + bh \\
ce + dg & cf + dh \\
\end{bmatrix}^{T} =
\begin{bmatrix}
ae + bg & ce + dg \\
af + bh & cf + dh \\
\end{bmatrix}
$$

$$B^T \cdot A^T = 
\begin{bmatrix}
e & g \\
f & h \\
\end{bmatrix} \cdot
\begin{bmatrix}
a & c \\
b & d \\
\end{bmatrix} =
\begin{bmatrix}
ea + gh & ec + gd \\
fa + hb & fc + hd \\
\end{bmatrix}
$$

$$\therefore (A \cdot B)^T = B^T \cdot A^T$$

$a, b, c, d$ 네 개의 원소로 구성된 $2 \times 2$ 정방행렬과 2차원 벡터 $(x, y)$를 열벡터로 설정한 두 행렬의 곱은 다음과 같이 전개된다.

$$
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix} \cdot
\begin{bmatrix}
x \\
y \\
\end{bmatrix} =
\begin{bmatrix}
ax + by \\
cx + dy \\
\end{bmatrix}
$$

행렬 곱의 결과는 2차원 벡터 공간의 선형 변환 $f(x, y) = (ax + by, cx + dy)$와 동일하다.     
따라서 $2 \times 2$ ***정방행렬*** $A$는 ***2차원 공간의 선형 변환에 대응되는 함수***를 의미하고, 이 수식은 $f(x, y) = (ax + by, cx + dy)$ ***2차원 벡터에 선형 변환을 적용해 새로운 벡터를 생성하는 작업***으로 해석할 수 있다.  
또한, ***벡터에 선형 변환을 적용하기 위한 연산 순서는 오른쪽에서 왼쪽 방향으로 이뤄짐***을 알 수 있다.

# 11.3. 정방행렬의 곱셈
$2 \times 2$ 정방행렬이 2차원 벡터 공간의 선형 변환에 대응된다면, $2 \times 2$ ***정방행렬 간의 곱은 합성함수에 대응되는 연산이다***.

벡터 $\vec{v}$에 선형 변환을 나타내는 $2 \times 2$ 정방행렬 $A, B$를 순서대로 연산한다고 가정하면, ***연산 순서는 오른쪽에서 왼쪽으로 진행***되므로 이의 수식은 다음과 같다.

$$B \cdot A \cdot \vec{v}$$

이는 다음 [그림 4-9](#그림-4-9-두-번의-선형-변환을-순서대로-적용한-예시)와 같이 세 개의 2차원 벡터 공간 $V, U, W$에 대해 두 번의 선형 변환을 거쳐 벡터 공간 $V$에 속한 벡터 $\vec{v}$가 벡터 공간 $W$의 벡터 $\vec{w}$에 대응되는 관계로 해석할 수 있다.

###### 그림 4-9 두 번의 선형 변환을 순서대로 적용한 예시
![두 번의 선형 변환을 순서대로 적용한 예시](/img/)

선형 변환을 담당하는 정방행렬 $A, B$와 벡터 $\vec{v}$의 각 요소를 다음과 같이 행렬로 나타낸다.

$$B = 
\begin{bmatrix}
e & f \\
g & h \\
\end{bmatrix}
$$

$$A = 
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix}
$$

$$\vec{v} = 
\begin{bmatrix}
x \\
y \\
\end{bmatrix}
$$

벡터 $\vec{v}$가 벡터 $\vec{w}$로 변환되는 과정은 다음과 같은 행렬 곱으로 표현할 수 있다.

$$\vec{w} = 
\begin{bmatrix}
e & f \\
g & h \\
\end{bmatrix} \cdot
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix} \cdot
\begin{bmatrix}
x \\
y \\
\end{bmatrix}
$$

***합성함수에 대응하는 행렬의 곱셈 역시 결합법칙을 만족한다***.   
따라서 행렬의 연산 순서를 바꿔도 최종 계산된 벡터 $\vec{w}$ 값은 동일하다.  
미지수로 구성된 정방행렬과 벡터를 사용해 이를 확인할 수 있다.

$$
\begin{matrix}
A \cdot \vec{v} = 
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix} \cdot
\begin{bmatrix}
x \\
y \\
\end{bmatrix} =
\begin{bmatrix}
ax + by \\
cx + dy \\
\end{bmatrix} \\
B \cdot (A \cdot \vec{v}) = 
\begin{bmatrix}
e & f \\
g & h \\
\end{bmatrix} \cdot
\begin{bmatrix}
ax + by \\
cx + by \\
\end{bmatrix} =
\begin{bmatrix}
e(ax + by) + f(cx + dy) \\
g(ax + by) + h(cx + dy) \\
\end{bmatrix}
\end{matrix}
$$

$$
\begin{matrix}
B \cdot A =
\begin{bmatrix}
e & f \\
g & h \\
\end{bmatrix} \cdot
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix} =
\begin{bmatrix}
ae + cf & be + df \\
ag + ch & bg + dh \\
\end{bmatrix} \\
(B \cdot A) \cdot \vec{v} = 
\begin{bmatrix}
x(ae + cf) + y(be + df) \\
x(ag + ch) + y(bg + dh) \\
\end{bmatrix}
\end{matrix}
$$

1번 식과 2번 식은 동일한 값이므로 다음 식이 성립한다.

$$\vec{W} = B \cdot (A \cdot \vec{v}) = (B \cdot A) \cdot \vec{v}$$

이처럼 ***결합법칙이 성립하는 행렬 곱의 성질***은 ***컴퓨터 그래픽 연산***에서 아주 유용하게 활용된다.  
예를 들어 100개의 점으로 구성된 물체가 모니터에 표현되기까지 5번의 선형 변환이 발생한다고 가정해보자.   
물체의 점을 각각 $\vec{v_1}...\vec{v_{100}}$으로 표기하고 선형 변환을 수행하는 행렬을 각각 $A, B, C, D, E$라고 하면 컴퓨터가 수행해야 할 계산은 다음과 같다.

$$
\begin{matrix}
E \cdot D \cdot C \cdot B \cdot A \cdot \vec{v_1} \\
... \\
E \cdot D \cdot C \cdot B \cdot A \cdot \vec{v_{100}} \\
\end{matrix}
$$

각 점마다 5번의 행렬 곱이 수행되므로 100개 점에 대한 행렬 곱의 총 횟수는 500이 될 것이다.

$$5 \cdot 100 = 500$$

이때 결합법칙이 성립하는 행렬 연산의 특징을 사용하면 계산량을 줄이되 동일한 결과를 얻을 수 있다.    
다음과 같이 행렬 곱을 4번 수행해서 합성함수에 해당하는 행렬 $F$를 미리 만들어둘 수 있다.

$$F = E \cdot D \cdot C \cdot B \cdot A$$

이제 각 점에 대해 미리 계산된 행렬 $F$만 곱하면 동일한 결과가 나온다.

$$
\begin{matrix}
F \cdot \vec{v_1} \\
... \\
F \cdot \vec{v_{100}} \\
\end{matrix}
$$

이 경우 100개 점에 대한 행렬 곱의 총 횟수는 최초 합성 변환을 만들기 위한 4번의 행렬 곱과 벡터마다 1번의 행렬 곱이 수행되므로 104가 된다.

$$4 + 1 \cdot 100 = 104$$

이의 결과는 앞서 구한 500번의 행렬 곱 연산과 동일하다.  
가상 공간의 한 캐릭터를 표현하는 데 보통 10만 개의 점이 사용되므로, 컴퓨터 그래픽에서 행렬은 가상 세계를 구축하는 데 필요한 계산량을 크게 줄여주는 중요한 역할을 수행한다는 사실을 알 수 있다.

> 참고: ***열 기준 행렬과 행 기준 행렬***     
행렬과 벡터의 곱셈을 수행하는 방식으로, 열 기준 행렬(Column major matrix)과 행 기준 행렬(Row major matrix) 두 가지가 있다.  
수학에서 행렬을 다룰 때는, 벡터를 열벡터로 나타내는 열 기준 행렬 방식을 주로 사용한다.
>
> $$
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix} \cdot
\begin{bmatrix}
x \\
y \\
\end{bmatrix} =
\begin{bmatrix}
ax + by \\
cx + dy \\
\end{bmatrix}$$
>
> 컴퓨터에서 실제로 행렬을 응용할 때는, 행 기준 행렬을 사용하는 경우도 있다.    
행 기준으로 선형 변환을 수행할 때는 열 기준과 다르게 행렬과 벡터의 위치를 거꾸로 뒤집어서, 다음과 같이 벡터를 앞쪽에 두어야 행렬의 곱셈이 성립된다.
>
> $$
\begin{bmatrix}
x & y
\end{bmatrix} \cdot
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix} =
\begin{bmatrix}
ax + cy & bx + dy
\end{bmatrix}$$
>
> 이와 같이 정방행렬 $A$의 요소를 열 기준 방식과 동일하게 배치한다면 행렬 곱셈의 결과는 다른 값이 나온다.   
>
> $$(ax + by, cx + dy) \neq (ax + cy, bx + dy)$$
>
> 원하는 결과는 $(ax + by, cx + dy)$이므로 열 기준 행렬 방식을 사용한다면 정방행렬 $A$의 요소는 다음과 같이 배치해야 할 것이다.
>
> $$
\begin{bmatrix}
x & y
\end{bmatrix} \cdot
\begin{bmatrix}
a & c \\
b & d \\
\end{bmatrix} =
\begin{bmatrix}
ax + by & cx + dy
\end{bmatrix}$$
>
> 이는 행 기준 방식의 정방행렬 $A$를 전치시킨 결과와 동일하다.
>
> $$
\begin{bmatrix}
a & c \\
b & d \\
\end{bmatrix} = 
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix}^T$$
>
> 행 기준 방식을 사용하는 대표적인 사례로는 게임 그래픽스 라이브러리인 다이렉트X(DirectX)가 있으며, 열 기준 방식을 사용하는 게임 그래픽스 라이브러리로는 오픈GL(OpenGL)이 있다.     
유니티(Unity) 엔진은 C# 스크립트에서 열 기준 방식을 사용하고, 언리얼(Unreal) 엔진의 C++ 코드는 행 기준 방식을 사용한다.     
이렇게 그래픽 라이브러리와 애플리케이션마다 행렬을 사용하는 방법은 다르다.      
두 방식 모두 전치연산을 통해 서로 변환할 수 있으므로 방식만 명확하게 이해하고 있다면 응용하는 데 큰 문제는 없다.    
열벡터와 행벡터는 서로 전치 관계에 있기 때문에, 선형 변환 역시 전치 관계의 차이가 있을 뿐이다.
>
> 열 기준 체계에서 설계된 수식을 행 기준에서 가져다 쓰고 싶다면 다음과 같이 전치연산을 적용해 변환하면 된다.
>
> $$(A \cdot \vec{v})^T = \vec{v}^T \cdot A^T$$
>
> $$
(
    \begin{bmatrix}
    a & b \\
    c & d \\
    \end{bmatrix} \cdot
    \begin{bmatrix}
    x \\
    y \\
    \end{bmatrix}
)^T =
\begin{bmatrix}
x \\
y \\
\end{bmatrix}^T \cdot
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix}^T =
\begin{bmatrix}
x & y
\end{bmatrix} \cdot
\begin{bmatrix}
a & c \\
b & d \\
\end{bmatrix}$$
>
> 열 기준 행렬은 행렬의 적용 순서가 오른쪽에서 왼쪽 방향으로 흐르는 역방향으로 진행된다.    
다음 행렬의 곱셈이 열 기준 방식으로 이뤄진다면, 벡터 $v$에 대해 행렬 $A$의 선형 변환이 적용된 후 행렬 $B$의 선형 변환이 적용된다.
>
> $$B \cdot A \cdot \vec{v} = \vec{W}$$
>
> 이와 같은 열 기준 방식의 변환을 행 기준 방식으로 변환하기 위해 위 식을 전치해보면, 계산은 다음과 같이 왼쪽에서 오른쪽의 순방향으로 진행된다.
>
> $$(B \cdot A \cdot \vec{v})^T = (\vec{W})^T$$
> 
> $$\vec{v}^T \cdot A^T \cdot B^T = (\vec{W})^T$$
>
> 이와 같이 열벡터 행렬을 전치한 결과는 행벡터가 된다.  
따라서 행벡터 변환 방식을 사용한다면 행렬의 적용 순서는 왼쪽에서 오른쪽의 순방향으로 진행되므로 이 점을 주의해야 한다.

# 12. 행렬의 설계
$2 \times 2$ ***정방행렬은 2차원 벡터 공간의 선형 변환에 대응한다***.
벡터 공간 $V$를 구성하는 두 표준기저벡터 $(1, 0)$과 $(0, 1)$이 [그림 4-10](#그림-4-10-선형-변환을-통해-기저벡터가-변하는-과정)과 같이 선형 변환을 통해 새로운 벡터 공간 $W$의 벡터 $(a, c)$와 $(b, d)$에 대응되어 변환된다고 생각해보자.

$$(1, 0) \mapsto (a, c)$$

$$(0, 1) \mapsto (b, d)$$

###### 그림 4-10 선형 변환을 통해 기저벡터가 변하는 과정
![선형 변환을 통해 기저벡터가 변하는 과정](/img/)

원 벡터 공간 $V$의 벡터 $\vec{v} = (x, y)$는 다음과 같은 ***표준기저벡터의 선형 결합을 통해 생성***됐다.

$$\vec{v} = (x, y) = x \cdot (1, 0) + y \cdot (0, 1)$$

같은 방법으로 벡터 $\vec{v}$가 선형 변환되는 경우에는 동일한 선형 결합식을 사용해 벡터 $\vec{w}$가 다음과 같이 계산된다.

$$\vec{w} = x(a, c) + y(b, d) = (ax + by, cx + dy)$$

이는 $a, b, c, d$로 만들어진 정방행렬에 벡터 $(x, y)$를 곱한 결과와 동일하다.

$$
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix} \cdot
\begin{bmatrix}
x \\
y \\
\end{bmatrix} =
\begin{bmatrix}
ax + by \\
cx + dy \\
\end{bmatrix}
$$

위의 정방행렬과 표준기저벡터가 변화된 두 벡터 $(a, c)$와 $(b, d)$와의 관계를 분석해보면 이들은 [그림 4-11](#그림-4-11-2개의-표준기저벡터로-구성된-행렬)과 같이 ***정방행렬을 구성하는 열벡터***임을 알 수 있다.

###### 그림 4-11 2개의 표준기저벡터로 구성된 행렬
![2개의 표준기저벡터로 구성된 행렬](/img/)

벡터 공간 $V$의 $(0, 0)$에서 $(1, 1)$까지로 둘러싸인 ***사각형의 부분 공간***을 관찰해 벡터 공간 $V$에서 벡터 공간 $W$로의 선형 변환을 통해 진행되는 부분 공간의 변화는 [그림 4-12](#그림-4-12-부분-공간을-사용한-선형-변환의-관찰)와 같다.

###### 그림 4-12 부분 공간을 사용한 선형 변환의 관찰
![부분 공간을 사용한 선형 변환의 관찰](/img/)

***부분 공간의 변화***를 관찰함으로써 선형 변환을 눈으로 확인할 수 있으며, 이를 활용해 원하는 형태로 공간이 변환되도록 행렬을 설계할 수 있다.

# 12.1. 크기 변환행렬
***크기 변환행렬(Scale transformation matrix)*** 은 물체의 크기를 변경하는 행렬이다.   
크기 변환은 ***각 표준기저벡터를 동일한 방향으로 지정한 크기만큼 늘리는 변환***을 의미한다.   
이를 위해 $(1, 0)$의 좌표를 갖는 $e_1$과 $(0, 1)$의 좌표를 갖는 $e_2$의 두 표준기저벡터를 다음과 같이 변환해보자.
- 표준기저벡터 $e_1$을 $a$배 늘리거나 줄인 벡터: $a \cdot (1, 0) = (a, 0)$
- 표준기저벡터 $e_2$를 $b$배 늘리거나 줄인 벡터: $b \cdot (0, 1) = (0, b)$

$e_1$을 $a$배만큼 늘리고 $e_2$를 $b$배만큼 줄인 선형 변환으로 인한 벡터 공간의 변화는 [그림 4-13](#그림-4-13-크기-변환의-시각화)과 같이 표현할 수 있다.

###### 그림 4-13 크기 변환의 시각화
![크기 변환의 시각화](/img/)

변환된 두 표준기저벡터 $(a, 0)$과 $(0, b)$를 열벡터로 설정해 생성한 크기 변환행렬은 다음과 같다.

$$S = 
\begin{bmatrix}
a & 0 \\
0 & b \\
\end{bmatrix}
$$

# 12.2. 회전 변환행렬
***회전 변환행렬(Rotation transformation matrix)*** 은 주어진 각 $\theta$로 벡터 공간을 회전시킨다.    
$90^\circ$ 회전은 양의 방향(+)에 해당하는 회전과 음의 방향(-) 두 가지가 있는데, 반시계 방향으로 회전하는 양의 방향 $90^\circ$ 회전은 [그림 4-14](#그림-4-14-반시계-방향으로-90도-회전-변환한-결과)와 같이 두 표준기저벡터가 서로 바뀐 형태를 가진다.

###### 그림 4-14 반시계 방향으로 90도 회전 변환한 결과
![반시계 방향으로 90도 회전 변환한 결과](/img/)

두 표준기저벡터는 변환에 의해 다음과 같이 좌표가 변경된다.
- 표준기저벡터 $e_1$을 $90^\circ$ 회전한 벡터: $(0, 1)$
- 표준기저벡터 $e_2$를 $90^\circ$ 회전한 벡터: $(-1, 0)$

따라서 $90^\circ$ 회전 변환을 수행하는 행렬은 다음과 같이 설계할 수 있다.

$$R_{90^\circ} = R_{\frac{\pi}{2}} = 
\begin{bmatrix}
0 & -1 \\
1 & 0 \\
\end{bmatrix}$$

시계 방향으로 진행하는 $-90^\circ$ 회전 변환을 설계해보면 해당 변환은 [그림 4-15](#그림-4-15-시계-방향으로-90도-회전-90도-회전-변환한-결과)와 같이 표현할 수 있다.

###### 그림 4-15 시계 방향으로 90도 회전(-90도 회전) 변환한 결과
![시계 방향으로 90도(-90도 회전) 변환한 결과](/img/)

두 표준기저벡터는 변환에 의해 다음과 같이 좌표가 변경된다.
- 표준기저벡터 $e_1$을 $-90^\circ$ 회전한 벡터: $(0, -1)$
- 표준기저벡터 $e_2$를 $-90^\circ$ 회전한 벡터: $(1, 0)$

따라서 $-90^\circ$ 회전 변환을 수행하는 행렬은 다음과 같이 설계할 수 있다.

$$R_{-90^\circ} = R_{-\frac{\pi}{2}} = 
\begin{bmatrix}
0 & 1 \\
-1 & 0 \\
\end{bmatrix}$$

> 참고: $90^\circ$ ***회전의 구현***    
$(x, y)$의 값을 가지는 벡터 $\vec{v}$를 $90^\circ$로 변환하는 작업은 행렬을 사용하지 않아도 두 값을 바꿔치는 방법으로 간단히 구할 수 있다.  
벡터 $\vec{v}$를 시계 반대 방향으로 $90^\circ$로 회전한 벡터 $\vec{v'}$는 두 값을 바꾸고 첫 번째 요소에 음수를 부여해 얻을 수 있다.
>
> $$\vec{v'} = (-y, x)$$
>
> 벡터 $\vec{v}$를 시계 방향으로 $90^\circ$로 회전한 벡터 $\vec{v'}$는 유사하게 두 값을 바꾸고 두 번째 요소에 음수를 부여하면 얻어진다.
>
> $$\vec{v'} = (y, -x)$$

두 표준기저벡터 $e_1$과 $e_2$가 각 $\theta$만큼 회전한 결과는 각각 [그림 4-16](#그림-4-16-두-표준기저벡터가-각-세타만큼-회전-변환한-결과)의 $(\cos \theta, \sin \theta)$와 $(-\sin \theta, \cos \theta)$가 된다.

###### 그림 4-16 두 표준기저벡터가 각 세타만큼 회전 변환한 결과
![두 표준기저벡터가 각 세타만큼 회전 변환한 결과](/img/)

정리하면 두 표준기저벡터가 각 $\theta$만큼 회전한 좌표는 다음과 같다.
- 표준기저벡터 $e_1$을 $\theta$만큼 회전한 벡터: $(\cos \theta, \sin \theta)$
- 표준기저벡터 $e_2$를 $\theta$만큼 회전한 벡터: $(-\sin \theta, \cos \theta)$

따라서 각 $\theta$에 대한 회전 변환행렬은 다음과 같이 설계할 수 있다.

$$R_\theta = 
\begin{bmatrix}
\cos \theta & -\sin \theta \\
\sin \theta & \cos \theta \\
\end{bmatrix}$$

# 12.3. 전단 변환행렬
표준기저벡터 $e_1$을 고정한 상태에서 표준기저벡터 $e_2$를 $x$축 방향으로 밀면 표준기저벡터 $e_1$은 고정되어 있기 때문에 변환된 결과는 [그림 4-17](#그림-4-17-e1을-고정한-상태에서-e2를-x축-방향으로-미는-변환)과 같이 대각선으로 밀리는 형태를 띤다.   
이를 ***전단 변환행렬(Shear transformation matrix)*** 이라고 한다.

###### 그림 4-17 e1을 고정한 상태에서 e2를 x축 방향으로 미는 변환
![e1을 고정한 상태에서 e2를 x축 방향으로 미는 변환](/img/)

$x$축 방향으로 1만큼 미는 전단 변환에 의해 두 표준기저벡터는 다음과 같이 좌표가 변경된다.
- 표준기저벡터 $e_1$의 변환 결과: $(1, 0)$ (변화 없음)
- 표준기저벡터 $e_2$의 변환 결과: $(1, 1)$

따라서 표준기저벡터 $e_2$를 $x$축 방향으로 1만큼 밀어내는 전단 변환행렬은 다음과 같이 설계할 수 있다.

$$S = 
\begin{bmatrix}
1 & 1 \\
0 & 1 \\
\end{bmatrix}$$

전단 변환에서 미는 크기는 1행 2열에 위치한 원소 값을 변경해 조절이 가능하다.    
만일 [그림 4-18](#그림-4-18-미는-크기에-따른-기저벡터의-변화)과 같이 $x$축 방향으로 $a$ 만큼 민다면 각 표준기저벡터 $e_1$과 $e_2$는 다음과 같이 변환된다.

###### 그림 4-18 미는 크기에 따른 기저벡터의 변화
![미는 크기에 따른 기저벡터의 변화](/img/)

$x$축 방향으로 $a$만큼 미는 전단 변환에 의해 두 표준기저벡터는 다음과 같이 좌표가 변경된다.
- 표준기저벡터 $e_1$의 변환 결과: $(1, 0)$ (변화 없음)
- 표준기저벡터 $e_2$의 변환 결과: $(a, 1)$

그러므로 $x$축 방향으로 $a$만큼 미는 전단 변환행렬은 다음과 같다.

$$S = 
\begin{bmatrix}
1 & a \\
0 & 1 \\
\end{bmatrix}$$

# 12.4. 삼각함수의 덧셈 정리
삼각함수를 응용할 때 유용하게 사용되는 공식에는 삼각함수의 덧셈 정리가 있다.    
$\cos$ 함수와 $\sin$ 함수의 덧셈 정리는 다음과 같다.

$$\cos(\alpha + \beta) = \cos \alpha \cos \beta - \sin \alpha \sin \beta$$

$$\sin(\alpha + \beta) = \sin \alpha \cos \beta + \cos \alpha \sin \beta$$

회전행렬의 원리를 파악하면 행렬 곱을 사용해 덧셈 정리를 유도할 수 있다.     
[그림 4-19](#그림-4-19-두-회전을-합성한-변환과-각각-회전한-변환의-비교)와 같이 회전 변환에 사용하는 두 각 $\alpha$와 $\beta$가 있을 때, 이 둘을 합한 $\alpha + \beta$ 만큼 회전한 변환은 두 각에 대한 회전 변환을 순서대로 적용한 결과와 동일하다.

###### 그림 4-19 두 회전을 합성한 변환과 각각 회전한 변환의 비교
![두 회전을 합성한 변환과 각각 회전한 변환의 비교](/img/)

각 $\alpha$에 대한 회전 변환행렬을 $R_\alpha$로, 각 $\beta$에 대한 회전 변환행렬을 $R_\beta$로 표기한다면 각 회전 변환과 이 둘을 합한 각 $\alpha + \beta$의 회전 변환도 다음과 같은 행렬로 나타낼 수 있다.

$$R_\alpha = 
\begin{bmatrix}
\cos \alpha & -\sin \alpha \\
\sin \alpha & \cos \alpha \\
\end{bmatrix}$$

$$R_\beta = 
\begin{bmatrix}
\cos \beta & -\sin \beta \\
\sin \beta & \cos \beta \\
\end{bmatrix}$$

$$R_{(\alpha + \beta)} = 
\begin{bmatrix}
\cos(\alpha + \beta) & -\sin(\alpha + \beta) \\
\sin(\alpha + \beta) & \cos(\alpha + \beta) \\
\end{bmatrix}$$

각 $\alpha + \beta$의 회전 변환은 각 $\alpha$에 대한 회전 변환을 수행한 후에 각 $\beta$에 대한 회전 변환을 이어서 변환한 결과와 동일하다.   
이를 행렬 곱으로 나타내면 다음과 같다.

$$
\begin{matrix}
R_\beta \cdot R_\alpha &=& 
\begin{bmatrix}
\cos \beta & -\sin \beta \\
\sin \beta & \cos \beta \\
\end{bmatrix}
\begin{bmatrix}
\cos \alpha & -\sin \alpha \\
\sin \alpha & \cos \alpha \\
\end{bmatrix} \\
&=&
\begin{bmatrix}
\cos \alpha \cos \beta - \sin \alpha \sin \beta & -(\cos \alpha \sin \beta + \sin \alpha \cos \beta) \\
\cos \alpha \sin \beta + \sin \alpha \cos \beta & \cos \alpha \cos \beta - \sin \alpha \sin \beta \\
\end{bmatrix} \\
&=&
\begin{bmatrix}
\cos(\alpha + \beta) & -\sin(\alpha + \beta) \\
\sin(\alpha + \beta) & \cos(\alpha + \beta) \\
\end{bmatrix}
\end{matrix}
$$

> 참고: ***삼각함수의 배각 공식***  
삼각함수의 덧셈 정리를 응용한 삼각함수의 배각 공식은 각 $\beta$ 대신 $\alpha$를 대입해 얻을 수 있다.    
>
> $$
\begin{matrix}
\cos 2 \alpha &=& \cos(\alpha + \alpha) \\
&=& \cos^2 \alpha - \sin^2 \alpha \\
&=& 1 - 2 \sin^2 \alpha \\
\end{matrix}$$
>
> $$
\begin{matrix}
\sin 2 \alpha &=& \sin(\alpha + \alpha) \\
&=& 2 \sin \alpha \cos \alpha
\end{matrix}$$

# 13. 역행렬
***선형 변환을 수행하는 행렬은 본질적으로 함수의 성질을 지니기 때문에 항등함수와 역함수에 대응하는 행렬이 존재한다***.    
이를 각각 ***항등행렬(Identity matrix)*** 과 ***역행렬(Inverse matrix)*** 이라고 부른다.

***항등행렬은 원 공간의 변화없이 동일한 공간으로 유지하는 변환***을 의미한다.     
변환된 공간의 표준기저벡터는 원 공간의 표준기저벡터와 동일하다.     
따라서 항등행렬은 표준기저벡터 $(1, 0)$과 $(0, 1)$을 순서대로 넣어 만들 수 있다.    
항등행렬은 $I$로 표기한다.

$$I = 
\begin{bmatrix}
1 & 0 \\
0 & 1 \\
\end{bmatrix}$$

역함수의 정의와 동일하게 ***행렬 곱의 결과가 항등행렬이 나오는 특별한 행렬을 역행렬***이라고 부른다.  
역행렬은 역함수와 동일하게 위 첨자 $^{-1}$을 사용해 표시하며 임의의 행렬을 $A$라고 했을 때 다음의 수식이 성립한다.

$$A \cdot A^{-1} = A^{-1} \cdot A = I$$

역행렬을 시각적으로 나타내본다면 [그림 4-20](#그림-4-20-역행렬의-시각적-의미)과 같이 벡터 공간 $V$가 선형 변환된 벡터 공간 $W$에서 원 벡터 공간 $V$로 되돌리는 선형 변환이라고 할 수 있다.

###### 그림 4-20 역행렬의 시각적 의미
![역행렬의 시각적 의미](/img/)

# 13.1. 역행렬의 존재를 판별하는 행렬식
어떤 함수가 역함수를 갖기 위한 조건은 전단사함수여야한다.     
행렬도 함수이므로 ***두 공간의 변환이 전단사로 대응될 때만 역행렬이 존재***한다.  
***어떤 행렬에 대해 역행렬이 존재하는지 파악할 수 있는 특별한 수식***이 있는데 이를 ***행렬식(Determinant)*** 이라 한다.

행렬식은 $\det()$의 기호로 표시하며, 일반적인 $2 \times 2$ 정방행렬 $A$의 행렬식은 다음과 같이 계산한다.

$$A = 
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix}$$

$$\det(A) = ad - bc$$

행렬식 $\det(A)$의 값이 0인 선형 변환은 전단사 대응이 성립하지 않아 역행렬이 존재하지 않는다.   
예를 들어 행렬이 아래와 같을 경우 

$$A = 
\begin{bmatrix} 
2 & 1 \\ 
1 & 0.5 \\ 
\end{bmatrix}$$

이의 행렬식 $\det(A)$의 값은 다음과 같이 0으로 계산된다.

$$\det(A) = ad - bc = 2 \cdot 0.5 - 1 \cdot 1 = 0$$

이러한 경우 행렬 $A$는 역행렬이 존재하지 않는데, 시각적으로 행렬 $A$의 결과가 어떻게 변환되어 역행렬이 존재하지 않게 되는지 [그림 4-21](#그림-4-21-행렬식이-0인-행렬을-사용한-변환-결과)을 통해 확인할 수 있다.  
행렬 $A$를 분석하면 원 벡터 공간 $V$의 두 표준기저벡터는 각각 $(2, 1)$과 $(1, 0.5)$의 열벡터로 변환됨을 알 수 있다.     
변환된 두 표준기저벡터를 추적하면 ***두 기저벡터의 기울기가 같음***을 알 수 있다.     
이를 시각적으로 분석하면 2차원의 평면 영역이 1차원의 직선 영역으로 압축됐다고 볼 수 있다.

###### 그림 4-21 행렬식이 0인 행렬을 사용한 변환 결과
![행렬식이 0인 행렬을 사용한 변환 결과](/img/)

이렇게 ***차원이 줄어들어 원 공간의 정보가 소멸***되면, 거꾸로 벡터 공간 $W$에서 벡터 공간 $V$로 변환되는 것은 불가능해진다.  
따라서 역행렬이 존재할 수 없다.  

벡터 공간 $V$에서 임의의 행렬

$$A = 
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix}$$

를 사용해 표준기저벡터가 $(a, c)$와 $(b, d)$로 변환된 새로운 벡터 공간 $W$를 생각해보면, 영역을 계산하는 함수를 $Area()$라고 지정했을 때 [그림 4-22](#그림-4-22-선형-변환된-사각형-영역의-넓이)의 왼쪽 그림에서 회색으로 칠해진 두 표준기저벡터가 형성하는 ***정사각형(Square)*** 영역의 넓이는 1이다.   
해당 영역이 행렬에 의해 ***평행사변형(Parallelogram)*** 으로 변환되면 넓이도 변화될 것이다.

###### 그림 4-22 선형 변환된 사각형 영역의 넓이
![선형 변환된 사각형 영역의 넓이](/img/)

변환된 두 벡터가 이루는 평행사변형의 넓이는 [그림 4-23](#그림-4-23-평행사변형-영역의-넓이)과 같다.

###### 그림 4-23 평행사변형 영역의 넓이
![평행사변형 영역의 넓이](/img/)

[그림 4-23](#그림-4-23-평행사변형-영역의-넓이)의 평행사변형의 넓이 $Area(P)$는 전체 사각형의 넓이에서 평행사변형을 제외한 삼각형과 사각형 영역을 빼서 구할 수 있는데, 이 값은 앞에서 구한 행렬식 $\det(A)$와 동일하다.

$$
\begin{matrix}
Area(P) &=& (a + b) \cdot (c + d) - 2 \cdot (\frac{1}{2}ac) - 2 \cdot (\frac{1}{2}bd) - bc - bc \\
&=& (a + b) \cdot (c + d) - ac - bd - 2bc \\
&=& ad - bc
\end{matrix}$$

따라서 이렇게 계산된 넓이, 즉 ***행렬식 값이 0인 경우에는 해당 평행사변형의 넓이는 소멸***되면서 평면의 모든 요소는 1차원 선 위에 놓이게 되어 이후에는 더 이상 2차원으로 돌아갈 수 없게 된다.

> 참고: ***행렬식 계산 결과가 음수가 나오는 경우***     
[그림 4-24](#그림-4-24-행렬식-값이-음수가-나오는-경우)와 같이 표준기저벡터 $e_1$이 변환된 결과 $(a, c)$가 표준기저벡터 $e_2$가 변환된 결과 $(b, d)$보다 상단에 위치한 상황을 생각해보면, 두 벡터를 구성하는 $a, b, c, d$ 값은 모두 양수인데 $b$는 $a$보다 크고 $c$는 $d$보다 크다.     
따라서 행렬식 $ad - bc$의 계산 결과는 음수가 나온다.
>
> ###### 그림 4-24 행렬식 값이 음수가 나오는 경우
> ![행렬식 값이 음수가 나오는 경우](/img/)
>
> 그림으로 두 표준기저벡터의 변환 과정을 추적해보면 보라색은 위로, 청록색은 아래로 가면서 평면이 뒤집혔다고 생각할 수 있다.     
따라서 행렬식 값은 단순히 면적의 변화를 측정하는 것뿐만 아니라 부호를 통해 평면이 원 공간과 동일한 면으로 설정되어 있는지, 뒤집힌 반대면으로 설정되어 있는지를 파악할 수 있다.

# 13.2. 크기 변환행렬의 역행렬
크기 변환행렬의 역행렬은 [그림 4-25](#그림-4-25-크기-변환의-역변환)와 같이 변화된 크기만큼 거꾸로 크기를 변화시키는 방법으로 구할 수 있다.     
크기 변환행렬 $S$는 다음과 같다.

$$S = 
\begin{bmatrix}
a & 0 \\
0 & b \\
\end{bmatrix}$$

크기 변환에 사용한 ***두 원소의 역수***를 사용해 크기 변환을 설계하면 변환된 두 기저벡터는 다시 표준기저벡터로 돌아온다.

###### 그림 4-25 크기 변환의 역변환
![크기 변환의 역변환](/img/)

원 공간에서 $x$축을 $a$배, $y$축을 $b$배만큼 크기를 변화시킨 크기 변환행렬 $S$의 역행렬 $S^{-1}$는 다음과 같이 $a$와 $b$의 역수를 대입해 구할 수 있다.

$$S^{-1} = 
\begin{bmatrix}
\frac{1}{a} & 0 \\
0 & \frac{1}{b} \\
\end{bmatrix}$$

# 13.3. 전단 변환행렬의 역행렬
전단 변환행렬 $S$는 다음과 같다.

$$S = 
\begin{bmatrix}
1 & a \\
0 & 1 \\
\end{bmatrix}$$

[그림 4-26](#그림-4-26-전단-변환의-역변환)과 같이 표준기저벡터 $e_1$을 고정한 상태에서 민 방향의 반대 방향으로 밀면 밀린 공간은 원대래로 돌아온다.

###### 그림 4-26 전단 변환의 역변환
![전단 변환의 역변환](/img/)

원 공간에서 $x$축으로 $a$만큼 민 전단 변환행렬 $S$의 역행렬 $S^{-1}$는 $a$의 반대수를 대입해 다음과 같이 구할 수 있다.

$$S^{-1} = 
\begin{bmatrix}
1 & -a \\
0 & 1 \\
\end{bmatrix}$$

# 13.4. 회전 변환행렬의 역행렬
회전 변환행렬 $R$은 다음과 같다.

$$R = 
\begin{bmatrix}
\cos \theta & -\sin \theta \\
\sin \theta & \cos \theta \\
\end{bmatrix}$$

회전각 $\theta$에 대한 회전 변환행렬의 역행렬은 [그림 4-27](#그림-4-27-회전-변환의-역변환)과 같이 반대방향의 회전각 $-\theta$에 대한 회전 변환을 의미한다.

$$R^{-1}_\theta = R_{(-\theta)}$$

###### 그림 4-27 회전 변환의 역변환
![회전 변환의 역변환](/img/)

$\sin$ 함수와 $\cos$ 함수는 다음과 같은 성질이 있다.

$$\cos(-\theta) = \cos(\theta)$$

$$\sin(-\theta) = -\sin(\theta)$$

이를 활용하면 회전행렬의 역행렬은 다음과 같이 정리할 수 있다.

$$R^{-1}_\theta = R_{(-\theta)} = 
\begin{bmatrix}
\cos \theta & \sin \theta \\
-\sin \theta & \cos \theta \\
\end{bmatrix}$$

역행렬에서 부호가 변하지 않는 $\cos$ 함수는 ***대각선 영역에만 위치***하므로 회전행렬과 이것의 역행렬은 서로 ***전치 관계***에 있다.

$$R_\theta = 
\begin{bmatrix}
\cos \theta & -\sin \theta \\
\sin \theta & \cos \theta \\
\end{bmatrix}$$

$$R^{-1}_\theta = 
\begin{bmatrix}
\cos \theta & \sin \theta \\
-\sin \theta & \cos \theta \\
\end{bmatrix}$$

따라서 ***회전행렬의 역행렬은 별도로 삼각함수를 사용하지 않아도 기존 행렬에 전치연산을 적용하는 방법으로 쉽게 구할 수 있다***.

$$R^{-1}_\theta = R^T_\theta$$

# 13.5. 행렬 곱의 역행렬
합성함수의 역함수에 대해 다음의 수식이 성립된다.

$$(g \circ f)^{-1} = f^{-1} \circ g^{-1}$$

합성함수에 해당하는 두 행렬 곱의 역행렬도 동일하게 다음의 수식이 성립한다.

$$(A \cdot B)^{-1} = B^{-1} \cdot A^{-1}$$

역행렬이 존재하는 두 행렬 $A$와 $B$를 곱한 행렬을 $C$라고 가정해보자.

$$A \cdot B = C$$

행렬 $C$의 역행렬이 존재한다면 다음과 같은 식이 성립한다.

$$C \cdot C^{-1} = I$$

이 식에서 $C$에 행렬 $A$와 $B$를 대입해 풀어 쓰면 다음과 같다.

$$(A \cdot B) \cdot (A \cdot B)^{-1} = I$$

이 식의 양변에 $A$의 역행렬 $A^{-1}$을 곱하면 다음과 같이 전개된다.

$$A^{-1} \cdot (A \cdot B) \cdot (A \cdot B)^{-1} = A^{-1}$$

행렬의 곱은 결합법칙이 성립하므로 이 식은 다음과 같이 전개할 수 있다.

$$(A^{-1} \cdot A) \cdot B \cdot (A \cdot B)^{-1} = A^{-1}$$

$A^{-1} \cdot A$은 항등행렬이므로 이 식은 다음과 같이 간략화된다.

$$B \cdot (A \cdot B)^{-1} = A^{-1}$$

이번에는 양 변에 $B$의 역행렬 $B^{-1}$을 곱한다.

$$B^{-1} \cdot B \cdot (A \cdot B)^{-1} = B^{-1} \cdot A^{-1}$$

$B^{-1} \cdot B$ 역시 항등행렬이므로 이를 소거하면 $(A \cdot B)^{-1} = B^{-1} \cdot A^{-1}$가 증명됨을 확인할 수 있다.

$$(A \cdot B)^{-1} = B^{-1} \cdot A^{-1}$$

# 14. 이동 변환을 위한 아핀 공간
$2 \times 2$ ***정방 행렬의 곱셈으로는 2차원 평면에서의 이동을 구현할 수 없다***.     
임의의 벡터 $(x, y)$를 지정한 크기 $(a, b)$만큼 이동시키는 기능은 다음과 같이 행렬의 덧셈으로 구할 수 있다.

$$
\begin{bmatrix}
x \\
y \\
\end{bmatrix} + 
\begin{bmatrix}
a \\
b \\
\end{bmatrix} = 
\begin{bmatrix}
x + a \\
y + b \\
\end{bmatrix}$$

하지만 다음의 행렬 곱을 만족하는 정방행렬 $A$는 존재하지 않는다.

$$A \cdot
\begin{bmatrix}
x \\
y \\
\end{bmatrix} =
\begin{bmatrix}
x + a \\
y + b \\
\end{bmatrix}$$

그 이유를 시각적으로 살펴보면, [그림 5-1](#그림-5-1-선형-변환의-형태를-벗어나는-이동-변환)과 같이 ***표준기저벡터의 원점을 이동시키는 변환이 행렬이 되기 위해서는 선형성을 만족***해야 하는데, ***선형성이 되기 위해서는 기저벡터가 원점에서부터 출발해야 한다***는 조건을 만족해야 하기 때문이다.

###### 그림 5-1 선형 변환의 형태를 벗어나는 이동 변환
![선형 변환의 형태를 벗어나는 이동 변환](/img/)

공간의 차원을 하나 더 늘린다면 이를 구현하는 것이 가능하다.     
[그림 5-2](#그림-5-2-차원을-하나-높여-선형-변환으로-이동을-구현하기)와 같이 물체를 표현하는데 두 개의 차원을 사용하고, ***차원 하나를 더 추가해 선형 변환을 위한 원점과의 연결고리로 활용***한다면 선형 변환의 형태로 이동을 구현할 수 있다.

###### 그림 5-2 차원을 하나 높여 선형 변환으로 이동을 구현하기
![차원을 하나 높여 선형 변환으로 이동을 구현하기](/img/)

선형 변환의 한 종류인 전단 변환은 [그림 5-3](#그림-5-3-전단-변환으로-발생하는-공간의-변화)처럼 표준기저벡터 $e_1$을 고정시킨 상태에서 옆으로 밀어 공간을 기울이는 특징을 지닌다.  
[그림 5-3](#그림-5-3-전단-변환으로-발생하는-공간의-변화)은 2차원에서 전단 변환의 변화를 나타낸 그림이다.  
(a)는 $x$축으로 1만큼 밀었을 때의 공간의 변화를 나타내고 (b)는 $x$축으로 2만큼 밀었을 때의 변화를 나타낸다.

###### 그림 5-3 전단 변환으로 발생하는 공간의 변화
![전단 변환으로 발생하는 공간의 변화](/img/)

[그림 5-4](#그림-5-4-전단-변환에-따라-변하는-x값의-영역)에서 전단 변환을 적용하기 전의 공간 (a)에서 $y$값이 1인 영역(보라색으로 표시됨)을 살펴보면 $x$ 범위는 $|0, 1|$임을 볼 수 있다.    
여기서 $x$축으로 1만큼 민 전단 변환 (b)의 $x$범위는 $|0, 1|$에서 1만큼 늘어난 $|1, 2|$가 되고, 2만큼 민 전단 변환 (c)의 $x$범위는 $|0, 1|$에서 2만큼 늘어난 $|2, 3|$이 됨을 확인할 수 있다.     
이는 전단 변환을 사용해 공간을 오른쪽으로 밀었을 때 $y$값이 1인 영역의 $x$범위는 밀어낸만큼 이동한다는 의미다.

###### 그림 5-4 전단 변환에 따라 변하는 x값의 영역
![전단 변환에 따라 변하는 x값의 영역](/img/)

이러한 전단 변환의 성질을 활용한다면, 선형 변환의 체계에서 특정 조건하에 이동 기능의 구현이 가능하다.   
다음과 같이 벡터의 $y$값에 1을 고정한 상태에서 전단 변환을 적용시키면 다음과 같은 결과가 나온다.

$$
\begin{bmatrix}
1 & a \\
0 & 1 \\
\end{bmatrix} \cdot
\begin{bmatrix}
x \\
1 \\
\end{bmatrix} = 
\begin{bmatrix}
x + a \\
1 \\
\end{bmatrix}$$

위 수식으로 $y = 1$이라는 조건하에 $a$만큼 미는 전단 변환의 결과는 1차원의 이동 변환 $x + a$로 활용할 수 있다.  
이의 원리를 2차원 평면 공간에도 적용해보면, 2차원 공간의 무대를 한 차원 늘려 3차원 공간으로 확장한 후, 마지막 차원 $z$의 값을 1로 조건을 고정한 전단 변환을 설계할 수 있다.

$$
\begin{bmatrix}
1 & 0 & a \\
0 & 1 & b \\
0 & 0 & 1 \\
\end{bmatrix} \cdot
\begin{bmatrix}
x \\
y \\
1 \\
\end{bmatrix} =
\begin{bmatrix}
x + a \\
y + b \\
1 \\
\end{bmatrix}$$

이는 $z = 1$의 조건에서 임의의 벡터 $(x, y)$를 지정한 크기 $(a, b)$만큼 이동시키는 2차원의 이동 변환을 만들어낸다.      
이를 시각적으로 표현하면 [그림 5-5](#그림-5-5-3차원-전단-변환을-사용해-2차원-이동-변환을-구현하기)와 같다.

###### 그림 5-5 3차원 전단 변환을 사용해 2차원 이동 변환을 구현하기
![3차원 전단 변환을 사용해 2차원 이동 변환을 구현하기](/img/)

마지막 차원의 값이 1이라는 특정 조건을 가지는 전단 변환을 활용하면 게임 콘텐츠 제작에 필수적인 이동 기능을 행렬로 구현할 수 있다.   
이를 ***이동 변환행렬(Translate transformation matrix)*** 이라고 하며 다음과 같이 설계할 수 있다.

$$T = 
\begin{bmatrix}
1 & 0 & a \\
0 & 1 & b \\
0 & 0 & 1 \\
\end{bmatrix}$$

이동 변환행렬에서 주의할 점은 ***이동에 사용되는 벡터는 언제나 마지막 차원 값이 1이어야 한다***는 것이다.     
만일 2차원 상의 벡터 $(x, y)$를 이동 변환을 사용해 이동시키고자 하는 경우에는 값을 $(x, y, 1)$로 지정해야 한다.     
이와 같이 이동이 가능한 벡터는 모두 마지막 차원 값이 1이 된다는 공통점을 가지며, 이들을 모두 모으면 [그림 5-5](#그림-5-5-3차원-전단-변환을-사용해-2차원-이동-변환을-구현하기)에서의 보라색으로 채워진 영역을 형성하게 된다.     
이렇게 벡터 공간에서 이동을 위해 마지막 차원 값을 1로 한정한 부분 공간을 ***아핀 공간(Affine space)*** 이라고 부른다.

크기 변환행렬과 회전 변환행렬은 $2 \times 2$ 정방행렬이고, 여기서 다루는 이동 변환행렬은 $3 \times 3$ 정방행렬이다.     
행렬 곱의 장점을 살리려면 $S, R, T$ 세 행렬은 크기가 같아야 한다.   
따라서 이동 변환에 맞춰서 3차원으로 늘린 크기 변환행렬 $S$와 회전 변환행렬 $R$은 각각 다음과 같다.

$$S = 
\begin{bmatrix}
a & 0 & 0 \\
0 & b & 0 \\
0 & 0 & 1 \\
\end{bmatrix}$$

$$R = 
\begin{bmatrix}
\cos \theta & -\sin \theta & 0 \\
\sin \theta & \cos \theta & 0 \\
0 & 0 & 1 \\
\end{bmatrix}$$

이렇게 ***한 차원을 높여 설계한 선형 변환***을 ***아핀 변환(Affine transformation)*** 이라고 하며, 위에 나열한 크기 변환(S), 회전 변환(R), 이동 변환(T)은 가상 공간의 변환을 다루는 데 있어 핵심적으로 사용되는 대표적인 아핀 변환이다.     
임의의 벡터 $(x, y, 1)$을 아핀 변환행렬에 곱한 결과는 다음과 같으며, 이들의 결과 역시 마지막 차원 값이 1이 되어 해당 연산은 ***아핀 공간에 닫혀 있음***을 확인할 수 있다.

$$
\begin{bmatrix}
a & 0 & 0 \\
0 & b & 0 \\
0 & 0 & 1 \\
\end{bmatrix}
\begin{bmatrix}
x \\
y \\
1 \\
\end{bmatrix} =
\begin{bmatrix}
ax \\
by \\
1 \\
\end{bmatrix}$$

$$
\begin{bmatrix}
\cos \theta & -\sin \theta & 0 \\
\sin \theta & \cos \theta & 0 \\
0 & 0 & 1 \\
\end{bmatrix}
\begin{bmatrix}
x \\
y \\
1 \\
\end{bmatrix} = 
\begin{bmatrix}
\cos \theta x - \sin \theta y \\
\sin \theta x + \cos \theta y \\
1 \\
\end{bmatrix}$$

$$
\begin{bmatrix}
1 & 0 & a \\
0 & 1 & b \\
0 & 0 & 1 \\
\end{bmatrix}
\begin{bmatrix}
x \\
y \\
1 \\
\end{bmatrix} =
\begin{bmatrix}
x + a \\
y + b \\
1 \\
\end{bmatrix}$$

# 15. 아핀 공간의 구성 요소
행렬 곱의 장점을 활용하기 위해 가상 공간의 이동 기능은 ***아핀 변환***으로 구현해야 한다면, 아핀 공간의 정의에 따라 아핀 공간에 속한 물체의 ***마지막 차원값은 언제나 1***이 되어야 한다.

이러한 아핀 공간의 성질로부터 ***가상 공간을 구성하는 체계***가 만들어진다.

# 15.1. 점
마지막 차원 값이 1인 ***아핀 공간의 원소***를 ***점(Point)*** 이라고 부른다.     
점이 지니는 성질은 ***행렬 곱을 사용해 이동이 가능하다***는 것이다.   
가상 공간이 이동하려면 물체는 점으로 구성되어야 한다.

2차원 공간에서 점은 항상 $(x, y, 1)$의 형태여야 한다.   
이의 규칙을 벗어난 벡터 $(x, y, 2)$에 $(a, b)$만큼의 이동 변환을 적용한 결과는 예상과 달리 $(x + 2a, y + 2b, 2)$가 되어 사용할 수 없다.

$$
\begin{bmatrix}
1 & 0 & a \\
0 & 1 & b \\
0 & 0 & 1 \\
\end{bmatrix}
\begin{bmatrix}
x \\
y \\
2 \\
\end{bmatrix} =
\begin{bmatrix}
x + 2a \\
y + 2b \\
2 \\
\end{bmatrix}$$

이러한 점이 가지는 규칙은 3차원 공간에도 동일하게 적용된다.     
한 차원 더 늘린 4차원 공간을 만들고 마지막 차원의 값을 1로 지정하면 3차원 공간에서의 이동 변환을 구현할 수 있다.    
이동 가능한 2차원 아핀 공간과 3차원 아핀 공간의 구성 요소인 점은 다음의 형태를 띤다.

- 2차원 공간의 점: $(x, y, 1)$    
- 3차원 공간의 점: $(x, y, z, 1)$    

# 15.2. 이동 벡터
행렬 곱의 장점을 살리기 위해 의도적으로 벡터 공간의 부분 공간인 아핀 공간을 사용한다.    
벡터의 합 연산으로 아핀 공간의 원소인 점을 이동시켰을 때, 행렬 곱의 장점을 유지하기 위해서는 그 결과는 항상 ***아핀 공간에 닫혀 있어야 한다***.   
이를 위해서 아핀 공간은 ***벡터(Vector)*** 라는 개념을 추가로 제공한다.

벡터는 ***아핀 공간 내의 이동을 지정하기 위해 사용***되는데, 벡터 공간의 원소로 정의한 벡터와 ***같은 단어지만 다른 용도로 사용***된다.    
둘을 구분하기 위해 ***아핀 공간의 벡터***를 ***이동 벡터*** 또는 ***변위 벡터(Displacement vector)*** 라고 부른다.

이동 벡터는 [그림 5-6](#그림-5-6-아핀-공간의-이동-벡터-v)과 같이 아핀 공간의 점과 점 간의 최단 거리로 정의한다.

###### 그림 5-6 아핀 공간의 이동 벡터 v
![아핀 공간의 이동 벡터 v](/img/)

아핀 공간의 점 $P_1$에 이동 벡터 $\vec{v}$를 더한 결과는 아핀 공간의 다른 점 $P_2$에 대응되는데 이를 수식으로 나타내면 다음과 같다.

$$P_1 + \vec{v} = P_2$$

이 수식에서 점 $P_1$을 우변으로 이항하면 점과 점의 뺄셈을 통해 이동 벡터를 만들어낸다.

$$\vec{v} = P_2 - P_1$$

여기서 벡터 $\vec{v}$는 뺄셈식의 뒤에 위치한 점 $P_1$에서 앞에 위치한 $P_2$로 향하는 벡터를 의미한다.   
벡터의 뺄셈은 교환법칙이 성립하지 않기 때문에 두 점의 위치를 바꾸면 점 $P_2$에서 $P_1$으로 향하는 반대 방향의 이동 벡터를 만들어내니 주의해야 한다.

$$P_1 - P_2 = -\vec{v}$$

점 $P_1$의 좌표를 $(x_1, y_1, 1)$로 $P_2$의 좌표를 $(x_2, y_2, 1)$로 지정할 때 두 점을 빼서 만든 이동 벡터의 마지막 차원 값은 $x, y$값과 무관하게 항상 0이 됨을 알 수 있다.

$$(x_1 - x_2, y_1 - y_2, 0)$$

따라서 이러한 이동 벡터들이 모이면 마지막 차원 $z$의 값이 항상 0인 영역을 형성한다.     
점들의 집합인 아핀 공간과 이동 벡터의 영역을 구분해 표현하면 [그림 5-7](#그림-5-7-점의-영역과-이동-벡터의-영역)과 같다.

###### 그림 5-7 점의 영역과 이동 벡터의 영역
![점의 영역과 이동 벡터의 영역](/img/)

# 15.3. 아핀 공간의 성질
아핀 공간의 중심을 원점 $O$라 한다면 원점 $O$의 값은 $(0, 0, 1)$이 된다.    
아핀 공간에 속한 임의의 점 $P$의 값을 $(x, y, 1)$로 지정한다면 원점 $O$에서 점 $P$로 향하는 이동벡터 $\vec{v}$는 다음과 같이 구할 수 있다.

$$\vec{v} = P - O = (x, y, 1) - (0, 0, 1) = (x, y, 0)$$

이를 시각적으로 나타내면 [그림 5-8](#그림-5-8-점과-이동-벡터의-관계)과 같다.

###### 그림 5-8 점과 이동 벡터의 관계
![점과 이동 벡터의 관계](/img/)

***점과 벡터의 덧셈 연산은 아핀 공간에 대해 닫혀 있다***.     
따라서 마지막 차원을 배제하고 점의 이동을 2차원 평면으로 표현해보면 점과 이동 벡터를 구분하는 마지막 차원값을 생략해도 [그림 5-8](#그림-5-8-점과-이동-벡터의-관계)과 같이 2차원 평면에서 아핀 공간의 점을 점으로, 이동 벡터를 화살표로 표시하면 둘을 구분할 수 있다.    
눈에 보이는 물체는 점으로, 물체를 이동시키는 데 사용하는 보이지 않는 힘은 화살표로 표현된다.

[그림 5-9](#그림-5-9-아핀-공간에서-물체와-이를-이동시키는-힘의-표현)와 같이 서로 다른 위치에 있는 점들에 이동 벡터 $(a, b, 0)$를 더하면 마치 물체에 보이지 않는 힘을 가해 동일한 크기와 방향으로 이동시킨 결과를 만들어낼 수 있다.

###### 그림 5-9 아핀 공간에서 물체와 이를 이동시키는 힘의 표현
![아핀 공간에서 물체와 이를 이동시키는 힘의 표현](/img/)

물리적인 관점에서 바라본 현실 세계의 3차원 공간을 ***유클리드 공간(Euclidean space)*** 이라고 하고, 유클리드 공간에서 작용하는 힘을 ***유클리드 벡터(Euclidean vector)*** 라고 하는데, 이에 대응되는 개념이 각각 아핀 공간과 이동 벡터다.

게임 콘텐츠를 담는 가상 세계를 구성하는 두 요소는 다음과 같다.  
- 점: 물체를 표현하고 위치를 지정하는 데 사용한다. 마지막 차원의 값은 항상 1이다.
- 이동 벡터(이하 벡터): 물체를 움직이는 데 사용한다. 마지막 차원의 값은 항상 0이다.

점과 벡터의 마지막 차원 값을 토대로 두 요소 사이에는 다음과 같은 연산 규칙이 성립된다.  
이 때 ***점과 점을 더하는 수식은 성립하지 않는데, 점과 점을 더하면 마지막 차원 값이 2가 되어 아핀 공간 영역을 벗어나기 때문이다***.
- 점 - 점 = 벡터 (예: $1 - 1 = 0$)
- 점 + 벡터 = 점 (예: $1 + 0 = 1$)
- 벡터 + 벡터 = 벡터 (예: $0 + 0 = 0$)
- 점 + 점 $\neq$ 점 (예: $1 + 1 \neq 1$)

점과 벡터의 관계는 시각과 시간 개념의 관계로 주로 설명된다.     
다음과 같이 점을 시각에, 벡터를 시간에 대응해보면 둘의 차이점을 더 쉽게 이해할 수 있다.
- 3시 - 2시 = 1시간(점 - 점 = 벡터)
- 2시 + 2시간 = 4시(점 + 벡터 = 점)
- 1시간 + 2시간 = 3시간(벡터 + 벡터 = 벡터)
- 2시 + 3시 = ?(점 + 점 $\neq$ 점)

# 16. 아핀 결합
아핀 공간을 다룰 때 ***일반적으로 점과 점을 더한 결과는 사용할 수 없다***.    
그러나 점과 점을 더할 때 그대로 더하는 것이 아닌 ***선형 결합***의 형태로 점에 ***스칼라(계수)*** 를 곱해 더한다면, 특정 조건에서 새로운 점을 생성하는 것이 가능해진다.

2차원 평면상 임의의 두 점 $P_1(x_1, y_1, 1)$과 $P_2(x_2, y_2, 1)$에 각각 스칼라 $a, b$를 곱한 선형 결합의 식은 다음과 같다.

###### 식 5-1

$$a \cdot P_1 + b \cdot P_2 = (ax_1 + bx_2, ay_1 + by_2, a + b)$$

[식 5-1](#식-5-1)에서 두 점의 결합 결과가 언제나 점이 되려면 마지막 차원 값 $a + b$가 1이 되어야 한다.  
$x$와 $y$ 값과 무관하게 $a + b = 1$의 조건을 유지한다면 점과 점을 결합해 새로운 점을 만들 수 있다.      
동일한 원리로 세 점에 대해서도 다음 수식과 같이 모든 스칼라 $a, b, c$의 합이 1이면 점의 생성이 가능하다(다음 수식의 $s.t.$는 ***such that***의 약자이며 ***수식이 성립하기 위한 조건***을 의미한다).

$$a \cdot P_1 + b \cdot P_2 + c \cdot P_3 = P_4 (s.t. a + b + c = 1)$$

이렇게 여러 개의 점을 결합해 새로운 점을 생성하는 수식을 ***아핀 결합(Affine combination)*** 이라고 한다.  
$n$개의 점을 아핀 결합하는 경우에는 각 점을 $P_i$로, 점에 사용하는 스칼라를 $c_i$로 지정한 후 모든 항을 더하는 ***시그마***($\Sigma$) 기호를 사용해 [식 5-2](#식-5-2)와 같이 간략히 표현할 수 있다.

###### 식 5-2

$$\sum_{i = 1}^n c_i \cdot P_i (s.t. \sum_{i = 1}^n c_i = 1)$$

# 16.1. 두 점의 결합
아핀 결합을 통해 생성한 점들 사이에는 특정한 관계가 형성된다.   
두 점의 아핀 결합이 성립하려면 점에 곱한 두 스칼라의 합이 $a + b = 1$을 만족해야 했는데, 이를 바탕으로 [식 5-1](#식-5-1)의 $b$를 $1 - a$로 치환하면 계수 $a$에 대한 식을 얻게 되며 이는 언제나 점의 생성을 보장한다.   
두 점을 $P_1, P_2$로 지정하고 아핀 결합으로 생성된 점을 $P'$으로 지정하면 다음의 수식이 성립된다.

###### 식 5-3

$$a \cdot P_1 + (1 - a) \cdot P_2 = P'$$

스칼라 $a$ 값의 변환에 따라 점들이 어떻게 생성되는지 관찰해보자.    
먼저 $a$에 1을 대입하면 점 $P_1$이 생성된다.

$$1 \cdot P_1 + 0 \cdot (x_2, y_2, 1) = P_1$$

$a$에 0을 대입하면 점 $P_2$가 생성된다.

$$0 \cdot (x_1, y_1, 1) + P_2 = P_2$$

$a = 0.5$를 대입하면 점 $P_1$과 점 $P_2$의 중점이 만들어진다.

$$\frac{1}{2} \cdot (x_1, y_1, 1) + \frac{1}{2} \cdot (x_2, y_2, 1) = \left(\frac{x_1 + x_2}{2}, \frac{y_1 + y_2}{2}, 1\right)$$

두 점 $P_1$과 $P_2$의 아핀 결합을 통해 새로운 점을 생성하면, $a$ 값이 양의 방향으로 커질수록 $P_1$의 바깥쪽 방향에 점이 생성되고, $a$ 값이 음의 방향으로 커질수록 $P_2$의 바깥쪽 방향에 점이 생성된다.      
이러한 규칙을 시각화해보면 [그림 5-10](#그림-5-10-두-점의-결합에-따른-새로운-점의-생성)과 같이 아핀 결합으로 생성되는 점을 모두 모으면 두 점 $P_1$과 $P_2$를 지나는 무한한 긴 선이 만들어진다.

###### 그림 5-10 두 점의 결합에 따른 새로운 점의 생성
![두 점의 결합에 따른 새로운 점의 생성](/img/)

아핀 결합으로 생성된 점들이 실제로 $P_1$과 $P_2$를 지나는 무한선상에 위치하는지 수식으로 확인해보자.    
[식 5-3](#식-5-3)을 $a$로 수식을 묶은 후 다시 정리하면 다음과 같은 식이 성립한다.

$$a(P_1 - P_2) = (P' - P_2)$$

앞서 살펴본 바와 같이 점에서 점을 빼면 벡터가 되므로, 좌변의 $(P_1 - P_2)$는 $P_2$에서 $P_1$으로 향하는 벡터가 되고 우변의 $(P' - P_2)$는 $P_2$에서 새롭게 생성된 점 $P'$로 향하는 벡터가 된다.     
이 두 벡터를 각각 $\vec{u}$와 $\vec{v}$로 표시하면 위 식은 다음과 같이 간단히 정리된다.

$$a \cdot \vec{u} = \vec{v}$$

스칼라 곱셈의 성질을 떠올려보면 두 벡터 $\vec{u}$와 $\vec{v}$는 서로 평행한 벡터임을 알 수 있다.    
그렇기 때문에 두 점의 아핀 결합으로 생성되는 점은 [그림 5-11](#그림-5-11-벡터를-사용해-결합된-점이-동일-선상에-위치함을-증명한-모습)과 같이 점 $P_2$에서 $P_1$을 지나는 직선 상에 위치함을 보장받게 된다.

###### 그림 5-11 벡터를 사용해 결합된 점이 동일 선상에 위치함을 증명한 모습
![벡터를 사용해 결합된 점이 동일 선상에 위치함을 증명한 모습](/img/)

[식 5-3](#식-5-3)에 모든 실수 $a$를 대입하면 두 점을 이은 양 끝으로 무한히 뻗은 선을 얻게 될 것이다.    
이 수식을 ***직선의 방정식***이라고 한다.

###### 식 5-4

$$L(a) = a \cdot P_1 + (1 - a) \cdot P_2$$

직선의 방정식은 $a$의 범위에 따라 다양한 종류의 선이 대응된다.  
(a)를 ***직선(Line)***, (b)를 ***반직선(Ray)***, (c)를 ***선분(Line segment)*** 이라고 부른다.

###### 그림 5-12 매개변수 범위에 따른 직선의 종류
![매개변수 범위에 따른 직선의 종류](/img/)

***직선(Line)*** 은 두 점의 양쪽 방향으로 무한히 뻗어나가는 선의 형태를 의미하며 ***추상적인 선의 성질을 표현할 때 사용***한다.

***반직선(Ray)*** 은 지정한 위치에서 한쪽 방향으로만 뻗어나가는 선을 뜻한다.   
반직선도 ***추상적인 개념이지만 게임 제작에서 여러 용도로 사용***된다.    
게임 제작에서 전방에 물체가 있는지 탐지하기 위해 사용하는 기능에 ***레이캐스팅(Raycasting)*** 이 있다.     
지정한 위치에서 특정 방향으로 ***반직선(Ray)*** 을 ***던져(Casting)*** 이와 맞닿는 물체를 탐지하는 기능이다.     
컴퓨터 그래픽스에서 각광받는 ***레이트레이싱(Raytracing)*** 기술에도 ***반직선(Ray)*** 개념이 사용된다.     
레이트레이싱은 ***화면에 도달한 빛의 경로를 거꾸로 추적해(Tracing) 현실 세계와 유사하게 빛의 경로를 시뮬레이션***하여 [그림 5-13](#그림-5-13-반직선-레이트레이싱-기술로-제작한-컴퓨터-그래픽-화면)과 같은 사실적인 이미지를 만들어내는 기법이다.

###### 그림 5-13 반직선 레이트레이싱 기술로 제작한 컴퓨터 그래픽 화면
![반직선 레이트레이싱 기술로 제작한 컴퓨터 그래픽 화면](/img/)

마지막으로 ***선분(Line segment)*** 은 시작점과 끝점의 위치가 정해져 있는 선을 말한다.     
프로그래밍을 활용해 화면에 선을 그리려면 무한이라는 추상적인 개념을 배제하고 명확하게 시작점과 끝점을 정해주어 선분의 형태로 정보가 제공되어야 한다.

# 17. 벡터의 내적
벡터의 ***내적(Dot product)*** 은 같은 차원의 두 벡터가 주어졌을 때, ***벡터를 구성하는 각 성분을 곱한 후 이들을 더해 스칼라를 만들어내는 연산***이다.   
내적은 곱셈 기호와 동일한 ***가웃뎀점(·)*** 을 사용한다.   
2차원 벡터의 내적을 계산하는 수식은 다음과 같다.

$$\vec{u} = (a, b)$$

$$\vec{v} = (c, d)$$

$$\vec{u} \cdot \vec{v} = a \cdot c + b \cdot d$$

# 17.1. 내적의 성질
***내적은 스칼라의 곱셈과 덧셈으로 구성되어 있으므로 교환법칙이 성립한다***.

$$\vec{u} \cdot \vec{v} = a \cdot c + b \cdot d$$

$$\vec{v} \cdot \vec{u} = c \cdot a + d \cdot b$$

$$\therefore \vec{u} \cdot \vec{v} = \vec{v} \cdot \vec{u}$$

하지만 ***결과가 벡터가 아닌 스칼라로 나오는 성질***로 인해 ***결합법칙은 성립하지 않는다***.

$$\vec{u} \cdot (\vec{v} \cdot \vec{w}) \neq (\vec{u} \cdot \vec{v}) \cdot \vec{w}$$

***내적은 덧셈에 대한 분배법칙이 성립된다***.

$$\vec{w} \cdot (\vec{u} + \vec{v}) = (e, f) \cdot (a + c, b + d) = ae + ce + bf + df$$

$$\vec{u} \cdot \vec{w} + \vec{v} \cdot \vec{w} = (a, b) \cdot (e, f) + (c, d) \cdot (e, f) = ae + bf + ce + df$$

$$\therefore \vec{w} \cdot (\vec{u} + \vec{v}) = \vec{u} \cdot \vec{w} + \vec{v} \cdot \vec{w}$$

같은 벡터를 내적하면 ***벡터의 크기를 제곱한 결과***가 나온다.    
이와 같은 내적의 성질은 모든 차원의 벡터에 동일하게 적용된다.

$$(x, y) \cdot (x, y) = x^2 + y^2$$

$$\therefore \vec{v} \cdot \vec{v} = |\vec{v}|^2$$

> 참고: ***벡터 크기의 정의***      
벡터의 크기를 정의할 때 피타고라스 정리를 활용한 최단 거리의 개념으로 설명했는데, 직각삼각형과 같은 기하학적인 요소를 완전히 배제한다면 벡터의 크기는 자신을 내적한 결과의 제곱근으로 정의할 수 있다.

내적은 교환법칙과 분배법칙이 성립하기 때문에, 두 벡터 합의 내적 $(\vec{u} + \vec{v}) \cdot (\vec{u} + \vec{v})$은 두 벡터의 크기로 표현할 수 있다.

$$
\begin{matrix}
(\vec{u} + \vec{v}) \cdot (\vec{u} + \vec{v}) &=& \vec{u} \cdot \vec{u} + \vec{v} \cdot \vec{v} + 2(\vec{u} \cdot \vec{v}) \\
&=& |\vec{u}|^2 + |\vec{v}|^2 + 2(\vec{u} \cdot \vec{v}) \\
\end{matrix}
$$

벡터의 내적은 벡터를 응용하는 데 있어 빈번히 사용되는 중요한 공식이다.      
특히 ***곱셈과 덧셈으로만 구성된 내적은 컴퓨터에서 빠르게 처리***되기 때문에, 컴퓨터 그래픽에서 실시간으로 변화하는 효과를 구현하는 데 유용하게 사용된다.    

# 17.2. 내적과 삼각함수의 관계
벡터의 내적은 [그림 6-1](#그림-6-1-두-벡터의-사잇각-세타)과 같이 ***두 벡터의 사잇각에 대한*** $\cos$ ***함수와 비례하는 특징***을 가진다.

###### 그림 6-1 두 벡터의 사잇각 세타
![두 벡터의 사잇각 세타](/img/)

두 벡터 $\vec{u}, \vec{v}$의 사잇각을 $\theta$라고 할 때 내적과 $\cos$ 함수의 관계는 다음과 같다.

###### 식 6-1

$$\vec{u} \cdot \vec{v} = |\vec{u}||\vec{v}| \cos \theta$$

[그림 6-2](#그림-6-2-삼각형의-설정)와 같이 데카르트 좌표계에 세 점 $A, B, C$로 구성된 삼각형을 그리고, 각 점을 마주보는 벡터를 $\vec{a}, \vec{b}, \vec{c}$로, 원점에 위치한 사잇각은 $\theta$로 지정하자.

###### 그림 6-2 삼각형의 설정
![삼각형의 설정](/img/)

삼각형을 구성하는 점과 벡터의 값을 [표 6-1](#표-6-1-삼각형을-구성하는-점과-변을-구성하는-벡터의-좌표)에 정리했다(편의상 점과 벡터를 구분하는 마지막 차원 값 0과 1은 생략한다).

###### 표 6-1 삼각형을 구성하는 점과 변을 구성하는 벡터의 좌표
|삼각형 점의 좌표|삼각형 변을 구성하는 벡터|
|---|---|
|$B = (0, 0)$|$\vec{a} = C - B = (\|\vec{a}\|, 0)$|
|$C = (\vec{a}, 0)$|$\vec{c} = A - B = (\|\vec{c}\| \cos \beta, \|\vec{c}\| \sin \beta)$|
|$A = (\|\vec{c}\| \cos \beta, \|\vec{c}\| \sin \beta)$|$\vec{b} = C - A = (\|\vec{a}\| - \|\vec{c}\| \cos \beta, 0 - \|\vec{c}\| \sin \beta)$|

여기서 벡터 $\vec{b}$는 [그림 6-3](#그림-6-3-벡터의-뺄셈으로-표현한-벡터-b)과 같이 벡터 $\vec{a}$에서 벡터 $\vec{c}$를 뺀 결과와 동일하다.

$$\vec{b} = C - A = \vec{a} + (-\vec{c})$$

###### 그림 6-3 벡터의 뺄셈으로 표현한 벡터 b
![벡터의 뺄셈으로 표현한 벡터 b](/img/)

이때 벡터 $\vec{b}$의 크기를 제곱한 수식은 다음과 같이 전개된다.

$$
\begin{matrix}
|\vec{b}|^2 &=& (|\vec{a}| - |\vec{c}| \cos \theta)^2 + |\vec{c}|^2 \sin^2 \theta \\
&=& |\vec{a}|^2 - 2|\vec{a}||\vec{c}| \cos \theta + |\vec{c}|^2 \cos^2 \theta + |\vec{c}|^2 \sin^2 \theta \\
&=& |\vec{a}|^2 + |\vec{c}|^2 - 2|\vec{a}||\vec{c}| \cos \theta \\
\end{matrix}$$

***같은 벡터를 내적하면 벡터 크기의 제곱***이 되므로 이를 활용해 내적을 전개할 수 있다.

$$
\begin{matrix}
|\vec{b}|^2 &=& \vec{b} \cdot \vec{b} \\
&=& (\vec{a} - \vec{c}) \cdot (\vec{a} - \vec{c}) \\
&=& (\vec{a} + (-\vec{c})) \cdot (\vec{a} + (-\vec{c})) \\
&=& |\vec{a}|^2 + |\vec{c}|^2 - 2\vec{a} \cdot \vec{c} \\
\end{matrix}$$

위의 두 식은 동일한 값이므로 다음 식이 성립함을 알 수 있다.

$$\vec{a} \cdot \vec{c} = |\vec{a}||\vec{c}| \cos \theta$$

[식 6-1](#식-6-1)에서 두 벡터의 크기가 1이면, 두 벡터의 내적은 $\cos$ 함수가 된다.

###### 식 6-2

$$\vec{u} \cdot \vec{v} = \cos \theta$$

이러한 내적의 성질은 ***덧셈과 곱셈만 사용***해 $\cos$ 함수 값을 빠르게 계산할 수 있어 유용하게 활용된다.     
또한 [식 6-1](#식-6-1)에서 영벡터가 아닌 경우, 내적 값이 0이 되기 위한 조건은 $\cos$ 함수 값이 0이 되는 경우 뿐인데, 이는 두 벡터의 사잇각이 $90^\circ$ 혹은 $270(-90^\circ)$인 경우다.     
이는 [그림 6-4](#그림-6-4-두-벡터의-내적이-0이-나오는-경우)와 같이 ***두 벡터가 서로 직교하는 경우***다.

###### 그림 6-4 두 벡터의 내적이 0이 나오는 경우
![두 벡터의 내적이 0이 나오는 경우](/img/)

따라서 ***두 벡터의 내적이 0이면 두 벡터는 직교한다***고 결론내릴 수 있으며 이는 두 벡터의 ***직교성을 판별하는 데 활용***될 수 있다.

직교성을 판별할 수 있는 내적의 성질은 많은 곳에서 응용된다.     
벡터 공간에서 직교하는 두 표준기저벡터 $(1, 0)$과 $(0, 1)$을 내적한 결과는 0이 나온다.  
두 표준기저벡터를 각 $\theta$만큼 회전한 두 기저벡터도 서로 직교하는데, [그림 6-5](#그림-6-5-회전행렬을-구성하는-항상-직교하는-두-기저벡터)와 같이 두 기저벡터 $(\cos \theta, \sin \theta)$와 $(-\sin \theta, \cos \theta)$는 항상 직교하기 때문에 두 벡터의 내적은 언제나 0이 나온다.

###### 그림 6-5 회전행렬을 구성하는 항상 직교하는 두 기저벡터
![회전행렬을 구성하는 항상 직교하는 두 기저벡터](/img/)

# 17.3. 행렬의 곱셈을 내적으로 표현하기
***행렬의 곱셈 연산은 내적으로 표현이 가능하다***.    

$$
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix}
\begin{bmatrix}
x \\
y \\
\end{bmatrix} = 
\begin{bmatrix}
ax + by \\
cx + dy \\
\end{bmatrix}
$$

행렬과 벡터의 곱셈은 행렬을 구성하는 두 개의 행벡터 $(a, b), (c, d)$와 벡터를 구성하는 열벡터 $(x, y)$의 내적으로 표현할 수 있다.

$$
\begin{bmatrix}
ax + by \\
cx + dy \\
\end{bmatrix} =
\begin{bmatrix}
(a, b) \cdot (x, y) \\
(c, d) \cdot (x, y) \\
\end{bmatrix}
$$

행렬의 곱셈 또한 벡터의 내적으로 바꿔 표현할 수 있다.   
행렬의 곱을 내적으로 표현하면 다음과 같다.

$$
\begin{bmatrix}
a & b \\
c & d \\
\end{bmatrix}
\begin{bmatrix}
e & f \\
g & h \\
\end{bmatrix} =
\begin{bmatrix}
ae + bg & af + bh \\
ce + dg & cf + dh \\
\end{bmatrix} =
\begin{bmatrix}
(a, b) \cdot (e, g) & (a, b) \cdot (f, h) \\
(c, d) \cdot (e, g) & (c, d) \cdot (f, h) \\
\end{bmatrix}
$$

***직교 행렬(Orthogonal matrix)*** 은 ***정방행렬을 구성하는 모든 행벡터와 열벡터의 크기가 1이고 벡터들이 서로 직교하는 행렬***이다.     
$a, b, c, d$로 구성된 직교행렬을 $Q$로 지정하면 열벡터와 행벡터를 구성하는 $(a, b), (b, d), (a, c), (c, d)$의 크기는 1이고 $(a, b)$와 $(c, d)$는 서로 직교한다.

$$Q = 
\begin{bmatrix}
a & c \\
b & d \\
\end{bmatrix}$$

직교행렬이 지니는 특징은 ***직교행렬의 전치행렬은 역행렬이 된다***는 점이다.  
그렇다면 직교행렬 $Q$와 이의 전치행렬 $Q^T$의 곱은 항등행렬이 된다.

$$Q \cdot Q^T = I$$

이는 내적을 사용해 증명할 수 있다.  
임의의 직교행렬과 이의 전치행렬의 곱을 내적을 사용해 표현해보자.

$$
\begin{bmatrix}
a & c \\
b & d \\
\end{bmatrix}^T
\begin{bmatrix}
a & c \\
b & d \\
\end{bmatrix} =
\begin{bmatrix}
(a, b) \cdot (a, b) & (a, b) \cdot (c, d) \\
(c, d) \cdot (a, b) & (c, d) \cdot (c, d) \\
\end{bmatrix}
$$

직교행렬의 정의에 의해 벡터 $(a, b)$와 $(c, d)$는 서로 직교하므로 두 벡터의 내적은 0이 나온다.  
직교행렬의 정의에 의해 행벡터와 열벡터의 크기는 각각 1이므로, 자신을 내적한 결과는 1이 된다.    
따라서 직교행렬과 그 전치행렬의 곱은 언제나 항등행렬을 보장한다.

$$
\begin{bmatrix}
(a, b) \cdot (a, b) & (a, b) \cdot (c, d) \\
(c, d) \cdot (a, b) & (c, d) \cdot (c, d) \\
\end{bmatrix} = 
\begin{bmatrix}
1 & 0 \\
0 & 1 \\
\end{bmatrix} = 
I
$$

***회전 변환행렬은 각 행벡터와 열벡터의 크기가 1이고 서로 직교하므로 직교행렬이다***.     
회전행렬의 역행렬은 전치연산으로 쉽게 구할 수 있다.

$$
\begin{matrix}
R_\theta &=& 
\begin{bmatrix}
\cos \theta & -\sin \theta \\
\sin \theta & \cos \theta \\
\end{bmatrix} \\
R^T_\theta \cdot R_\theta &=&
\begin{bmatrix}
\cos^2 \theta + \sin^2 \theta & 0 \\
0 & \cos^2 \theta + \sin^2 \theta \\
\end{bmatrix} = 
\begin{bmatrix}
1 & 0 \\
0 & 1 \\
\end{bmatrix} =
1
\end{matrix}
$$

여러 종류의 선형 변환 중 물체의 형태가 그대로 유지되는 선형 변환을 ***강체 변환(Rigid Transformation)*** 이라고 하는데, 선형 변환이 강체 변환이 되기 위한 조건은 다음과 같다.

1. 변화된 기저벡터의 크기는 모두 1이어야한다.
2. 모든 기저벡터는 서로 직교해야 한다.
3. 행렬식의 값이 1이어야 한다.

회전 변환은 강체 변환의 성질을 가지고 있음을 수식으로 확인해보자.   
앞에서 회전행렬은 직교행렬의 성질을 가지고 있음을 확인했으므로 1번과 2번은 만족한다.    
3번을 확인하기 위해 회전 행렬의 행렬식 값을 확인해보자.     
회전행렬의 행렬식 $ad - bc$의 값은 언제나 1이 됨을 알 수 있다.  
따라서 ***회전 변환은 물체의 형태를 그대로 유지시켜주는 강체 변환***이다.

$$\det(R) = \cos^2 \theta + \sin^2 \theta = 1$$

# 18. 시야 판별
# 18.1. 앞뒤 판별
게임 제작 과정에서 공간을 파악하는 데 가장 유용하게 활용되는 사례는 목표물이 캐릭터의 앞에 있는지, 뒤에 있는지를 구분하는 것이다.   
이는 내적의 부호를 통해 쉽게 파악할 수 있다.

내적과 삼각함수와의 관계를 나타내는 [식 6-1](#식-6-1)을 살펴보자.   
벡터의 크기 값은 언제나 양수이므로 벡터 내적의 부호는 $\cos$ 함수가 결정한다.    
$\cos$ 함수는 [그림 6-6](#그림-6-6--180-180-범위에서의-cos-함수-그래프)에서 $(-90^\circ, 90^\circ)$ 영역에 대해 양의 부호를 가지고 $-90^\circ$와 $90^\circ$에서는 0, 나머지 범위에서는 음의 부호를 가진다.

###### 그림 6-6 [-180, 180] 범위에서의 cos 함수 그래프
![-180, 180 범위에서의 cos 함수 그래프](/img/)

벡터 내적의 부호는 [그림 6-7](#그림-6-7-벡터-내적의-부호-영역)과 같이 두 벡터가 이루는 사잇각의 범위에 따라 결정된다.    
첫 번째 벡터를 캐릭터의 시선 방향으로 생각한다면 두 번째 벡터는 시선 벡터에서부터 멀어질수록 사잇각이 커질 것이다.      
하지만 $\cos$ 함수는 $(-90^\circ, 90^\circ)$ 영역에 대해 양의 부호를 가지므로 두 번째 벡터가 보라색으로 칠해진 영역에 존재한다면 내적 값은 언제나 양의 부호를 가진다.

###### 그림 6-7 벡터 내적의 부호 영역
![벡터 내적의 부호 영역](/img/)

이를 응용하면 내적의 부호만 가지고도 두 벡터가 같은 방향을 향하는지, 아니면 서로 마주보는지를 확인할 수 있다.

- 벡터 내적의 결과가 양수: 두 벡터는 같은 방향을 향하고 있다.
- 벡터 내적의 결과가 음수: 두 벡터는 다른 방향을 향하고 있다.   
벡터는 위치의 개념이 없으므로 두 벡터는 서로 마주보고 있다로도 해석할 수 있다.
- 벡터 내적의 결과가 0: 두 벡터는 서로 직교한다.

이 성질을 응용하면 앞뒤 판별 기능을 구현할 수 있다.     
[그림 6-8](#그림-6-8-캐릭터-시선-벡터와-목표-벡터의-설정)과 같이 게임 공간에 캐릭터와 목표물이 배치된 상황을 가정한다.   
캐릭터가 바라보는 방향을 시선 벡터 $\vec{f}$로 표시한 후에 목표물의 위치에서 캐릭터의 위치를 빼서 캐릭터에서 목표물로 향하는 벡터 $\vec{v}$를 만든다.    
시선 벡터 $\vec{f}$와 목표물로 향하는 벡터 $\vec{v}$의 사잇각을 $\alpha$로 설정한다.

###### 그림 6-8 캐릭터 시선 벡터와 목표 벡터의 설정
![캐릭터 시선 벡터와 목표 벡터의 설정](/img/)

그렇다면 두 벡터의 내적 $\vec{f} \cdot \vec{v}$의 부호에 따라 캐릭터와 목표물의 사이의 공간 구성을 파악할 수 있다.

- $\vec{f} \cdot \vec{v}$ 결과의 부호가 양수: 캐릭터 앞에 목표물이 있다.
- $\vec{f} \cdot \vec{v}$ 결과의 부호가 음수: 캐릭터 뒤에 목표물이 있다.
- $\vec{f} \cdot \vec{v}$ 결과가 0: 캐릭터 바로 옆에 목표물이 있다.

# 18.2. 시야 판별
[그림 6-9](#그림-6-9-캐릭터-시야각의-설정)와 같이 캐릭터에 시야각이라는 특성을 부여해보자.  
캐릭터에 부여한 시야각이 $\beta$라면 양쪽으로 균등하게 $\frac{\beta}{2}$의 시야각이 설정된다.   
나머지는 앞뒤 판별 문제와 동일하게 캐릭터의 시선 방향을 벡터 $\vec{f}$로 표시하고, 캐릭터에서 목표물로 향하는 벡터 $\vec{v}$를 만든 후 벡터 $\vec{f}$와 벡터 $\vec{v}$의 사잇각을 $\alpha$로 설정한다.

###### 그림 6-9 캐릭터 시야각의 설정
![캐릭터 시야각의 설정](/img/)

내적으로 캐릭터의 시야에 목표물이 탐지되는지 여부를 파악해보자.     
이는 사잇각 $\alpha$가 시야각의 절반인 $\frac{\beta}{2}$보다 작거나 같은지 비교하는 문제가 된다.    
내적에 비례하는 $\cos$ 함수는 [그림 6-10](#그림-6-10-각-0-180-범위에서의-코사인-그래프의-특징)에서 볼 수 있듯이 $[0^\circ, 180^\circ]$ 범위에서는 각이 커질수록 값이 작아지는 성질을 지닌다.     
따라서 해당 범위에서 각이 작을수록 $\cos$ 함수의 값은 반대로 커진다.

###### 그림 6-10 각 [0, 180] 범위에서의 코사인 그래프의 특징
![각 0, 180 범위에서의 코사인 그래프의 특징](/img/)

이를 활용해 다음의 과정으로 캐릭터의 시야에 목표물이 탐지됐는지 판별할 수 있다.

1. 시야각을 절반 나눈 각의 $\cos \frac{\beta}{2}$를 미리 계산해둔다.
2. 캐릭터의 시선 벡터를 구하고 이의 크기를 1로 정규화시킨다.    
이를 단위 벡터 $\hat{f}$라고 한다.
3. 캐릭터에서 목표물로 향하는 벡터도 정규화시킨다.  
이를 단위 벡터 $\hat{v}$라고 한다.
4. 내적 $\hat{f} \cdot \hat{v}$의 계산 결과는 $\cos \alpha$가 된다.  
이를 앞서 계산해 둔 $\cos \frac{\beta}{2}$값과 비교한다.

$\hat{f} \cdot \hat{v}$ 값이 $\cos \frac{\beta}{2}$보다 크다면 사잇각이 시야각보다 작다는 것을 의미하므로 물체가 시야 영역에 들어왔음을 의미한다.   
따라서 사잇각을 몰라도 내적 $\hat{f} \cdot \hat{v}$의 결과에 따라 캐릭터 시야 범위에 목표물이 있는지 파악할 수 있다.

- $\hat{f} \cdot \hat{v} \geq \cos \frac{\beta}{2}$: 목표물이 시야 범위 안에 있음
- $\hat{f} \cdot \hat{v} < \cos \frac{\beta}{2}$: 목표물이 시야 범위 밖에 있음

$atan2$ 함수를 활용해 두 벡터가 이루는 각 $\alpha$를 구한 후 이를 $\frac{\beta}{2}$와 비교해도 동일한 결과를 얻을 수 있다.  
하지만 단위 벡터를 구한 후 내적을 계산하는 방식이 $atan2$를 호출하는 것보다 더 효율적이다.

# 19. 조명 효과의 구현
현실 세계와 비슷한 조명 효과를 만들기 위해 고안된 방법으로 ***램버트 반사(Lambertian reflection)*** 모델이 있다.  
이 모델을 고안한 스위스의 수학자 ***요한 하인리히 램버트(Johann Heinrich Lambert)*** 의 이름을 따서 지어진 램버트 반사 모델은 ***컴퓨터 그래픽스에서 표면에서의 조명 모델 계산***을 위해 쓰인다.     
[그림 6-11](#그림-6-11-램버트-반사-모델로-3차원-물체의-조명-효과를-구현한-예시)은 램버트 반사 모델을 사용해 3차원 물체의 조명 효과를 구현한 화면이다.   
램버트 반사 모델은 계산량이 적어 속도가 빠르지만 그럴듯한 조명 효과를 줄 수 있어 ***실시간 조명 구현***이 필요한 게임 제작에 널리 사용된다.

###### 그림 6-11 램버트 반사 모델로 3차원 물체의 조명 효과를 구현한 예시
![램버트 반사 모델로 3차원 물체의 조명 효과를 구현한 예시](/img/)

[그림 6-12](#그림-6-12-조명-모델-계산을-위한-설정)와 같이 광원이 물체를 향해 직사광선을 발사하는 상황을 가정해보자.    
빛을 받아 표면에서 반사되는 ***빛의 세기는 두 벡터가 만드는 사잇각의*** $\cos$ ***함수에 비례한다***는 것이 램버트 반사 모델의 주요 내용이다.   
표면이 향하는 단위 벡터를 $\hat{N}$으로 지정하고 표면에서 광원으로 향하는 단위 벡터를 $\hat{L}$로 지정한다.

###### 그림 6-12 조명 모델 계산을 위한 설정
![조명 모델 계산을 위한 설정](/img/)

***두 벡터의 내적***을 사용하면 램버트 반사 모델에 필요한 사잇각의 $\cos$ 값을 얻을 수 있다.

$$\hat{N} \cdot \hat{L} = \cos \theta$$

# 20. 투영 벡터
***벡터 내적은 어떤 벡터를 다른 벡터에 직교 투영하는 용도로 사용된다***.  
예를 들어 [그림 6-13](#그림-6-13-카메라-공간의-분석-예시)과 같이 카메라가 만드는 공간을 분석할 때 ***카메라와 물체 사이의 거리*** 외에도 ***카메라에서 물체까지의 깊이*** 값이 필요한 경우도 있다.  
이 경우 내적을 활용한 투영 벡터를 구하는 공식이 활용된다.

###### 그림 6-13 카메라 공간의 분석 예시
![카메라 공간의 분석 예시](/img/)

[그림 6-14](#그림-6-14-벡터-투영-과정의-시각화)와 같이 임의의 두 벡터 $\vec{u}$와 $\vec{v}$가 주어졌을 때 벡터 $\vec{u}$를 벡터 $\vec{v}$에 투영하는 상황을 생각해보자.     
투영한 벡터를 $\vec{v'}$로 표기했는데, 투영한 벡터는 대상 벡터 $\vec{v}$와 방향이 같기 때문이다.

###### 그림 6-14 벡터 투영 과정의 시각화
![벡터 투영 과정의 시각화](/img/)

따라서 투영한 벡터 $\vec{v'}$의 크기를 알고 있다면 [그림 6-15](#그림-6-15-투영-벡터식-유도에-사용되는-단위-벡터)에서 보듯이 $\vec{v}$를 정규화시킨 단위 벡터 $\hat{v}$를 구하고 그 크기를 곱하면 투영된 벡터를 얻을 수 있다.

###### 그림 6-15 투영 벡터식 유도에 사용되는 단위 벡터
![투영 벡터식 유도에 사용되는 단위 벡터](/img/)

이를 수식으로 표현하면 다음과 같다.

$$\vec{v'} = |\vec{v'}| \cdot \hat{v}$$

내적을 활용해 $\vec{u}$로부터 $\vec{v'}$를 구하도록 수식을 전개한다.

$$
\begin{matrix}
\vec{v'} &=& |\vec{v'}| \cdot \hat{v} \\
&=& |\vec{v'}| \cdot \frac{\vec{v}}{|\vec{v}|} \\
&=& |\vec{u}| \cdot \cos \theta \cdot \frac{\vec{v}}{|\vec{v}|} \\
&=& |\vec{u}| \cdot \frac{\vec{u} \cdot \vec{v}}{|\vec{u}||\vec{v}|} \cdot \frac{\vec{v}}{|\vec{v}|} \\
&=& \frac{(\vec{u} \cdot \vec{v})}{|\vec{v}|^2} \cdot \vec{v} \\
&=& \frac{(\vec{u} \cdot \vec{v})}{(\vec{v} \cdot \vec{v})} \cdot \vec{v} \\
\end{matrix}
$$

1. 단위 벡터 $\hat{v}$를 구하기 위해 벡터 $\vec{v}$를 정규화한다.
2. $\vec{v'}$의 크기는 벡터 $\vec{u}$의 크기에 $\cos \theta$를 곱해 얻을 수 있다.
3. $\cos \theta$는 내적 공식 $\vec{u} \cdot \vec{v} = |\vec{u}||\vec{v}| \cos \theta$로부터 얻을 수 있다.
4. 분자와 분모를 소거하고 정리한다.
5. 벡터의 크기의 제곱을 내적으로 변경한다.

위 식에서 투영할 벡터 $\vec{v}$의 크기가 1이면 위 식은 다음과 같이 단순하게 정리된다.

$$\vec{v'} = (\vec{u} \cdot \vec{v}) \cdot \vec{v}$$

# 21. 세 점의 결합
아핀 결합식에 사용하는 스칼라(계수) 값의 범위에 따라 직선, 반직선, 선분 등 다양한 종류의 선을 만들 수 있다.     
세 점 $P_1, P_2, P_3$를 결합하는 경우 스칼라는 2개에서 3개로 늘어나는데 세 스칼라의 합은 1이 되어야 하므로 아핀 결합 식은 다음과 같이 전개된다.

###### 식 7-1

$$P' = s \cdot P_1 + t \cdot P_2 + (1 - s - t) \cdot P_3$$

[식 7-1](#식-7-1)을 점에서 점을 빼는 수식으로 바꿔 전개하면 다음과 같다.

###### 식 7-2

$$(P' - P_3) = s(P_1 - P_3) + t(P_2 - P_3)$$

[식 7-2](#식-7-2)의 각 괄호를 $\vec{u}, \vec{v}, \vec{w}$의 벡터로 치환하면 다음과 같이 벡터로 구성된 수식이 만들어진다.

###### 식 7-3

$$\vec{w} = s \cdot \vec{u} + t \cdot \vec{v}$$

벡터 $\vec{u}$와 $\vec{v}$가 서로 선형 독립의 관계라면 벡터 $\vec{w}$는 2차원 벡터 공간 $R^2$에 존재하는 모든 벡터를 생성할 수 있다.    
따라서 ***세 점의 아핀 결합은 평면의 모든 점을 만들어낸다***.

###### 그림 7-1 선형 독립의 관계를 가지는 두 벡터의 결합으로 만들어내는 평면의 점
![선형 독립의 관계를 가지는 두 벡터의 결합으로 만들어내는 평면의 점](/img/)

선분이 만들어지는 조건과 동일하게 $s$와 $t$의 값을 $|0, 1|$ 범위로 고정시키면 어떤 모습이 될지 확인해보자.  
[그림 7-2](#그림-7-2-세-점의-아핀-결합에서-범위를-제한한-경우)와 같이 스칼라 $s$와 $t$의 값을 몇 가지 지정해보면 해당 영역은 삼각형이 됨을 알 수 있다.

###### 그림 7-2 세 점의 아핀 결합에서 범위를 제한한 경우
![세 점의 아핀 결합에서 범위를 제한한 경우](/img/)

아핀 결합식에서 스칼라 값을 $|0, 1|$ 범위로 제한하면 시작과 끝의 범위가 명확해지므로 선분과 동일하게 그릴 수 있는 도형이 만들어진다.    
이렇게 아핀 결합에서 모든 스칼라 값을 $|0, 1|$ 범위로 한정한 결합을 ***컨벡스 결합(Convex combination)*** 이라고 부른다.   
컨벡스 결합은 [식 5-2](#식-5-2)의 아핀 결합식에 각 스칼라의 범위를 $|0, 1|$로 제한하는 조건을 추가해 다음과 같이 표현할 수 있다.

###### 식 7-4

$$\sum_{i=0}^n c_i \cdot P_i (s.t. \sum_{i=0}^n c_i = 1, 0 \leq c_i \leq 1)$$

선분이나 삼각형처럼 컨벡스 결합으로 만든 영역을 ***컨벡스 영역(Convex region)*** 이라고 한다.  
컨벡스 영역이란 ***'볼록한 형태의 영역'*** 이라 해석할 수 있다.    
수학에서 정의한 ***'볼록함'*** 이란, ***영역 내 임의의 두 점을 연결한 선분을 만들었을 때 그 선분은 언제나 해당 컨벡스 영역 안에 속하는 성질***을 의미한다.   
예를 들어 [그림 7-3](#그림-7-3-삼각형의-컨벡스-성질)의 삼각형 내 임의의 두 점 $P_1$과 $P_2$를 선택해 선분을 그리면, 선분 $\overline{P_1 P_2}$는 언제나 삼각형 내에 속한다.

###### 그림 7-3 삼각형의 컨벡스 성질
![삼각형의 컨벡스 성질](/img/)

컨벡스의 반대는 오목한 모양을 뜻하는 ***컨케이브(Concave)*** 다.   
[그림 7-4](#그림-7-4-컨벡스-영역a과-컨케이브-영역b의-비교)는 컨벡스 영역과 컨케이브 영역을 함께 비교한다.   
(b)의 ***컨케이브 영역은 임의의 두 점을 이은 선분이 영역 밖으로 벗어나는 경우가 발생***한다.

###### 그림 7-4 컨벡스 영역(a)과 컨케이브 영역(b)의 비교

아핀 공간에서 점 4개를 결합한 식을 벡터로 바꿔 표현하면 다음과 같이 전개된다.

$$\vec{x} = a \cdot \vec{u} + b \cdot \vec{v} + c \cdot \vec{w}$$

세 벡터 $\vec{u}, \vec{v}, \vec{w}$가 선형 독립 관계를 이룬다면 3차원 공간의 모든 벡터를 생성할 수 있으므로 아핀 결합으로 생성된 벡터 $\vec{x}$는 3차원 공간의 벡터가 된다.     
이때 스칼라 $a, b, c$의 값을 $|0, 1|$ 범위로 제한한다면 [그림 7-5](#그림-7-5-3차원-공간의-컨벡스-도형의-일종인-삼각뿔)와 같은 ***삼각뿔(Tetrahedron)*** 영역이 형성된다.  
삼각뿔 영역 또한 내부의 두 점을 연결한 선분은 항상 해당 영역에 속하는 컨벡스 성질을 가진다.

###### 그림 7-5 3차원 공간의 컨벡스 도형의 일종인 삼각뿔
![3차원 공간의 컨벡스 도형의 일종인 삼각뿔](/img/)

컨벡스 결합으로 만들어지는 1차원의 선분, 2차원의 삼각형, 3차원의 삼각뿔 중에서 ***가상 공간의 물체를 표현하는 데 가장 적합한 도형은 삼각형***이다.    
삼각형으로는 2차원의 물체를 효과적으로 표현할 수 있으며, 3차원의 물체도 표면만을 다루기 때문에 삼각형만으로 표현하는 것이 가장 효과적이기 때문이다.

# 22. 메시
3차원 공간의 입체적인 물체 또한 삼각형을 이어붙이면 표현이 가능하다.    
그래서 물체를 표현하기 위해 삼각형 ***데이터를 체계적으로 읽고 쓰는 방법***이 필요한데, ***삼각형을 중심으로 물체에 관련된 정보를 기록한 데이터***를 ***메시(Mesh)*** 라고 한다.   
[그림 7-6](#그림-7-6-메시의-예시)에서 그 사례를 볼 수 있다.    
(a)는 메시를 구성하는 삼각형의 세 점을 선을 이어 표현한 화면이고, (b)는 삼각형이 만들어내는 면에 이미지를 입혀서 물체를 렌더링한 결과다.

###### 그림 7-6 메시의 예시
![메시의 예시](/img/)

메시는 다수의 삼각형으로 구성되고, 메시를 이루는 삼각형은 다시 3개의 점으로 구성된다.   
메시는 결국 다수의 점으로 구성된다고 정리할 수 있다.

메시는 삼각형을 이용해 물체의 외형을 표현하기 때문에, 삼각형을 이루는 각 점의 위치를 가지고 있어야 한다.    
위치 정보만 담지 않고, 물체를 표현하는 데 활용할 수 있는 색상이나 방향과 같은 다양한 부가 정보도 담아 함께 제공한다.    
이렇게 ***위치 정보와 부가 정보를 묶은 특별한 점***을 ***정점(Vertex)*** 이라고 한다.

즉 메시는 정점들이 모인 데이터라고 할 수 있는데, 컴퓨터에서 메시를 읽어 물체를 표현할 때에는 메시의 정점 정보를 빠르게 읽기 위해서 ***메모리에 정점 정보를 일렬로 나열하는 배열의 형태로 관리한다***.     
이를 ***정점 버퍼(Vertex buffer)*** 라고 한다.     
정점 버퍼의 정보만으로는 어떤 세 정점이 모여 삼각형을 구성하는지 알 수 없다.    
그래서 삼각형을 구성하는 정점의 인덱스(순번)만 기록한 배열을 별도로 만들어 관리한다.    
이를 ***인덱스 버퍼(Index buffer)*** 라고 한다.    
인덱스 정보는 삼각형의 수만큼 필요하기 때문에 인덱스 버퍼의 크기는 항상 3의 배수다.     
이렇게 정점 버퍼와 인덱스 버퍼의 두 가지 배열 정보를 사용해 삼각형들을 하나씩 그려나가면 최종적으로 [그림 7-6](#그림-7-6-메시의-예시)과 같은 물체를 표현할 수가 있다.   
[그림 7-7](#그림-7-7-정사각형을-구성하는-메시-정보)은 두 개의 삼각형으로 이뤄진 정사각형 메시를 정점 버퍼와 인덱스 버퍼로 저장한 예시다.     
예시와 같이 두 삼각형이 빗변을 맞대고 나란히 붙어 있다면 0번째 점과 2번째 점은 두 삼각형이 공유해 사용할 수 있다.

###### 그림 7-7 정사각형을 구성하는 메시 정보

정점 배열과 인덱스 배열을 채운 후, 삼각형을 구성하는 세 점에서 두 점씩 묶어 선으로 삼각형을 표현해보자.     
삼각형을 하나씩 표현해나가면 [그림 7-6](#그림-7-6-메시의-예시)의 (a)와 같이 메시를 형상화할 수 있다.    
이렇게 삼각형의 외곽선만 그려 메시를 표현하는 방법을 ***와이어프레임(Wireframe)*** 이라고 한다.

# 23. 무게중심좌표
[식 7-1](#식-7-1)에 사용된 세 스칼라 $s, t, 1 - s - t$는 모두 실수이므로, 이들을 묶어서 하나의 3차원 벡터를 생성할 수 있다.     
이렇게 아핀 결합의 스칼라를 묶어 만든 좌표를 ***무게중심좌표(Barycentric coordinate)*** 라고 한다.     
무게중심좌표는 [그림 7-8](#그림-7-8-무게중심좌표의-의미)과 같이 삼각형에 관련된 정보를 담고 있기에, 삼각형에 관련된 기능을 구현할 때 유용하게 활용된다.

###### 그림 7-8 무게중심좌표의 의미
![무게중심좌표의 의미](/img/)

# 23.1. 무게중심좌표의 계산
[식 7-4](#식-7-4)에서 세 점의 아핀 결합이 삼각형이 되려면 모든 스칼라의 값이 $|0, 1|$ 범위 내에 있어야 했다.    
무게중심좌표를 구성하는 스칼라 값이 하나라도 $|0, 1|$ 범위를 벗어난다면 아핀 결합으로 생성된 점은 삼각형 외부에 있다고 할 수 있다.      
이러한 성질을 활용하면 주어진 점이 삼각형 영역의 내부에 있는지 외부에 있는지 판단할 수 있다.    
세 점의 아핀 결합 수식을 벡터로 변경한 [식 7-3](#식-7-3)을 도식화하면 [그림 7-9](#그림-7-9-삼각형을-구성하는-세-벡터)와 같다.

###### 그림 7-9 삼각형을 구성하는 세 벡터
![삼각형을 구성하는 세 벡터](/img/)

여기서 아핀 결합으로 생성되는 점 $P'$가 삼각형 내부에 있는지 판별하기 위해 ***내적***을 활용한다.     
[식 7-3](#식-7-3)의 벡터 $\vec{w}$에 $\vec{u}$와 $\vec{v}$를 각각 내적하면 다음 수식이 나온다.

$$\vec{w} \cdot \vec{u} = (s \cdot \vec{u} + t \cdot \vec{v}) \cdot \vec{u}$$

$$\vec{w} \cdot \vec{v} = (s \cdot \vec{u} + t \cdot \vec{v}) \cdot \vec{v}$$

내적 연산한 수식을 분배법칙에 따라 풀어주면 다음과 같이 전개된다.

$$\vec{w} \cdot \vec{u} = s(\vec{u} \cdot \vec{u}) + t(\vec{u} \cdot \vec{v})$$

$$\vec{w} \cdot \vec{v} = s(\vec{u} \cdot \vec{v}) + t(\vec{v} \cdot \vec{v})$$

여기서 $s$를 소거하기 위해, 1번 식에는 $(\vec{u} \cdot \vec{v})$를, 2번 식에는 $(\vec{u} \cdot \vec{u})$를 곱해 각각 전개한다.  

$$(\vec{w} \cdot \vec{u})(\vec{u} \cdot \vec{v}) = s(\vec{u} \cdot \vec{u})(\vec{u} \cdot \vec{v}) + t(\vec{u} \cdot \vec{v})(\vec{u} \cdot \vec{v})$$

$$(\vec{w} \cdot \vec{v})(\vec{u} \cdot \vec{u}) = s(\vec{u} \cdot \vec{v})(\vec{u} \cdot \vec{u}) + t(\vec{v} \cdot \vec{v})(\vec{u} \cdot \vec{u})$$

1번 식에서 2번 식을 빼 $s$를 소거하고 $t$만 남긴다.     
식을 풀어 $t$에 대해 정리하면 다음과 같은 식이 만들어진다.

$$t = \frac{(\vec{w} \cdot \vec{u})(\vec{u} \cdot \vec{v}) - (\vec{w} \cdot \vec{v})(\vec{u} \cdot \vec{u})}{(\vec{u} \cdot \vec{v})^2 - (\vec{u} \cdot \vec{u})(\vec{v} \cdot \vec{v})}$$

다시 예전 식으로 돌아가서, $s$에 대해 정리하기 위해 1번 식과 2번 식의 양변에 $(\vec{v} \cdot \vec{v})$와 $(\vec{u} \cdot \vec{v})$를 각각 곱한다.

$$(\vec{w} \cdot \vec{u})(\vec{v} \cdot \vec{v}) = s(\vec{u} \cdot \vec{u})(\vec{v} \cdot \vec{v}) + t(\vec{u} \cdot \vec{v})(\vec{v} \cdot \vec{v})$$

$$(\vec{w} \cdot \vec{v})(\vec{u} \cdot \vec{v}) = s(\vec{u} \cdot \vec{v})(\vec{u} \cdot \vec{v}) + t(\vec{v} \cdot \vec{v})(\vec{u} \cdot \vec{v})$$

1번 식에서 2번 식을 빼 $t$를 소거하고 $s$에 대해 정리한 식은 다음과 같다.

$$s = \frac{(\vec{w} \cdot \vec{v})(\vec{u} \cdot \vec{v}) - (\vec{w} \cdot \vec{u})(\vec{v} \cdot \vec{v})}{(\vec{u} \cdot \vec{v})^2 - (\vec{u} \cdot \vec{u})(\vec{v} \cdot \vec{v})}$$

이렇게 얻어진 무게중심좌표 $(s, t, 1 - s - t)$의 세 값 모두 $|0, 1|$ 범위 안에 있다면 점 $P_4$는 삼각형 안에 있고, 세 값 중 하나라도 $|0, 1|$ 범위를 벗어나면 점 $P_4$는 삼각형 밖에 있다고 판단할 수 있다.

이 식을 사용할 때 주의할 점은 공통분모 $(\vec{u} \cdot \vec{v})^2 - (\vec{u} \cdot \vec{u})(\vec{v} \cdot \vec{v})$의 결과가 0이 나올 수도 있다는 것이다.    
이처럼 분모 값이 0이라면 무게중심좌표를 구할 수 없다.   
어떤 경우에 분모 값이 0이 되는지 살펴보자.  
분모 $(\vec{u} \cdot \vec{v})^2 - (\vec{u} \cdot \vec{u})(\vec{v} \cdot \vec{v})$의 내적을 $\cos$ 공식으로 변경하면 다음과 같다.

$$(|\vec{u}||\vec{v}|)^2 \cdot \cos^2 \theta - (|\vec{u}||\vec{v}|)^2$$

이 값이 0이 되기 위한 조건은 벡터 $\vec{u}$ 또는 $\vec{v}$의 크기가 0이거나 벡터 $\vec{u}$와 $\vec{v}$가 이루는 각 $\theta$ 값이 $0^\circ$이거나 $180^\circ$일 때다.    
이는 두 벡터가 평행한 상태임을 의미하며, 두 벡터가 평행하면 [그림 7-10](#그림-7-10-퇴화삼각형의-예시)과 같이 선형 종속의 관계를 이루며, 선형 종속의 관계를 이루는 세 점의 결합은 삼각형이 아닌 선분을 만들어낸다.     
이러한 삼각형을 ***퇴화삼각형(Degenerate triangle)*** 이라 하며, 퇴화삼각형이 검출되면 그리기에서 제외한다.

###### 그림 7-10 퇴화삼각형의 예시
![퇴화삼각형의 예시](/img/)

# 24. 텍스처 매핑
무게중심좌표는 메시에 이미지를 입히는 용도로 활용할 수도 있다.  
메시에 이미지를 입히기 위해 변환된 데이터를 ***텍스처(Texture)*** 라고 하며, 메시에 이미지를 입히는 작업을 ***텍스처 매핑(Texture mapping)*** 이라 한다.

사진이나 그림을 저장한 이미지는 가로와 세로의 픽셀 수에 따른 고유한 해상도를 가진다.     
하지만 이미지를 메시에 입히기 위해 텍스처로 변환하면 관리 방식을 통일하기 위해 이미지의 원본 해상도에 관계없이 텍스처의 가로, 세로 크기는 1로 정규화된다.   
따라서 렌더링 과정에서 텍스처를 사용할 때에는 $|0, 1|$ 범위로 구성된 ***2차원 좌표계***를 사용한다.   
텍스처를 구성하는 2차원 좌표계를 ***UV 좌표계***라고 한다.

UV 좌표계는 2차원 벡터로 구성되며 가로 정보는 U, 세로 정보는 V로 지정된다.  

# 25. 3차원 공간의 설계
상하와 좌우만 존재했던 2차원 공간의 좌표계에서는 $x$축이 오른쪽, $y$축은 위쪽으로 방향이 명확했기 때문에 좌표계를 구성하는 데 큰 어려움이 없었다.   
3차원 공간은 2차원의 공간에 새로운 축을 추가해야 하는데, 이를 어떻게 설정하느냐에 따라 공간의 체계가 달라진다.

3차원 공간을 설계하는 방법은 크게 두 가지로 구분된다.
[그림 8-1](#그림-8-1-3차원-좌표계의-구성)처럼 사용자가 보는 모니터 화면이 데카르트 좌표계로 표현된다면, 나머지 한 축의 방향은 모니터가 바라보는 방향과 모니터 뒤편으로 향하는 뒤쪽 방향 두 가지로 나뉜다.  
나머지 한 축이 모니터가 바라보는 방향과 일치하는 체계를 ***오른손 좌표계(Right-handed coordinate system)*** 라 하고, 반대로 모니터 뒤편을 향하는 체계를 ***왼손 좌표계(Left-handed coordinate system)*** 라 한다.

###### 그림 8-1 3차원 좌표계의 구성
![3차원 좌표계의 구성](/img/)

왼손 좌표계와 오른손 좌표계는 용어가 의미하는 그대로 왼손과 오른손으로 파악해볼 수 있다.    
3차원 공간의 세 기저 축 $x, y, z$에 대해 $x \rightarrow y \rightarrow z \rightarrow x \rightarrow y$의 순서로 세 축이 순환된다고 생각해보자.    
주먹을 쥔 상태에서 엄지손가락만 세우고 나머지 네 손가락을 펴고 $x$축에서 $y$축 방향으로 손을 감으면, 나머지 축은 엄지 손가락이 가리키는 방향을 향한다.      
[그림 8-2](#그림-8-2-3차원-공간의-오른손-좌표계와-왼손-좌표계)와 같이 왼손을 사용해 $x$축에서 $y$축 방향으로 네 손가락을 감으면 엄지손가락은 모니터 뒤편을 향하고, 오른손을 감으면 엄지손가락은 모니터를 보는 자신을 향한다.

###### 그림 8-2 3차원 공간의 오른손 좌표계와 왼손 좌표계
![3차원 공간의 오른손 좌표계와 왼손 좌표계](/img/)

이렇게 왼손 좌표계와 오른손 좌표계 중 하나로 3차원 공간의 체계를 정했다면, 그 다음으로는 세 축의 용도를 지정해야 한다.      
2차원 공간에서 $x$축은 오른쪽과 왼쪽 방향, $y$축은 위와 아래 방향을 지정하는 용도로 사용됐다.   
하지만 3차원 공간에서는 이를 지정하는 방법이 프로그램마다 모두 다르다.  
위/아래 방향을 기준축으로 하여 각 소프트웨어별 좌표계 시스템을 나타낸 [그림 8-3](#그림-8-3-3d-소프트웨어가-사용하는-좌표계-시스템)을 살펴보면 (a)는 3D 모델링 소프트웨어 3DS 맥스가 사용하는 좌표계다.    
맥스는 오른손 좌표계를 사용하며 위와 아래 방향을 지정하는 데 $z$축을 사용한다.  
(b)는 게임 엔진인 유니티(Unity)가 사용하는 좌표계다.    
유니티는 왼손 좌표계를 사용하며 위와 아래 방향은 $y$축을 사용한다.  
(c)는 게임 엔진인 언리얼(Unreal)이 사용하는 좌표계다.   
언리얼도 유니티와 동일하게 왼손 좌표계를 사용하지만 위와 아래 방향은 $z$축을 사용한다.

###### 그림 8-3 3D 소프트웨어가 사용하는 좌표계 시스템
![3D 소프트웨어가 사용하는 좌표계 시스템](/img/)

3DS 맥스는 z업 오른손 좌표계, 유니티 엔진은 y업 왼손 좌표계, 언리얼 엔진은 z업 왼손 좌표계를 사용한다고 표현한다.

# 26. 3차원 공간의 트랜스폼
3차원 공간의 트랜스폼은 기저벡터가 하나 더 증가했을 뿐, 2차원 공간의 트랜스폼 설계 방식과 크게 다르지 않다.     
2차원 공간에서 이동 변환을 지원하기 위해 3차원 공간을 사용했듯이, 3차원 공간 역시 이동 변환을 위해 한 차원 더 늘어난 ***4차원 공간을 사용***한다.

2차원 공간의 크기 변환은 직교하는 $x$축과 $y$축이 서로 독립적으로 동작했다.     
3차원은 $x$축과 $y$축에 직교하는 $z$축이 하나 더 늘어났을 뿐이다.   
세 축은 모두 독립적으로 동작하기 때문에 3차원 공간의 크기 변환행렬은 다음과 같이 설계할 수 있다.

$$S = 
\begin{bmatrix}
S_x & 0 & 0 & 0 \\
0 & S_y & 0 & 0 \\
0 & 0 & S_z & 0 \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
$$

3차원 공간의 이동 변환도 모든 축이 독립적으로 동작한다.     
따라서 3차원 공간의 이동 행렬은 다음과 같이 설계할 수 있다.

$$T = 
\begin{bmatrix}
1 & 0 & 0 & t_x \\
0 & 1 & 0 & t_y \\
0 & 0 & 1 & t_z \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
$$

***회전 변환은 강체 변환의 성질을 가진다***.  
그렇기에 3차원 공간의 회전 변환은 3차원 공간을 구성하는 ***세 표준기저벡터가 동일한 크기와 직교성을 유지***한 상태로 함께 움직여야 한다.  
회전 변환으로 달라진 세 표준기저벡터값을 알 수 있다면 이를 열벡터로 꽂아넣어 회전 변환행렬 $R$을 만들어낼 수 있다.  

###### 그림 8-5 세 축의 기저벡터로 만들어지는 회전행렬
![세 축의 기저벡터로 만들어지는 회전행렬](/img/)

하지만 위와 같은 방법으로 3차원 공간의 회전을 지정한다는 것은 매번 3개의 변화된 표준기저벡터 값을 계산해야 하기 때문에 복잡한 일이 된다.   
따라서 회전을 지정할 때는 일반적으로 회전하는 중심축과 각으로 표현된 회전량을 지정하는 방식을 사용한다.     

2차원 공간은 하나의 평면만 존재하기 때문에 각으로 회전량을 지정하면 원하는 회전을 설계할 수 있다.   
하지만 3차원 공간은 무수히 많은 평면으로 구성되기 때문에 새로운 방식이 필요하다.

# 26.1. 오일러 각
***오일러 각(Euler's angle)*** 은 3차원 공간에서 물체가 놓인 방향을 3개의 각을 사용해 표시하는 방법이다.   
오일러 각은 직관적으로 이해하기 쉽기 때문에 3차원 공간을 사용하는 프로그램에서 자주 사용된다.   
[그림 8-6](#그림-8-6-유니티-엔진에서-오일러-각을-사용해-3차원-회전을-지정하는-예시)은 물체의 회전을 설정하기 위해 오일러 각을 설정하는 유니티 엔진의 인터페이스 화면이다.

###### 그림 8-6 유니티 엔진에서 오일러 각을 사용해 3차원 회전을 지정하는 예시
![유니티 엔진에서 오일러 각을 사용해 3차원 회전을 지정하는 예시](/img/)

게임 엔진에서 오일러 각을 사용해 물체의 방향을 표시할 때는 표준기저벡터를 사용한다.     
그래서 오일러 각은 표준기저벡터를 중심으로 회전하는 각의 크기로 지정된다.   
세 표준기저벡터를 중심으로 회전하는 각을 모으면 다음의 3차원 벡터로 표현할 수 있다. 

$$(\theta_x, \theta_y, \theta_z)$$

각의 값은 실수이기 때문에, ***오일러 각은 Vector3 구조체를 사용해 관리할 수 있다***.  
실제로 ***유니티 엔진에서는 Vector3를 사용해 오일러 각의 정보를 관리***한다.

이렇게 만들어진 ***오일러 각의 정보를 모든 프로그램에서 범용적으로 사용하기에는 문제가 있다***.   
왜냐하면 소프트웨어마다 $x, y, z$ ***축의 용도가 다르기 때문***이다.   
예를 들어 언리얼 엔진에서의 $x, y, z$축 회전과 유니티 엔진에서의 $x, y, z$축 회전은 서로 다르게 동작하기 때문에, 언리얼 엔진에서의 오일러 각 정보를 그대로 유니티 엔진으로 넘겨 사용할 수 없다.     
이런 문제를 해결하기 위해 $x, y, z$축 대신 ***회전의 움직임으로 회전 동작을 구분하고 각을 지정하는 방법을 사용***한다.

***표준기저벡터를 축으로 하는 회전의 움직임은 방향에 따라 요(Yaw), 롤(Roll), 피치(Pitch)로 불린다***.     
원래 항공기의 회전을 표현할 때 사용하는 용어인데, 게임에서도 동일하게 사용된다.     
요, 롤, 피치의 움직임은 [그림 8-7](#그림-8-7-요-롤-피치-회전)과 같다.

###### 그림 8-7 요, 롤, 피치 회전
![요, 롤, 피치 회전](/img/)

요, 롤, 피치의 움직임으로 오일러 각을 지정하면, 서로 다른 좌표계를 사용하는 프로그램 간에도 데이터를 쉽게 변환할 수 있다.

오일러 각을 사용해 3차원 공간의 회전을 표현할 수 있게 되었지만 ***렌더링 과정에서 3차원 공간의 회전을 사용하기 위해서는 어쩔 수 없이 회전행렬을 생성해야 한다***.

***오일러 각은 표준기저벡터를 중심으로 진행되는 세 번의 연속적인 회전을 의미한다***.  
예를 들어 $x$축 회전은 $yz$ 평면의 회전을 의미하는데, 이 경우 $x$값은 변하지 않고 오직 $y$축과 $z$축의 값만 변한다.     
따라서 $x$축의 회전행렬 $R_x$는 다음과 같이 설계할 수 있다.

$$R_x = 
\begin{bmatrix}
1 & 0 & 0 \\
0 & \cos \theta & -\sin \theta \\
0 & \sin \theta & \cos \theta \\
\end{bmatrix}
$$

동일한 방법으로 나머지 $y$축과 $z$축의 회전행렬 $R_y$와 $R_z$는 각각 다음과 같다.

$$R_y = 
\begin{bmatrix}
\cos \theta & 0 & \sin \theta \\
0 & 1 & 0 \\
-\sin \theta & 0 & \cos \theta \\
\end{bmatrix}
$$

$$R_z = 
\begin{bmatrix}
\cos \theta & -\sin \theta & 0 \\
\sin \theta & \cos \theta & 0 \\
0 & 0 & 1 \\
\end{bmatrix}
$$

주의 깊게 살펴볼 부분은 $y$축의 회전행렬 $R_y$다.   
다른 행렬은 모두 우측 상단의 $\sin$ 함수가 음의 부호인 반면 회전행렬 $R_y$는 좌측 하단의 $\sin$ 함수가 음의 부호를 가진다.  
3차원 공간에서는 $x \rightarrow y \rightarrow z \rightarrow x \rightarrow y$의 순서로 세 축이 순환되기 때문에 $y$축에 직교하는 평면은 $xz$ 평면이 아니라 $zx$ 평면이다.

# 26.2. 회전행렬의 유도
각 기저 축의 회전행렬을 구했다면, 이를 순서대로 적용해 최종 회전행렬을 만들어야 한다.   
세 번의 연속적인 회전으로 구성된 오일러 각 회전 방법은 [표 8-1](#표-8-1-오일러-각-조합에-대한-경우의-수)과 같이 총 6가지의 경우가 발생한다.

###### 표 8-1 오일러 각 조합에 대한 경우의 수
|경우|회전축의 순서|회전 동작의 순서|
|---|---|---|
|1|$x \rightarrow y \rightarrow z$|피치 $\rightarrow$ 요 $\rightarrow$ 롤|
|2|$x \rightarrow z \rightarrow y$|피치 $\rightarrow$ 롤 $\rightarrow$ 요|
|3|$y \rightarrow x \rightarrow z$|요 $\rightarrow$ 피치 $\rightarrow$ 롤|
|4|$y \rightarrow z \rightarrow x$|요 $\rightarrow$ 롤 $\rightarrow$ 피치|
|5|$z \rightarrow x \rightarrow y$|롤 $\rightarrow$ 피치 $\rightarrow$ 요|
|6|$z \rightarrow y \rightarrow x$|롤 $\rightarrow$ 요 $\rightarrow$ 피치|

언리얼 엔진과 유니티 엔진은 5번의 $z \rightarrow x \rightarrow y$의 순서를 사용한다.

***각 회전행렬을 순서대로 곱해 오일러 각에 대응되는 회전행렬*** $R$ ***을 생성할 수 있다***.

###### 식 8-1

$$R = R_{yaw} \cdot R_{pitch} \cdot R_{roll}$$

요, 피치, 롤 각의 값을 각 $\alpha, \beta, \gamma$라고 한다면 행렬 곱은 다음과 같이 계산된다.

$$
\begin{matrix}
R_\alpha \cdot R_\beta \cdot R_\gamma &=& 
\begin{bmatrix}
\cos \alpha & 0 & \sin \alpha \\
0 & 1 & 0 \\
-\sin \alpha & 0 & \cos \alpha \\
\end{bmatrix}
\begin{bmatrix}
1 & 0 & 0 \\
0 & \cos \beta & -\sin \beta \\
0 & \sin \beta & \cos \beta \\
\end{bmatrix}
\begin{bmatrix}
\cos \gamma & -\sin \gamma & 0 \\
\sin \gamma & \cos \gamma & 0 \\
0 & 0 & 1 \\
\end{bmatrix} \\
&=& 
\begin{bmatrix}
\cos \alpha \cos \gamma + \sin \alpha \sin \beta \sin \gamma & -\cos \alpha \sin \gamma + \sin \alpha \sin \beta \cos \gamma & \sin \alpha \cos \beta \\
\cos \beta \sin \gamma & \cos \beta \cos \gamma & -\sin \beta \\
-\sin \alpha \cos \gamma + \cos \alpha \sin \beta \sin \gamma & \sin \alpha \sin \gamma + \cos \alpha \sin \beta \cos \gamma & \cos \alpha \cos \beta \\
\end{bmatrix}
\end{matrix}
$$

***계산된 회전행렬의 열벡터는 표준기저벡터가 회전 변환된 로컬 축을 의미한다***.   
따라서 오일러 각으로 변환된 각 로컬 축의 값은 다음과 같이 계산해 얻을 수 있다.

$$x_{local} = (\cos \alpha \cos \gamma + \sin \alpha \sin \beta \sin \gamma, \cos \beta \sin \gamma, -\sin \alpha \cos \gamma + \cos \alpha \sin \beta \sin \gamma)$$

$$y_{local} = (-\cos \alpha \sin \gamma + \sin \alpha \sin \beta \cos \gamma, \cos \beta \cos \gamma, \sin \alpha \sin \gamma + \cos \alpha \sin \beta \cos \gamma)$$

$$z_{local} = (\sin \alpha \cos \beta, -\sin \beta, \cos \alpha \cos \beta)$$

3차원 공간의 트랜스폼도 회전 변환이 발생할 때마다 로컬 축 데이터를 갱신하면 게임 로직에서 유용하게 사용할 수 있을 뿐만 아니라, 렌더링 로직에 필요한 회전행렬도 바로 만들어 낼 수 있다.  
이 계산식으로 얻어낸 로컬 축 벡터를 각각 $\vec{x} = (x_x, x_y, x_z)$, $\vec{y} = (y_x, y_y, y_z)$, $\vec{z} = (z_x, z_y, z_z)$로 지정하고, 이들을 열벡터로 꽂아넣어 얻어지는 3차원 공간의 회전행렬 $R$은 다음과 같다.

$$R = 
\begin{bmatrix}
x_x & y_x & z_x & 0 \\
x_y & y_y & z_y & 0 \\
x_z & y_z & z_z & 0 \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
$$

# 26.3. 3차원 모델링 행렬
***3차원 공간의 트랜스폼***을 구성하는 ***크기(S)***, ***회전(R)***, ***이동(T)*** 변환행렬은 다음과 같다.  

$$S = 
\begin{bmatrix}
S_x & 0 & 0 & 0 \\
0 & S_y & 0 & 0 \\
0 & 0 & S_z & 0 \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
$$

$$R = 
\begin{bmatrix}
X_x & Y_x & Z_x & 0 \\
X_y & Y_y & Z_y & 0 \\
X_z & Y_z & Z_z & 0 \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
$$

$$T = 
\begin{bmatrix}
1 & 0 & 0 & t_x \\
0 & 1 & 0 & t_y \\
0 & 0 & 1 & t_z \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
$$

이 세 행렬을 $TRS$ 연산 순서에 따라 곱해 만든 ***모델링 행렬*** $M$은 다음과 같이 계산된다.

$$M = T \cdot R \cdot S = 
\begin{bmatrix}
X_xS_x & Y_xS_y & Z_xS_z & t_x \\
X_yS_x & Y_yS_y & Z_yS_z & t_y \\
X_zS_x & Y_zS_y & Z_zS_z & t_z \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
$$

# 27. 카메라 공간
2차원 카메라를 구현할 때에는 이동 기능만 부여했지만 3차원 공간의 카메라에는 이동과 회전 기능을 함께 부여한다.

3차원 공간에서 카메라 설정은 고려할 요소가 많다.    
[그림 8-8](#그림-8-8-3차원-공간의-카메라-설정)과 같이 월드 공간의 원점에 카메라가 있고, 카메라가 바라보는 방향에 게임 오브젝트가 위치한 상황을 가정해본다.  
이 상황에서 카메라의 $x$축과 $y$축으로 최종 화면을 생성한다고 설정했을 때 화면의 $x$축 방향은 익숙한 오른쪽이 아닌 왼쪽을 향하게 된다.

###### 그림 8-8 3차원 공간의 카메라 설정
![3차원 공간의 카메라 설정](/img/)

이는 보편적으로 인지하는 2차원 데카르트 좌표계와 다르기 때문에 바로잡아 줄 필요가 있다.     
그래서 카메라가 만들어내는 화면의 $x$축이 왼쪽을 향하도록 [그림 8-9](#그림-8-9-뷰-공간으로-재해석된-3차원-공간)와 같이 $y$축으로 $180^\circ$ 회전시켜 ***뷰 공간***을 구성한다.

이 경우 뷰 공간의 $z$축은 카메라의 뒤를 향하고, 뷰 공간에서 $x$축과 $z$축은 월드 공간의 $x$축과 $z$축의 반대 방향을 가지게 된다.

###### 그림 8-9 뷰 공간으로 재해석된 3차원 공간
![뷰 공간으로 재해석된 3차원 공간](/img/)

***카메라에는 크기의 개념이 없기 때문에, 카메라의 트랜스폼은 크기 변환을 제외한 회전과 이동 변환으로만 구성된다***.   
카메라의 트랜스폼에 저장된 위치 값을 $t = (t_x, t_y, t_z)$로 지정하고, 로컬 축 값을 각각 $x = (x_x, x_y, x_z)$, $y = (y_x, y_y, y_z)$, $z = (z_x, z_y, z_z)$로 지정한다.    
이동 행렬 $T$와 회전 행렬 $R$은 다음과 같다.

$$T = 
\begin{bmatrix}
1 & 0 & 0 & t_x \\
0 & 1 & 0 & t_y \\
0 & 0 & 1 & t_z \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
$$

$$R = 
\begin{bmatrix}
x_x & y_x & z_x & 0 \\
x_y & y_y & z_y & 0 \\
x_z & y_z & z_z & 0 \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
$$

뷰 행렬을 구하기 위한 역행렬을 계산해보자.  
이동 $T$의 역행렬 $T^{-1}$은 덧셈의 역원인 반대수를 사용해 구할 수 있다.    
***이동의 역행렬을 적용하면 모든 좌표는 카메라를 중심으로 재배치된다***.

$$T^{-1} = 
\begin{bmatrix}
1 & 0 & 0 & -t_x \\
0 & 1 & 0 & -t_y \\
0 & 0 & 1 & -t_z \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
$$

회전 변환 역시 이동 변환과 동일하게 역행렬을 적용시킨다.    
예를 들어 물체는 가만히 있는데 카메라가 $30^\circ$ 회전하는 상황이라면, 화면을 바라보는 사용자는 마치 물체가 $-30^\circ$ 회전하는 것으로 느낄 것이다.   
***직교행렬인 회전 변환행렬*** $R$의 ***역행렬*** $R^{-1}$은 다음과 같이 ***전치행렬***로 구할 수 있다.

$$R^{-1} = 
\begin{bmatrix}
x_x & x_y & x_z & 0 \\
y_x & y_y & y_z & 0 \\
z_x & z_y & z_z & 0 \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
$$

이동의 역행렬과 회전의 역행렬을 구했다면 이들을 적용해 최종 뷰 행렬을 완성할 수 있다.   
여기서, 이동의 역행렬을 먼저 적용할지, 회전의 역행렬을 먼저 적용할지를 선택해야 한다.   
적용 순서를 고려한다면 ***이동의 역행렬을 적용한 후에 회전의 역행렬을 적용해야 한다***.   
***카메라에 회전을 적용할 시점에 모든 좌표는 카메라를 중심으로 변환되어 있어야 하기 때문이다***.  
이는 트랜스폼의 순서를 거꾸로 돌리는 것과 동일한 원리로 볼 수 있다.

정리하면 크기 변환 $S$를 제외한 카메라의 트랜스폼으로부터 얻어지는 모델링 행렬 $M$은 다음과 같다.

$$M = T \cdot R$$

모델링 행렬의 역행렬 $M^{-1}$은 바로 뷰 행렬이 되며, 다음과 같이 전개된다.

$$M^{-1} = (T \cdot R)^{-1} = R^{-1} \cdot T^{-1}$$

두 행렬을 곱한 결과는 다음과 같다.  
마지막 4열은 내적을 사용해 간략하게 정리한다.

$$R^{-1} \cdot T^{-1} = 
\begin{bmatrix}
x_x & x_y & x_z & -x \cdot t \\
y_x & y_y & y_z & -y \cdot t \\
z_x & z_y & z_z & -z \cdot t \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
$$

마지막으로 최종 뷰 좌표계는 [그림 8-9](#그림-8-9-뷰-공간으로-재해석된-3차원-공간)와 같이 $y$축으로 $180^\circ$ 회전한 구조를 가져야 한다.   
이를 위해 $x$축 기저와 $z$축 기저를 반전시킨다.     
반전을 적용한 최종 뷰 행렬 $V$는 다음과 같다.

$$V = R^{-1} \cdot T^{-1} = 
\begin{bmatrix}
-x_x & -x_y & -x_z & x \cdot t \\
y_x & y_y & y_z & -y \cdot t \\
-z_x & -z_y & -z_z & z \cdot t \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
$$

뷰 좌표계에서 카메라 정면에 위치한 모든 물체의 $z$값은 음수다.

# 28. 오일러 각의 특징
3차원 트랜스폼의 회전을 담당하는 오일러 각 방식은 장점과 단점이 명확하게 존재한다.  

오일러 각은 ***3차원 공간의 회전을 지정할 때 직관적인 인터페이스를 제공***한다.   
설정할 값도 세 가지뿐이고, 직관적인 표준기저벡터를 회전축으로 사용하기 때문에 회전을 설계하기가 용이하다.   
이러한 오일러각은 사용자 입장에서 물체의 회전을 설정할 때 가장 적합하다.    
대다수 3차원 그래픽 소프트웨어에서 3차원 회전을 설정하는 인터페이스로 오일러 각 방식을 사용한다.

오일러 각의 또 다른 장점은 ***적은 용량으로 3차원 공간의 회전 정보를 기록할 수 있다***는 점이다.      
행렬을 사용해 3차원 공간의 회전을 표현하려면 최소 9개의 실수 데이터가 필요하지만, 오일러 각은 3개의 데이터만 있으면 3차원 공간의 회전을 표현할 수 있다.     
이는 트랜스폼 정보를 줄일 수 있어 적은 용량으로 게임 데이터를 관리할 수 있게 도와준다.

# 28.1. 짐벌락 현상
오일러 각을 사용해 3차원 공간의 회전을 다룰 때에는 특정 상황에서 회전 움직임이 제한되는 ***짐벌락(Gimbal lock)*** 이라 불리는 이상 현상을 감안해야 한다.     
짐벌락 현상을 알아보기 위해 오일러 각을 사용해 [그림 8-10](#그림-8-10-짐벌락-현상을-알아보기-위한-기준-설정)의 게임 오브젝트를 회전시켜 본다.

###### 그림 8-10 짐벌락 현상을 알아보기 위한 기준 설정
![짐벌락 현상을 알아보기 위한 기준 설정](/img/)

여기서 물체를 앞 방향인 $z$축으로 $90^\circ$ 회전(Roll)시킨다면, [그림 8-11](#그림-8-11-z축으로-90도-회전한-결과-화면)과 같이 얼굴 면이 반시계 방향으로 돌아가는 회전이 발생한다.

###### 그림 8-11 z축으로 90도 회전한 결과 화면
![z축으로 90도 회전한 결과 화면](/img/)

우측 방향인 $x$축으로 $-90^\circ$ 회전시킨다.    
목을 중심으로 시계 방향으로 돌아가게 된다.  
[그림 8-12](#그림-8-12-x축으로-회전한-결과-화면)처럼 게임 오브젝트는 위를 바라보게 된다.

###### 그림 8-12 x축으로 회전한 결과 화면
![x축으로 회전한 결과 화면](/img/)

위쪽 방향인 $y$축 회전을 적용한다.  
$y$축의 회전은 [그림 8-13](#그림-8-13-y축으로--45도-회전한-결과-화면)과 같이 얼굴 면이 돌아가는 회전이 되는데, 이는 처음 진행한 $z$축의 회전과 동일하다.

###### 그림 8-13 y축으로 -45도 회전한 결과 화면
![y축으로 -45도 회전한 결과 화면](/img/)

결과적으로 $z$축과 $y$축은 얼굴을 돌리는 동일한 회전이 되어버려, 세 개의 축으로 자유롭게 회전하지 못하고 두 개의 축만 회전에 사용됐다.  
이렇게 회전이 제약되는 현상을 짐벌락이라고 한다.

# 28.2. 회전 보간의 계산
3차원 공간에서 시작 회전과 끝 회전을 지정하고 시간에 따라 두 회전 사이를 부드럽게 전환하기는 기능은 카메라의 움직임이나 캐릭터 애니메이션을 구현하는 데 필요하다.   
이를 구현하기 위해서는 경과된 시간에 따라 회전이 변화되도록 중간 회전 값을 계산할 수 있어야 하는데 이를 ***회전 보간(Rotational interpolation)*** 이라고 한다.

중간 회전 값은 다음과 같이 선형 보간의 식을 사용해 얻을 수 있다.

$$\theta' = (1 - t)\theta_{start} + t\theta_{end}$$

예를 들어 동일한 평면 상에서 $15^\circ$에서 시작해 $165^\circ$로 끝나는 회전의 $\frac{1}{3}$ 비율에 해당하는 회전 보간 값은 $65^\circ$인데, 이는 다음의 수식으로 계산할 수 있다.

$$\frac{2}{3} \cdot 15^\circ + \frac{1}{3} \cdot 165^\circ = 65^\circ$$

***선형 보간식이 성립하려면 두 각의 회전 변환을 곱한 결과가 두 각의 합의 회전 변환과 동일해야 한다***.    
2차원 공간의 회전에서는 두 결과가 동일하기 때문에 2차원 공간의 회전에서 선형 보간식을 사용하는 데 아무런 문제가 없다.   
3차원 공간의 오일러 각 회전에서도 선형 보간식을 사용하는 데 문제가 없는지는 두 오일러 각의 회전 변환을 곱한 결과가 두 오일러 각의 합의 회전 변환과 동일한지 확인하면 알 수 있다.    
세 기저벡터 중에서 $y$축에 대해서만 회전하는 오일러 각 회전을 살펴보면, $y$축으로 $\alpha$와 $\beta$만큼 회전하는 오일러 각의 데이터는 각각 다음과 같다.

$$(0, \alpha, 0)$$

$$(0, \beta, 0)$$

[식 8-1](#식-8-1)에 의해 두 오일러 각에 대응하는 회전 변환 $R_\alpha$와 $R_\beta$는 다음과 같이 계산된다.

$$R_\alpha = R_{yaw\alpha} \cdot I \cdot I = R_{yaw\alpha}$$

$$R_\beta = R_{yaw\beta} \cdot I \cdot I = R_{yaw\beta}$$

두 오일러 각을 합한 회전 변환 $R_{(\alpha + \beta)}$는 다음과 같다.

$$R_{(\alpha + \beta)} = R_{yaw(\alpha + \beta)} \cdot I \cdot I = R_{yaw(\alpha + \beta)}$$

두 오일러 각에 대응하는 회전 변환 $R_\alpha$와 $R_\beta$를 곱한 결과를 전개해보자.

$$
\begin{matrix}
R_\beta \cdot R_\alpha &=& (R_{yaw\beta} \cdot R_{pitch\beta} \cdot R_{roll\beta}) \cdot (R_{yaw\alpha} \cdot R_{pitch\alpha} \cdot R_{roll\alpha}) \\
&=& (R_{yaw\beta} \cdot I \cdot I) \cdot (R_{yaw\alpha} \cdot I \cdot I) \\
&=& R_{yaw\beta} \cdot R_{yaw\alpha} \\
&=& R_{yaw(\beta + \alpha)} \\
&=& R_{(\alpha + \beta)} \\
\end{matrix}
$$

$y$축만 사용하는 두 오일러 각을 곱한 결과는 두 오일러 각을 합한 회전 변환 $R_{(\alpha + \beta)}$와 동일함을 확인할 수 있다.     
***오일러 각에서 한 축만 사용한다는 것은 결국 2차원 평면에서의 회전과 동일하다***.    
따라서 해당 상황에서는 선형 보간식을 사용하는 데 문제가 없다.

$x$축과 $y$축, 두 축에 대해서 회전하는 오일러 각에 대해 알아보자.   
두 축에 대해 $\alpha$와 $\beta$만큼 회전하는 오일러 각의 데이터는 각각 다음과 같다.

$$(\alpha, \alpha, 0)$$

$$(\beta, \beta, 0)$$

[식 8-1](#식-8-1)에 의해 두 오일러 각에 대응하는 회전 변환 $R_\alpha$와 $R_\beta$는 다음과 같이 계산된다.

$$R_\alpha = R_{yaw\alpha} \cdot R_{pitch\alpha} \cdot I = R_{yaw\alpha} \cdot R_{pitch\alpha}$$

$$R_\beta = R_{yaw\beta} \cdot R_{pitch\beta} \cdot I = R_{yaw\beta} \cdot R_{pitch\beta}$$

두 오일러 각을 합한 각의 회전 변환 $R_{(\alpha + \beta)}$는 다음과 같다.

$$R_{(\alpha + \beta)} = R_{yaw(\alpha + \beta)} \cdot R_{pitch(\alpha + \beta)} \cdot I = R_{yaw(\alpha + \beta)} \cdot R_{pitch(\alpha + \beta)}$$

두 오일러 각에 대응하는 회전 변환 $R_\alpha$와 $R_\beta$를 곱한 결과는 두 오일러 각을 합한 회전 변환 $R_{(\alpha + \beta)}$와 다르다.

$$
\begin{matrix}
R_\beta \cdot R_\alpha &=& (R_{yaw\beta} \cdot R_{pitch\beta} \cdot R_{roll\beta}) \cdot (R_{yaw\alpha} \cdot R_{pitch\alpha} \cdot R_{roll\alpha}) \\
&=& (R_{yaw\beta} \cdot R_{pitch\beta} \cdot I) \cdot (R_{yaw\alpha} \cdot R_{pitch\alpha} \cdot I) \\
&=& R_{yaw\beta} \cdot R_{pitch\beta} \cdot R_{yaw\alpha} \cdot R_{pitch\alpha} \\
&\neq& R_{(\alpha + \beta)} \\
\end{matrix}
$$

따라서 ***두 축 이상을 사용하는 오일러 각은 선형 보간식을 사용할 수 없다***.

일반적으로 게임에서 캐릭터의 회전은 $y$축에 대응하는 요 회전만을 사용하기 때문에 캐릭터 회전 보간은 오일러 각으로 충분히 구현 가능하다.     
하지만 비행기 조종 같은 3차원 공간에서 2개 이상의 기저축이 결합된 방식으로 회전을 진행하는 경우 오일러 각 방식을 사용해 회전 보간을 구현하는 작업은 어려워진다.     
3차원 공간에서 자유로운 회전 보간을 구현하고 싶은 경우에는 ***로드리게스 회전 공식***을 사용하거나 ***사원수***를 사용해야 한다.

# 29. 벡터의 외적
벡터에는 내적 외에도 ***외적(Cross product)*** 이라는 연산이 있는데 내적이 모든 차원의 벡터에 적용할 수 있는 것과 달리 ***외적은 3차원 공간의 벡터에서만 사용이 가능한 연산***이다.

3차원 벡터의 외적은 $\times$기호를 사용한다.    
두 3차원 벡터 $\vec{u}$와 $\vec{v}$의 외적 $\vec{u} \times \vec{v}$는 다음과 같다.

###### 식 9-1

$$\vec{u} = (u_x, u_y, u_z), \vec{v} = (v_x, v_y, v_z)$$

$$\vec{u} \times \vec{v} = (u_yv_z - v_yu_z, u_zv_x - v_zu_x, u_xv_y - v_xu_y)$$

외적은 회전의 순환 순서 $x \rightarrow y \rightarrow z \rightarrow x$에 맞춰 벡터를 순서대로 나열하는 형태이고, ***외적의 결과는 언제나 3차원 벡터가 된다***.     
이는 ***연산 결과가 항상 스칼라로 나오는 내적***과 대비된다.

외적 계산식의 패턴은 $x$ 성분의 결과를 만들기 위해 $x$와 관련없는 나머지 두 성분 $y$와 $z$를 결합해 만든다는 것이다.    
나머지 $y$와 $z$를 만들 때도 동일하다.  
이것도 항상 같은 성분만 사용하는 내적과 대비된다.   
두 연산에 사용되는 벡터의 요소를 비교하면 [그림 9-1](#그림-9-1-내적과-외적의-성질-비교)과 같다.

###### 그림 9-1 내적과 외적의 성질 비교
![내적과 외적의 성질 비교](/img/)

***외적은 교환법칙이 성립하지 않는다***.  
[식 9-1](#식-9-1)을 살펴보면 교환법칙이 성립하지 않는 뺄셈이 사용되고 있다.

$$\vec{u} \times \vec{v} \neq \vec{v} \times \vec{u}$$

뺄셈에서 두 수의 순서를 바꿔 계산하면 반대수가 나오는 것처럼 외적도 ***순서를 바꿔 연산하면 반대 방향의 벡터가 나온다***.     
외적의 특징을 수식으로 표현하면 다음과 같다.

$$a - b = -(b -a)$$

$$\vec{u} \times \vec{v} = -\vec{v} \times \vec{u}$$

***외적은 결합법칙도 성립하지 않는다***.

$$\vec{u} \times (\vec{v} \times \vec{w}) \neq (\vec{u} \times \vec{v}) \times \vec{w}$$

***덧셈에 대한 분배법칙은 성립한다***.

$$\vec{u} \times (\vec{v} + \vec{w}) = \vec{u} \times \vec{v} + \vec{u} \times \vec{w}$$

벡터의 내적과 외적의 차이를 정리하면 [표 9-1](#표-9-1-벡터의-내적과-외적의-차이1)과 같다.

###### 표 9-1 벡터의 내적과 외적의 차이(1)
||내적|외적|
|---|---|---|
|계산 결과|스칼라|벡터|
|교환법칙|성립함|성립하지 않음|
|결합법칙|성립하지 않음|성립하지 않음|
|분배법칙|성립함|성립함|
|연산 방법|같은 위치의 요소만 사용|다른 위치의 요소만 사용|

서로 대립되는 내적과 외적의 성질은 각 연산이 가지는 부족한 부분을 상호보완하는 기능으로 활용된다.

# 29.1. 평행성 판별
동일한 벡터끼리 내적하면 벡터 크기를 제곱한 값이 나오는데, ***동일한 벡터를 외적하면 그 결과는 항상 영벡터가 나온다***.

$$\vec{u} \times \vec{u} = (u_yu_z - u_yu_z, u_zu_x - u_zu_x, u_xu_y - u_xu_y) = (0, 0, 0)$$

이는 $\vec{u}$와 반대 방향의 벡터 $-\vec{u}$를 외적하는 경우에도 동일하다.  

$$\vec{u} \times -\vec{u} = (-u_yu_z + u_yu_z, -u_zu_x + u_zu_x, -u_xu_y + u_xu_y) = (0, 0, 0)$$

$\vec{u}$와 평행하지만 크기가 다른 $\vec{v}$라는 벡터를 서로 외적해도 0이 된다.

$$\vec{v} = k \cdot \vec{u}$$

$$\vec{u} \times \vec{v} = (ku_yu_z - ku_yu_z, ku_zu_x - ku_zu_x, ku_xu_y - ku_xu_y)$$

이로써 평행한 두 벡터를 외적하면 항상 영벡터가 됨을 알 수 있으며, 이러한 외적의 성질은 ***평행성을 판별하는 데 사용***된다.   
이는 ***두 벡터의 직교성을 판별하는 내적의 성질과 대립***된다.

외적의 성질을 자세히 알아보기 위해, [그림 9-2](#그림-9-2-벡터를-수평-성분과-수직-성분으로-분리하기)처럼 벡터 $\vec{u}$를 벡터 $\vec{v}$에 수평인 벡터 $\vec{u_\parallel}$과 수직인 벡터 $\vec{u_\perp}$로 분리한다.  
벡터 $\vec{u}$는 수평 성분과 수직 성분의 덧셈으로 분리된다.

###### 그림 9-2 벡터를 수평 성분과 수직 성분으로 분리하기
![벡터를 수평 성분과 수직 성분으로 분리하기](/img/)

외적은 덧셈의 분배법칙이 성립하므로 벡터 $\vec{u}$를 분리한 벡터 $\vec{u_\perp}$, $\vec{u_\parallel}$와 $\vec{v}$의 외적은 다음과 같이 전개된다.

$$\vec{v} \times \vec{u} = \vec{v} \times (\vec{u_\perp} + \vec{u_\parallel}) = \vec{v} \times \vec{u_\perp} + \vec{v} \times \vec{u_\parallel}$$

벡터 $\vec{v}$와 평행한 벡터 $\vec{u_\parallel}$와의 외적은 크기와 관계 없이 영벡터가 된다.     
따라서 위 식은 다음과 같이 간략하게 정리된다.

$$\vec{v} \times \vec{u} = \vec{v} \times \vec{u_\perp}$$

이로써 ***외적은 상대방에 직교하는 벡터 성분만 사용되는 성질이 있음***을 알 수 있다.  
두 벡터의 사잇각을 $\theta$라고 할 때 [그림 9-3](#그림-9-3-크기는-같지만-사잇각이-다른-두-벡터의-수직-성분의-크기-비교)을 살펴보면 두 벡터의 사잇각이 큰 (a)의 직교하는 성분 $\vec{u_\perp}$의 크기는 그보다 사잇각이 작은 (b)의 직교하는 성분 $\vec{u_\perp}$보다 크다.   
직교 성분 $\vec{u_\perp}$의 크기는 $\sin$ 함수에 비례하므로 외적의 크기도 $\sin$ 함수에 비례한다.

###### 그림 9-3 크기는 같지만, 사잇각이 다른 두 벡터의 수직 성분의 크기 비교
![크기는 같지만, 사잇각이 다른 두 벡터의 수직 성분의 크기 비교](/img/)

실제로 외적의 결과가 $\sin$ 함수에 비례하는지 수식으로 확인해보자.  
이를 위해 준비한 세 가지 연산 $|\vec{u} \times \vec{v}|^2$, $(|\vec{u}||\vec{v}|)^2$, $(\vec{u} \cdot \vec{v})^2$을 각각 전개한다.  
첫 번째 식 $|\vec{u} \times \vec{v}|^2$를 전개하면 다음과 같다.

$$
\begin{matrix}
|\vec{u} \times \vec{v}|^2 &=& (\vec{u} \times \vec{v}) \cdot (\vec{u} \times \vec{v}) \\
&=& (u_yv_z - u_zv_y)^2 + (u_zv_x - u_xv_z)^2 + (u_xv_y - u_yv_x)^2 \\
&=& u_y^2v_z^2 - 2u_yu_zv_yv_z + u_z^2v_y^2 + u_z^2v_x^2 - 2u_yu_zv_yv_z + u_x^2v_z^2 + u_x^2v_y^2 - 2u_xu_yv_xv_y + u_y^2v_x^2 \\
\end{matrix}
$$

두 번째 식 $(|\vec{u}||\vec{v}|)^2$를 전개하면 다음과 같다.

$$
\begin{matrix}
(|\vec{u}||\vec{v})^2 &=& (\sqrt{u_x^2 + u_y^2 + u_z^2} \sqrt{v_x^2 + v_y^2 + v_z^2})^2 \\
&=& (u_x^2 + u_y^2 + u_z^2)(v_x^2 + v_y^2 + v_z^2) \\
&=& u_x^2v_x^2 + u_x^2v_y^2 + u_x^2v_z^2 + u_y^2v_x^2 + u_y^2v_y^2 + u_y^2v_z^2 + u_z^2v_x^2 + u_z^2v_y^2 + u_z^2v_z^2 \\
\end{matrix}
$$

마지막 식 $(\vec{u} \cdot \vec{v})^2$를 전개하면 다음과 같다.

$$
\begin{matrix}
(\vec{u} \cdot \vec{v})^2 &=& (u_xv_x + u_yv_y + u_zv_z)^2 \\
&=& u_x^2v_x^2 + u_y^2v_y^2 + u_z^2v_z^2 + 2u_xu_yv_xv_y + 2u_xu_zv_xv_z + 2u_yu_zv_yv_z \\
\end{matrix}
$$

세 식의 결과를 비교하면 당므과 같은 관계를 가진다.

$$|\vec{u} \times \vec{v}|^2 = (|\vec{u}||\vec{v}|)^2 - (\vec{u} \cdot \vec{v})^2$$

위 식의 내적 $\vec{u} \cdot \vec{v}$를 코사인 공식으로 바꿔 전개하면 아래와 같다.

$$
\begin{matrix}
|\vec{u} \times \vec{v}|^2 &=& (|\vec{u}||\vec{v}|)^2 - (|\vec{u}||\vec{v}| \cos \theta)^2 \\
&=& (|\vec{u}||\vec{v}|)^2(1 - \cos^2 \theta) \\
&=& (|\vec{u}||\vec{v}|)^2 \sin^2 \theta \\
\end{matrix}
$$

이로써 벡터 외적의 크기는 $\sin$ 함수의 크기에 비례함을 알 수 있다.

$$|\vec{u} \times \vec{v}| = |\vec{u}||\vec{v}||\sin \theta|$$

***외적으로 생성된 벡터의 크기는*** [그림 9-4](#그림-9-4-두-벡터-u와-v가-만드는-평행사변형의-넓이)와 같이 ***두 벡터가 만드는 평행사변형의 넓이로 나타낼 수 있다***.    
이는 ***행렬식이 만들어내는 넓이와 동일***하다.

###### 그림 9-4 두 벡터 u와 v가 만드는 평행사변형의 넓이
![두 벡터 u와 v가 만드는 평행사변형의 넓이](/img/)

[표 9-1](#표-9-1-벡터의-내적과-외적의-차이1)에 이어 내적과 대비되는 외적의 성질을 정리하면 [표 9-2](#표-9-2-벡터의-내적과-외적의-차이2)와 같다.

###### 표 9-2 벡터의 내적과 외적의 차이(2)

||내적|외적|
|---|---|---|
|판별성|직교성|평행성|
|삼각함수|$\cos \theta$|$\sin \theta$|

# 29.2. 법선 벡터
벡터 외적이 가지는 또 하나의 중요한 성질은 ***두 벡터에 직교하는 벡터를 생성한다***는 것이다.     
임의의 두 벡터 $\vec{u} = (u_x, u_y, u_z)$와 $\vec{v} = (v_x, v_y, v_x)$의 외적을 계산해 확인해보자.

$$\vec{u} \times \vec{v} = (u_yv_z - v_yu_z, u_zv_x - v_zu_x, u_xv_y - v_xu_y)$$

$\vec{u}$와 $\vec{v}$의 외적 결과에 벡터 $\vec{u}$를 내적하면 결과는 항상 0이 된다.

$$\vec{u} \cdot (\vec{u} \times \vec{v}) = u_xu_yv_z - u_xv_yu_z + u_yu_zv_x - u_yv_zu_x + u_zu_xv_y - u_zv_xu_y = 0$$

동일한 방법으로 $\vec{u}$와 $\vec{v}$의 외적 결과에 벡터 $\vec{v}$를 내적해도 0이 나온다.

$$\vec{v} \cdot (\vec{u} \times \vec{v}) = v_xu_yv_z - v_xv_yu_z + v_yu_zv_x - v_yv_zu_x + v_zu_xv_y - v_zv_xu_y = 0$$

***외적의 결과는 두 벡터에 모두 직교함***을 알 수 있다.   
***선형 독립의 관계를 가지는 두 벡터의 선형 결합은 평면을 만든다***.   
두 벡터의 외적은 두 벡터가 만드는 평면에 직교하는, 다시 말하면 ***평면이 향하는 방향에 대한 벡터를 만들어내는 것으로 해석할 수 있다***.

[그림 9-5](#그림-9-5-법선-벡터를-생성하는-외적)와 같이 3개의 점 $P_1, P_2, P_3$를 결합해 만든 평면을 가정한다.   
점 $P_2$와 $P_3$에서 점 $P_1$을 뺀 두 벡터 $\vec{u}$와 $\vec{v}$를 생성한 후 둘을 외적하면 세 점이 만들어내는 평면에 직교하는 벡터가 생성된다.  
이는 평면이 향하는 방향을 나타내며 이 벡터를 ***법선 벡터(Normal vector)*** 또는 ***노멀 벡터***라고 한다.

###### 그림 9-5 법선 벡터를 생성하는 외적
![법선 벡터를 생성하는 외적](/img/)

외적은 교환법칙이 성립하지 않기 때문에, 연산의 순서를 바꾼 $\vec{v} \times \vec{u}$는 [그림 9-6](#그림-9-6-외적의-적용-순서에-따른-결과-비교)과 같이 $\vec{u} \times \vec{v}$의 반대 방향으로 향하는 법선 벡터가 생성된다.   
따라서 ***법선 벡터를 생성할 때에는 외적의 연산 순서에 신경 써야 한다***.

###### 그림 9-6 외적의 적용 순서에 따른 결과 비교
![외적의 적용 순서에 따른 결과 비교](/img/)

이렇게 두 개의 다른 벡터가 나오는 이유는 ***3차원 공간에서 평면은 앞면과 뒷면으로 구성***되어 있기 때문이다.  

# 29.3. 좌우 방향 판별
$\sin$ 함수와 관련 있는 외적의 성질은 게임 개발에서 유용하게 활용할 수 있다.    
대표적인 외적의 활용 방법은 ***왼쪽과 오른쪽의 판별***이다.   
[그림 9-7](#그림-9-7-좌우-방향-판별을-위한-예시-상황)은 월드 공간의 $y$축 $\vec{y} = (0, 1, 0)$에 직교하는 평면에 캐릭터와 물체가 놓여 있는 상황이다.      
이때 캐릭터의 정면을 향하는 시선 벡터 $\vec{f}$와 캐릭터에서 물체로 향하는 벡터 $\vec{v}$가 주어진 상황을 가정한다.

###### 그림 9-7 좌우 방향 판별을 위한 예시 상황
![좌우 방향 판별을 위한 예시 상황](/img/)

만일 물체가 시선 방향의 왼쪽에 있다면 시선 벡터 $\vec{f}$에서 물체로 향하는 벡터 $\vec{v}$로 외적한 결과는 오른손 법칙에 따라 평면의 위쪽인 $\vec{y}$로 향한다.     
반대로 물체가 시선 방향의 오른쪽에 있다면 외적의 결과는 평면의 아래쪽인 $-\vec{y}$로 향한다.    
왼쪽과 오른쪽에 따라 달라지는 외적 결과는 [그림 9-8](#그림-9-8-물체가-놓인-위치가-왼쪽-오른쪽에-따라-달라지는-외적의-결과)과 같다.

###### 그림 9-8 물체가 놓인 위치가 왼쪽, 오른쪽에 따라 달라지는 외적의 결과
![물체가 놓인 위치가 왼쪽, 오른쪽에 따라 달라지는 외적의 결과](/img/)

이러한 외적의 성질을 활용하면 ***시선 방향을 기준으로 물체가 왼쪽에 있는지 오른쪽에 있는지를 파악할 수 있다***.   
외적의 결과는 벡터이므로, 참 거짓을 파악할 수 있도록 스칼라로 변환해야 한다.    
이를 위해서는 외적의 결과에 내적을 추가로 활용해야 한다.    
외적 결과에 평면의 위쪽 방향을 나타내는 벡터 $\vec{y}$를 내적한다.  
두 벡터의 방향이 같다면 내적 값은 양수, 반대 방향이라면 음수가 된다.    
따라서 물체가 캐릭터의 시선 방향 왼쪽에 있다면 내적의 결과는 양수, 오른쪽에 있다면 음수가 된다.     
외적과 내적 연산을 조합해 파악할 수 있는 경우의 수를 [표 9-3](#표-9-3-물체의-좌우-방향-판별을-위한-수식)에 정리했다.

###### 표 9-3 물체의 좌우 방향 판별을 위한 수식

|물체의 위치|판별식의 값|
|---|---|
|물체가 시선 방향에서 왼쪽에 있는 경우|$(\vec{f} \times \vec{v}) \cdot \vec{y} > 0$|
|물체가 시선 방향에서 오른쪽에 있는 경우|$(\vec{f} \times \vec{v}) \cdot \vec{y} < 0$|
|물체가 정확히 시선 방향과 일치하는 경우|$(\vec{f} \times \vec{v}) = 0$|

이러한 좌우 방향 판별에 사용되는 외적의 응용은 $\sin$ 함수에 비례하는 외적의 성질에 기인한다.   
반면 내적은 $\cos$ 함수에 비례하기 때문에 앞뒤 방향 판별에 사용된다.    
[그림 9-9](#그림-9-9-삼각함수에-비례하는-내적a과-외적b이-가지는-부호-영역)의 (a)는 두 벡터의 사잇각이 $\cos$ 함수에 비례하는 내적의 부호 영역이고, (b)는 $\sin$ 함수에 비례하는 외적의 부호 영역이다.

###### 그림 9-9 삼각함수에 비례하는 내적(a)과 외적(b)이 가지는 부호 영역
![삼각함수에 비례하는 내적(a)과 외적(b)이 가지는 부호 영역](/img/)

[표 9-1](#표-9-1-벡터의-내적과-외적의-차이1)과 [표 9-2](#표-9-2-벡터의-내적과-외적의-차이2)에 이어 내적에 대비되는 외적의 성질은 [표 9-4](#표-9-4-벡터의-내적과-외적의-차이3)와 같다.

###### 표 9-4 벡터의 내적과 외적의 차이(3)

||내적|외적|
|---|---|---|
|방향 판별|앞, 뒤|왼쪽, 오른쪽|

# 30. 벡터로부터 회전행렬 생성
임의로 주어진 ***두 벡터에 직교하는 벡터를 생성하는 외적의 성질***은 ***카메라의 회전을 설정하는 데도 사용***된다.      
[그림 9-10](#그림-9-10-물체를-바라보는-카메라의-설정)과 같이 3차원 공간에서 좌우로 기울어지지 않은 카메라가 아래쪽에 위치한 물체를 바라보고 있는 상황을 설정한다.

###### 그림 9-10 물체를 바라보는 카메라의 설정
![물체를 바라보는 카메라의 설정](/img/)

오일러 각 방식을 사용해 카메라의 회전을 지정할 수 있지만, 외적을 사용하면 ***카메라의 시선 벡터 정보로부터 카메라의 세 가지 로컬 축을 구하고 이로부터 회전행렬까지 얻어낼 수 있다***.

[그림 9-11](#그림-9-11-카메라의-로컬-z축-구하기)처럼 물체의 위치에서 카메라 위치를 뺀 후 크기를 1로 정규화시킨 시선 벡터 $\vec{v}$를 생성한다.   
이 벡터는 카메라 트랜스폼의 로컬 $z$축이 된다.

###### 그림 9-11 카메라의 로컬 z축 구하기
![카메라의 로컬 z축 구하기](/img/)
 
카메라의 로컬 $x$축은 [그림 9-12](#그림-9-12-카메라의-로컬-x축-구하기)에 보이는 것처럼 ***업벡터(Up vector)*** 라고도 불리는 월드 공간의 $y$축과 카메라의 로컬 $z$축을 외적하면 얻을 수 있다.

월드 공간의 $y$축을 벡터 $\vec{u}$로 표시하고 이를 카메라의 로컬 $z$축과 외적한 후 이를 정규화시키면 카메라의 로컬 $x$축이 구해진다.

###### 그림 9-12 카메라의 로컬 x축 구하기
![카메라의 로컬 x축 구하기](/img/)

로컬 $z$축과 로컬 $x$축을 외적하면 [그림 9-13](#그림-9-13-뷰-공간의-최종-y축-기저벡터)과 같이 마지막 남은 로컬 $y$축을 구할 수 있다.     
이때는 ***두 벡터가 단위 벡터이므로 외적의 결과도 단위 벡터가 된다***.

###### 그림 9-13 뷰 공간의 최종 y축 기저벡터
![뷰 공간의 최종 y축 기저벡터](/img/)

정리하면 카메라가 바라보는 시선 벡터 $\vec{v}$와 주어지는 업벡터 $\vec{u}$로부터 로컬 공간을 구성하는 세 기저벡터 $\vec{x}$, $\vec{y}$, $\vec{z}$를 다음과 같이 구할 수 있다.

$$\vec{x} = \frac{\vec{u} \times \vec{z}}{|\vec{u} \times \vec{z}|}$$

$$\vec{y} = \vec{z} \times \vec{x}$$

$$\vec{z} = \frac{\vec{v}}{|\vec{v}|}$$

카메라 트랜스폼의 회전행렬 $R$은 로컬 벡터를 열벡터로 지정해 다음과 같이 생성할 수 있다.

$$R = 
\begin{bmatrix}
x_x & y_x & z_x & 0 \\
x_y & y_y & z_y & 0 \\
x_z & y_z & z_z & 0 \\
0 & 0 & 0 & 1 \\
\end{bmatrix}
$$

시선 벡터로부터 카메라의 로컬 축을 계산하는 데 있어 추가로 고려해야 할 예외 상황이 있다.    
그 중 하나는 카메라의 위쪽 방향이다.    
앞서 살펴본 방법은 카메라의 위쪽 방향이 월드 공간의 $y$축을 향한다고 가정한다.  
하지만 [그림 9-14](#그림-9-14-거꾸로-뒤집힌-카메라의-뷰-공간)와 같이 카메라가 거꾸로 뒤집혀 있는 상황이라면, 로컬 $x$축을 구하기 위한 업벡터로 월드 공간 $y$축의 반대 방향인 $(0, -1, 0)$을 사용해야 한다.

###### 그림 9-14 거꾸로 뒤집힌 카메라의 뷰 공간
![거꾸로 뒤집힌 카메라의 뷰 공간](/img/)

일반적인 상황에서는 카메라가 위를 향해 세워져 있겠지만, 그렇지 않은 경우도 간혹 발생할 수 있으니 외적에 사용될 업벡터의 값을 입력받도록 설계하는 것이 안전하다.

그다음 고려할 예외 상황으로는 [그림 9-14](#그림-9-14-거꾸로-뒤집힌-카메라의-뷰-공간)와 같이 로컬 $z$축이 업벡터와 평행한 때다.     
두 벡터가 평행하면 외적 결과가 영벡터가 되어 더 이상 계산을 진행할 수가 없다.   
이 경우에는 외적을 계산하는 대신, 로컬 $z$축에 직교하는 로컬 $x$축의 값을 수동으로 지정해야 한다.

###### 그림 9-15 카메라의 시선 방향이 월드 공간 y축과 평행한 경우
![카메라의 시선 방향이 월드 공간 y축과 평행한 경우](/img/)

# 31. 렌더링 계산량을 줄여주는 백페이스 컬링
게임은 실시간으로 빠르게 렌더링을 처리해야 하기 때문에 시선에 감지되지 않는 ***메시(Mesh)*** 의 ***뒷면(Backface)*** 은 그리지 않고 건너뛰는 것이 효과적이다.     
이렇게 카메라와 마주보지 않는 뒷면을 생략하는 기법을 ***백페이스 컬링(Backface culling)*** 이라고 한다.    
백페이스 컬링은 메시의 삼각형을 구성하는 세 정점의 외적을 활용해 구현할 수 있다.    
[그림 9-16](#그림-9-16-정점-버퍼와-인덱스-버퍼)과 같이 삼각형을 구성하는 메시 데이터가 설정된 상황을 설정한다.

###### 그림 9-16 정점 버퍼와 인덱스 버퍼
![정점 버퍼와 인덱스 버퍼](/img/)

삼각형의 세 점을 지정하는 인덱스 버퍼에는 점의 순서가 나열되어 있다.    
이를 활용한다면 삼각형의 방향을 지정하지 않아도 외적을 사용해 삼각형이 향하는 방향을 파악할 수 있다.    
[그림 9-17](#그림-9-17-점의-순서에-따른-면의-방향의-결정)는 인덱스 버퍼의 순서에 따라 삼각형의 방향이 어떻게 결정되는지를 정리한다.   
(a)는 ***시계 방향으로 정점이 나열되어 있으므로 삼각형이 향하는 방향은 지면의 뒤편***을 향하게 되고, (b)는 ***반시계 방향으로 정점이 나열되어 있어서 지면***을 향한다.

###### 그림 9-17 점의 순서에 따른 면의 방향의 결정
![점의 순서에 따른 면의 방향의 결정](/img/)

이렇게 정한 삼각형의 방향과 카메라의 시선 방향을 대조해 ***서로 마주보면 삼각형을 그리고, 같은 방향을 바라보면 그리기를 생략하는 것이 백페이스 컬링의 알고리즘***이다.    
(a)는 삼각형의 방향과 카메라의 시선 방향이 같은 방향을 향하고 있다.     
따라서 해당 삼각형은 그리기를 생략해 렌더링 계산량을 줄일 수 있다.      
(b)는 삼각형의 방향과 카메라의 시선 방향이 마주보고 있다.   
따라서 해당 삼각형은 그려준다.

###### 그림 9-18 백페이스 컬링의 원리
![백페이스 컬링의 원리](/img/)

# 32. 오일러 각의 문제를 해결하는 로드리게스 회전 공식
3차원 회전을 관리하기 위해 오일러 각을 사용하고 있지만, ***오일러 각은 짐벌락 현상이 발생하고, 회전 보간이 어렵다***는 문제가 있다.   
오일러 각의 문제는 임의의 축에 대한 평면의 회전 방식을 사용하면 해결이 가능하다.    
이 방식을 ***각-축 회전(Axis-Angle rotation)*** 이라 부르는데, [그림 9-19](#그림-9-19-임의의-축에-대한-회전의-개요)과 같이 3차원 공간에서 지정된 임의의 축에 직교하는 평면에서 회전이 진행되는 형태를 띤다.

###### 그림 9-19 임의의 축에 대한 회전의 개요
![임의의 축에 대한 회전의 개요](/img/)

축-각 회전을 수행하는 회전 공식을 내적과 외적을 사용해 직접 유도한다.   
이를 위해 [그림 9-20](#그림-9-20-회전-평면의-설정)과 같이 관련된 점과 벡터에 각각 기호를 붙인다.     
***회전축은 회전이 발생하는 평면에 직교하는 법선 벡터다***.   
이를 벡터 $\vec{n}$으로 지정하고 편의를 위해 크기를 1로 정규화시킨다.   
회전시킬 점을 $P$, 점 $P$가 각 $\theta$만큼 회전한 최종 점을 $P'$으로 표기하고, 월드 공간의 원점을 $O$로, 회전 평면의 중심점을 $O'$으로 지정한다.    
이때 점 $P$의 좌표는 다음과 같이 설정한다.

###### 그림 9-20 회전 평면의 설정
![회전 평면의 설정](/img/)

원점 $O$에서부터 회전시킬 점 $P$까지의 벡터를 $\vec{u}$로 지정한다.     
점 $P$와 벡터 $\vec{u}$의 값은 마지막 차원의 값만 다를 뿐 $(x, y, z)$의 값은 동일하다.  
따라서 구해야할 점 $P'$의 좌표는 벡터 $\vec{u}$를 구해서 얻을 수 있다.

$$\vec{u} = P - O = (x, y, z, 0)$$

임의의 축 $\hat{n}$에 대해 벡터 $\vec{u}$를 각 $\theta$만큼 회전시켜 벡터 $\vec{u'}$을 계산하는 축-각 회전의 공식은 다음과 같다.

###### 식 9-2

$$\vec{u'} = \cos \theta \cdot \vec{u} + (1 - \cos \theta) \cdot (\vec{u} \cdot \hat{n}) \cdot \hat{n} + \sin \theta \cdot (\hat{n} \times \vec{u})$$

원점에서 회전시킬 점으로 향하는 벡터 $\vec{u}$를 평면의 회전축에 해당하는 법선 벡터 $\hat{n}$에 투영한다.   
벡터 $\vec{u}$가 투영할 벡터 $\hat{n}$의 크기가 1이므로 투영 공식에 의해 벡터 $\vec{OO'}$의 값은 $(\vec{u} \cdot \hat{n}) \cdot \hat{n}$이 된다.    
[그림 9-21](#그림-9-21-벡터-내적의-투영-공식으로-구한-벡터-v)에서 보여지는 공간의 원점에서 회전 평면의 원점으로 향하는 벡터 $\vec{v}$는 다음과 같이 계산된다.

$$\vec{OO'} = \vec{v} = (\vec{u} \cdot \hat{n}) \cdot \hat{n}$$

###### 그림 9-21 벡터 내적의 투영 공식으로 구한 벡터 v
![벡터 내적의 투영 공식으로 구한 벡터 v](/img/)

회전 평면의 중점 $O'$에서 점 $P$으로 향하는 벡터 $\vec{O'P}$는 두 벡터의 차가 되므로 $\vec{u} - \vec{v}$가 된다.

$$\vec{O'P} = \vec{u} - \vec{v}$$

위에서 내려다본 회전 평면의 모습은 [그림 9-22](#그림-9-22-회전-평면에서의-회전)와 같다.  
이 평면의 벡터 $\vec{O'P}$를 각 $\theta$만큼 회전 시킨 벡터 $\vec{O'P'}$를 구해야 한다.

###### 그림 9-22 회전 평면에서의 회전
![회전 평면에서의 회전](/img/)

벡터 $\vec{O'P'}$를 가로 성분과 세로 성분으로 분리하면, 가로 성분에 해당하는 벡터는 [그림 9-23](#그림-9-23-회전한-점-p를-구하기-위한-가로-벡터의-계산)과 같이 벡터 $\vec{O'P}$에 $\cos \theta$를 곱해 얻을 수 있다.

###### 그림 9-23 회전한 점 P'를 구하기 위한 가로 벡터의 계산
![회전한 점 P'를 구하기 위한 가로 벡터의 계산](/img/)

세로 성분에 해당하는 벡터를 구하려면 같은 방향을 향하는 벡터가 필요한데 이는 [그림 9-24](#그림-9-24-벡터-op에-직교하는-벡터-oq)와 같이 법선 벡터 $\hat{n}$과 벡터 $\vec{O'P}$를 외적해 얻을 수 있다.   
이를 벡터 $\vec{O'Q}$로 지정한다면 벡터 $\vec{O'Q}$는 다음과 같이 구할 수 있다.

$$\vec{O'Q} = \hat{n} \times (\vec{u} - \vec{v})$$

###### 그림 9-24 벡터 O'P에 직교하는 벡터 O'Q
![벡터 O'P에 직교하는 벡터 O'Q](/img/)

벡터 $\vec{O'Q}$에 $\sin \theta$를 곱하면 세로 성분에 해당하는 벡터를 얻을 수 있다.     
두 벡터를 모두 얻었으니 다음의 수식으로 벡터 $\vec{O'P}$를 각 $\theta$만큼 회전한 벡터 $\vec{O'P'}$의 값을 얻게 된다.

$$\vec{O'P'} = \cos \theta \cdot \vec{O'P} + \sin \theta \cdot \vec{O'Q}$$

위 식을 벡터 $\hat{n}$, $\vec{u}$와 $\vec{v}$를 사용해 전개하면 다음과 같다.

$$\vec{O'P'}  = \cos \theta \cdot (\vec{u} - \vec{v}) + \sin \theta \cdot (\hat{n} \times (\vec{u} - \vec{v}))$$

분배 법칙을 적용해 이를 풀어 전개하면 다음과 같다.

$$\vec{O'P'} = \cos \theta \cdot (\vec{u} - \vec{v}) + \sin \theta \cdot (\hat{n} \times \vec{u} - \hat{n} \times \vec{v})$$

벡터 $\hat{n}$과 $\vec{v}$는 평행하므로 우변의 끝에 위치한 외적 $\hat{n} \times \vec{v}$의 값은 항상 영벡터가 된다.     
따라서 이 식은 다음과 같이 정리된다.

$$\vec{O'P'} = \cos \theta \cdot (\vec{u} - \vec{v}) + \sin \theta \cdot (\hat{n} \times \vec{u})$$

마지막으로 구해야할 최종 벡터 $\vec{OP'}$는 [그림 9-25](#그림-9-25-최종-벡터-op의-계산)와 같이 선분 $\vec{O'P'}$에 벡터 $\vec{v}$를 더해 얻을 수 있다.

###### 그림 9-25 최종 벡터 OP'의 계산
![최종 벡터 OP'의 계산](/img/)

이를 식으로 나타내면 다음과 같다.

$$\vec{OP'} = \vec{v} + \cos \theta \cdot (\vec{u} - \vec{v}) + \sin \theta \cdot (\hat{n} \times \vec{u})$$

이제 벡터 $\vec{v}$를 $(\vec{u} \cdot \hat{n}) \cdot \hat{n}$로 치환하면 [식 9-2](#식-9-2)의 최종 수식이 유도된다.

$$\vec{u'} = \cos \theta \cdot \vec{u} + (1 - \cos \theta)(\vec{u} \cdot \hat{n}) \cdot \hat{n} + \sin \theta \cdot (\hat{n} \times \vec{u})$$

위 공식은 1840년에 프랑스 수학자 로드리게스(Olinde Rodrigues)가 발표했으며, 그의 이름을 인용해 ***로드리게스 회전 공식(Rodrigues' rotation formula)*** 이라고 한다.

# 33. 삼중곱
벡터의 외적과 내적을 두 번 연속 사용하는 연산을 ***삼중곱(Triple product)*** 이라고 한다.  
두 연산이 연속으로 사용되는 삼중곱의 식을 세우려면 세 개의 벡터 $\vec{u}$, $\vec{v}$, $\vec{w}$가 필요하며, 내적과 외적의 순서에 따라 다음과 같은 경우의 수가 발생한다.

1. $\vec{u} \cdot (\vec{v} \cdot \vec{w})$
2. $\vec{u} \cdot (\vec{v} \times \vec{w})$
3. $\vec{u} \times (\vec{v} \cdot \vec{w})$
4. $\vec{u} \times (\vec{v} \times \vec{w})$

1번 연산에서 괄호 안의 벡터 내적의 결괏값은 스칼라가 되므로 해당 삼중곱은 벡터를 세 번 곱했다고 보기 어렵다.    
3번 연산의 경우 벡터와 스칼라는 외적할 수 없으므로 연산이 불가능하다.   
이 두 경우는 제외되므로 2번과 4번만이 유효한 삼중곱 연산이 된다.

# 33.1. 스칼라 삼중곱
2번 삼중곱 연산($\vec{u} \cdot (\vec{v} \times \vec{w})$)은 4번 삼중곱 연산($\vec{u} \times (\vec{v} \times \vec{w})$)과 구분하기 위해 별도로 ***스칼라 삼중곱(Scalar triple product)*** 이라고 부른다.    
***왼쪽과 오른쪽의 판별 방법과 백페이스 컬링에 사용한 공식이 모두 스칼라 삼중곱이다***.

$$\hat{y} \cdot (\vec{f} \times \vec{v})$$

$$-\hat{z} \cdot (\vec{P_0P_1} \times \vec{P_0P_2})$$

외적으로 만든 벡터의 크기는 두 벡터가 이루는 평행사변형의 크기임과 동시에 외적으로 만들어진 법선 벡터의 크기다.     
이를 표현하면 [그림 9-26](#그림-9-26-외적의-크기)과 같다.

###### 그림 9-26 외적의 크기
![외적의 크기](/img/)

이 상황에서 임의의 벡터 $\vec{u}$의 크기를 법선 벡터 $\vec{v} \times \vec{w}$에 수직으로 투영한 벡터의 높이는 [그림 9-27](#그림-9-27-법선-벡터에-투영한-벡터의-크기)처럼 $\cos$ 함수에 비례한다.

###### 그림 9-27 법선 벡터에 투영한 벡터의 크기
![법선 벡터에 투영한 벡터의 크기](/img/)

높이 $|\vec{u}|\cos \theta$에 평행사변형의 넓이 $|\vec{v} \times \vec{w}|$를 곱하면 [그림 9-28](#그림-9-28-육면체의-부피)에서 볼 수 있는 육면체의 부피가 나온다.

###### 그림 9-28 육면체의 부피
![육면체의 부피](/img/)

이는 ***스칼라 삼중곱이 만들어내는 값의 절댓값과 동일***하다.

$$|\vec{u}||\vec{v} \times \vec{w}|\cos\theta = |\vec{u} \cdot (\vec{v} \times \vec{w})|$$

따라서 스칼라 삼중곱의 절댓값은 세 벡터 $\vec{u}$, $\vec{v}$, $\vec{w}$가 만드는 ***평행육면체(Parallelepiped)*** 의 부피를 의미하며, 이러한 평행육면체는 [그림 9-29](#그림-9-29-세-벡터로-구성된-평행육면체)의 형태를 이룬다.

###### 그림 9-29 세 벡터로 구성된 평행육면체
![세 벡터로 구성된 평행육면체](/img/)

위 세 벡터에서 ***바닥에 해당하는 두 벡터를 다른 벡터로 변경해도 최종 육면체의 부피 값은 변하지 않으므로 삼중곱의 결과는 동일***하다.     
이는 [그림 9-30](#그림-9-30-순서를-바꿔도-결과는-같은-스칼라-삼중곱의-예시)과 같이 표현할 수 있다.

###### 그림 9-30 순서를 바꿔도 결과는 같은 스칼라 삼중곱의 예시
![순서를 바꿔도 결과는 같은 스칼라 삼중곱의 예시](/img/)

부호에 유의해 벡터 $\vec{u}$, $\vec{v}$, $\vec{w}$가 만들어내는 스칼라 삼중곱은 다음과 같은 성질을 가진다.

$$\vec{u} \cdot (\vec{v} \times \vec{w}) = \vec{v} \cdot (\vec{w} \times \vec{u}) = \vec{w} \cdot (\vec{u} \times \vec{v})$$

이러한 성질을 가진 ***스칼라 삼중곱은 세 벡터의 선형 관계를 파악하는 데 사용***된다.

***외적으로 생성된 벡터의 크기는 두 벡터가 만드는 평행 사변형의 넓이와 동일함***을 알 수 있고, 이는 ***행렬식의 절댓값과 동일***하다.   
***행렬식은 평면에서 평행사변형을 이루는 두 벡터가 서로 선형 독립의 관계를 가지는지 판단하는 수식***이다.     
이와 동일한 관점에서 ***스칼라 삼중곱은 3차원 공간의 세 벡터가 모두 선형 독립의 관계를 가지는지 판단하는 판별식***으로 생각할 수 있다.    
삼중곱의 값이 0이 나오는 경우는 (a)와 같이 평면을 이루는 두 벡터 $\vec{v}$와 $\vec{w}$가 평행이거나, (b)와 같이 두 벡터 $\vec{v}$와 $\vec{w}$가 만드는 평면에 벡터 $\vec{u}$가 속하는 경우다.

###### 그림 9-31 세 벡터가 모두 선형 독립이 아닌 경우
![세 벡터가 모두 선형 독립이 아닌 경우](/img/)

(a)의 경우 외적의 결과가 영벡터가 되므로 스칼라 삼중곱의 값은 0이 된다.     
(b)의 경우 외적의 결과로 만들어진 법선 벡터에 벡터 $\vec{u}$는 직교하므로 이의 내적은 0이 된다.     
따라서 ***스칼라 삼중곱이 0이 아니면 세 벡터는 모두 선형 독립의 관계를 가짐***을 알 수 있다.

# 33.2. 벡터 삼중곱
세 벡터의 외적으로 구성된 삼중곱 $\vec{u} \times (\vec{v} \times \vec{w})$을 ***벡터 삼중곱(Vector triple product)*** 이라고 한다.     
벡터 삼중곱은 다음과 같은 성질을 지닌다.

###### 식 9-3

$$\vec{u} \times (\vec{v} \times \vec{w}) = (\vec{u} \cdot \vec{w}) \cdot \vec{v} - (\vec{u} \cdot \vec{v}) \cdot \vec{w}$$

이를 ***삼중곱 전개(Triple product expansion)*** 또는 ***라그랑주 공식(Largrange's formula)*** 이라고 한다.      
좌변의 식 $\vec{u} \times (\vec{v} \times \vec{w})$의 최종 연산은 외적이므로 이의 결과는 벡터로 나옴을 알 수 있다.      
이때 최종 벡터의 $x$ 성분만 먼저 전개한다.      
먼저 $\vec{v} \times \vec{w}$의 외적을 계산하는 식은 다음과 같다.

$$\vec{v} \times \vec{w} = (v_yw_z - w_yv_z, v_zw_x - w_zv_x, v_xw_y - w_xv_y)$$

여기서 외적의 $x$ 요소에는 $\vec{u}$ 벡터와 $(\vec{v} \times \vec{w})$ 벡터의 $y$ 성분과 $z$ 성분만 사용된다.   
$\vec{u} \times (\vec{v} \times \vec{w})$로 만들어지는 $x$ 성분을 전개한다.     
이는 $v_x(\vec{u} \cdot \vec{w}) - w_x(\vec{u} \cdot \vec{v})$의 내적식으로 간단하게 정리된다.

$$
\begin{matrix}
(\vec{u} \times (\vec{v} \times \vec{w}))_x &=& u_y(v_xw_y - w_xv_y) - (v_zw_x - w_zv_x)u_z \\
&=& v_x(u_yw_y + u_zw_z) - w_x(u_yv_y + u_zv_z) \\
&=& v_x(u_yw_y + u_zw_z) - w_x(u_yv_y + u_zv_z) + v_xu_xw_x - v_xu_xw_x \\
&=& v_x(u_xw_x + u_yw_y + u_zw_z) - w_x(u_xv_x + u_yv_y + u_zv_z) \\
&=& v_x(\vec{u} \cdot \vec{w}) - w_x(\vec{u} \cdot \vec{v}) \\
\end{matrix}
$$

0의 값을 가지는 수식 $+ v_xu_xw_x - v_xu_xw_x$을 추가한다.

나머지 두 개의 성분도 동일한 방식으로 전개할 수 있으며, 이 결과를 정리하면 다음과 같다.

$$(\vec{u} \times (\vec{v} \times \vec{w}))_y = v_y(\vec{u} \cdot \vec{w}) - w_y(\vec{u} \cdot \vec{v})$$

$$(\vec{u} \times (\vec{v} \times \vec{w}))_z = v_z(\vec{u} \cdot \vec{w}) - w_z(\vec{u} \cdot \vec{v})$$

위 결과를 종합하면 [식 9-3](#식-9-3)이 유도됨을 확인할 수 있다.     
***벡터 삼중곱은 다소 복잡한 외적을 두 개의 내적 연산으로 변환한다***는 특징을 지닌다.    
이 식의 우변은 결국 $a\vec{v} + b\vec{w}$ 형태의 ***선형 결합식***이므로 ***벡터 삼중곱으로 만들어지는 벡터***는 두 벡터 $\vec{v}$와 $\vec{w}$가 만드는 ***평면에 속함***을 알 수 있다.

###### 그림 9-32 벡터 삼중곱으로 만들어진 벡터의 결과
![벡터 삼중곱으로 만들어진 벡터의 결과](/img/)

> 참고  
3차원 공간의 연산 외적이 사용되는 벡터 삼중곱은 2차원 공간의 문제를 푸는 데도 유용하게 활용할 수 있다.      
2차원 평면의 벡터 $\vec{u}$와 동일한 평면에 위치한 임의의 벡터 $\vec{v}$가 주어졌을 때, 동일 평면에서 벡터 $\vec{u}$와 직교하는 벡터는 $(\vec{u} \times \vec{v}) \times \vec{u}$의 벡터 삼중곱을 사용해 구할 수 있다.
>
> ###### 그림 9-33 2차원 평면 위의 직교 벡터를 생성해주는 벡터 삼중곱 연산
> ![2차원 평면 위의 직교 벡터를 생성해주는 벡터 삼중곱 연산](/img/)

# 34. 원근 투영 변환의 원리
원근 기법은 르네상스 시대의 화가들에 의해 창안되었다.   
당시 르네상스 화가들은 눈에 보이는 상을 그대로 화폭에 담기 위해 [그림 10-1](#그림-10-1-알브레히트-뒤러의-틀과-실을-이용하여-단축법의-원리를-연구하는-화가)과 같이 시선을 한 점에 고정시키고, 고정된 점으로부터 화폭까지 곧게 뻗은 실을 활용해 그림을 그렸다.   
이러한 화법을 ***투시 원근법(Perpective projection drawing)*** 이라고 한다.

###### 그림 10-1 알브레히트 뒤러의 <틀과 실을 이용하여 단축법의 원리를 연구하는 화가>
![알브레히트 뒤러의 <틀과 실을 이용하여 단축법의 원리를 연구하는 화가>](/img/)

3차원 공간에 투시 원근법의 원리를 적용하기 위해서는, [그림 10-1](#그림-10-1-알브레히트-뒤러의-틀과-실을-이용하여-단축법의-원리를-연구하는-화가)과 같은 원리로 ***공간의 모든 점이 한 점을 향해 모이는 형태***로 변경해야 한다.    
이러한 변환을 ***원근 투영 변환(Perpective projection transformation)*** 이라고 부른다.

원근 투영 변환이란 사람의 눈이 바라보는 방식으로 가상 공간을 변환하는 것이다.   
가상 공간에서 눈에 대응하는 물체는 카메라다.    
원근 투영 변환을 설계하기 위해서는 ***눈에 보이는 범위*** 를 카메라에도 설정해야 하는데, 이를 ***화각(Field of view)*** 라고 한다.    
카메라에 화각을 설정하면 [그림 10-2](#그림-10-2-카메라-화각에-따라-변화된-공간의-모습)와 같이 ***좌우와 위아래가 균등한 사각뿔 영역***이 만들어진다.

###### 그림 10-2 카메라 화각에 따라 변화된 공간의 모습
![카메라 화각에 따라 변화된 공간의 모습](/img/)

원근 투영 변환은 $x$, $y$, $z$축이 모두 직교하는 ***정육면체 형태를 가진 뷰 공간***을 ***카메라의 한 점으로 모이는 사각뿔 형태를 가진 공간으로 변환하는 작업***이라고 할 수 있다.       
3차원 공간을 변환한 후에는 공간의 물체를 투영해 2차원의 모니터 평면에 담아내야 한다.    
이를 위해서 ***모든 물체의 상이 맺히는 가상의 평면***을 생성해야 하는데, 이를 ***투영 평면(Projection plane)*** 이라고 부른다.   
투영 평면의 개념은 [그림 10-3](#그림-10-3-투영-평면과-초점-거리)과 같으며 ***투영 평면의 위치가 카메라로부터 멀어질수록 투영 평면은 더 커진다***.   
투영 평면의 위치를 지정하기 위해 설정한 ***카메라로부터 투영 평면까지의 거리***를 ***초점 거리(Focal length)*** 라고 한다.

###### 그림 10-3 투영 평면과 초점 거리
![투영 평면과 초점 거리](/img/)

[그림 10-4](#그림-10-4-오른쪽에서-바라본-투영-공간과-투영-평면)에 투영 공간을 오른쪽에서 바라본 2차원 단면도로 정리하고 화각을 $\theta$, 초점 거리를 $d$로 표시했다.

###### 그림 10-4 오른쪽에서 바라본 투영 공간과 투영 평면
![오른쪽에서 바라본 투영 공간과 투영 평면](/img/)

원근 투영을 구현하기 위해서는 우선 투영 평면의 위치를 지정해야 한다.    
일반적으로 투영 평면의 위치는 계산의 편의를 위해 위 아래의 크기가 각각 1이 되는 지점으로 결정한다.      
좌우와 상하의 화각이 동일하므로 투영 평면은 [그림 10-5](#그림-10-5-투영-평면으로-생성되는-ndc-영역)와 같이 좌우와 상하가 되는 각각 $|-1, 1|$의 범위를 가지는 정사각형의 모습을 띠며 이 평면에 물체의 상이 맺힌다.   
투영 평면에 대응하는 정사각형 영역은 2차원 평면의 좌표시스템을 가지는데 이를 ***NDC(Normalized device coordinate)*** 라고 부르는데, ***NDC는 가운데 중점을 원점으로 설정한다***.

###### 그림 10-5 투영 평면으로 생성되는 NDC 영역
![투영 평면으로 생성되는 NDC 영역](/img/)

투영 평면에 대응하는 NDC가 언제나 일정한 값을 가져야 한다면, 카메라에 설정된 화각이 변할 때, 초점 거리는 달라질 수밖에 없다.    
***화각이 커질수록 초점 거리는 가까워지고 화각이 작아질수록 초점 거리는 멀어진다***.      
화각과 초점 거리의 관계는 [그림 10-6](#그림-10-6-화각과-초점거리의-관계)에 보이는 직각삼각형의 $\tan$ 함수로 설정된다.

$$\tan(\frac{\theta}{2}) = \frac{1}{d}$$

###### 그림 10-6 화각과 초점거리의 관계
![화각과 초점거리의 관계](/img/)

따라서 주어진 화각 $\theta$에 따른 초점 거리 $d$는 다음 식으로 계산할 수 있다.

###### 식 10-1

$$d = \frac{1}{\tan(\frac{\theta}{2})}$$

$\tan$ 함수를 사용해 초점 거리를 구했다면, ***뷰 공간의 점을 투영 평면 위의 점으로 대응시키는 원근 투영 변환***을 설계한다.  
행렬로 설계할 수 있다면 행렬 곱의 장점을 활용해 로컬 공간의 점을 투영 평면의 점으로 한 번에 변환해주는 파이프라인을 만들 수 있다.

***세 축이 모두 직교하는 공간***을 ***유클리드 공간(Euclidean space)*** 이라고 한다.     
***로컬 공간, 월드 공간, 뷰 공간***은 모두 유클리드 공간의 형태다.    
정육면체 형태의 유클리드 공간은 원근 투영 변환에 의해 [그림 10-2](#그림-10-2-카메라-화각에-따라-변화된-공간의-모습)와 같은 사각뿔 형태로 바뀌게 된다.   
이를 ***사영 공간(Projective space)*** 이라고 한다.

사영 공간의 $x$축과 $y$축은 여전히 직교하기 때문에 사영 공간의 $x$축과 $y$축은 유클리드 공간과 동일한 성질을 가진다.    
하지만 사영 공간의 $z$축은 독립적으로 행동하지 않고 $x$축과 $y$축에 모두 영향을 준다.   
이는 초점 거리에 따라 $x$축과 $y$축이 만들어내는 투영 평면의 면적이 달라지는 이유이기도 하다.

유클리드 공간이 사영 공간으로 변환되면서 $x$, $y$, $z$축이 모두 직교하는 체계가 달라지기 때문에 ***원근 투영 변환에 대응하는 행렬은 지금까지 사용한 표준기저벡터의 변화를 관찰하는 방법으로는 생성할 수 없다***.      
문제를 단순화시키기 위해 $x$축을 배제한 $y$축과 $z$축으로 공간을 설정하고 투영 평면에 상이 맺히는 과정을 생각해보면, 뷰 공간의 점 $P_{view}$가 투영 평면에 투영된 점을 $P_{ndc}$라고 할 때 투영 과정은 [그림 10-7](#그림-10-7-투영의-진행-과정)과 같이 진행된다.

###### 그림 10-7 투영의 진행 과정
![투영의 진행 과정](/img/)

뷰 공간의 점 $P_{view}$로부터 투영된 점 $P_{ndc}$의 좌표를 구해야 한다.     
$x$값을 0으로 고정한 상태이므로, 둘의 좌표는 다음과 같다.

$$P_{view} = (0, v_y, v_z)$$

$$P_{ndc} = (0, n_y)$$

두 점의 관계를 파악하기 위해 [그림 10-8](#그림-10-8-두-개의-닮은꼴-삼각형)과 같이 닮은꼴 삼각형 두 개를 그린다.   
뷰 공간에서 카메라 앞에 위치한 점의 $z$값은 항상 음수이므로 큰 삼각형의 밑변의 길이는 $-v_z$가 된다.

###### 그림 10-8 두 개의 닮은꼴 삼각형
![두 개의 닮은꼴 삼각형](/img/)

두 삼각형의 닮은꼴 성질로부터 다음의 비가 성립된다.

$$n_y:d = v_y:-v_z$$

이로써 투영 평면의 $y$값 $n_y$은 다음 식으로 얻을 수 있다.

$$n_y = \frac{d \cdot v_y}{-v_z}$$

카메라의 좌우와 상하의 시야각은 동일하므로 $NDC$의 $x$값 또한 $y$값을 0으로 고정한 후 $x$축과 $z$축의 평면을 사용하는 방식으로 구할 수 있다.

$$n_x = \frac{d \cdot v_x}{-v_z}$$

따라서 초점거리와 뷰 좌표로부터 $P_{ndc}$는 다음과 같이 구할 수 있다.

$$P_{ndc} = (n_x, n_y) = (\frac{d \cdot v_x}{-v_z}, \frac{d \cdot v_y}{-v_z}) = -\frac{d}{v_z}(v_x, v_y)$$

NDC 좌표를 계산했다면 모니터의 최종 화면을 구성하는 작업이 남았다.    
[그림 10-9](#그림-10-9-ndc에서-화면-공간으로의-변환)와 같이 NDC 좌표를 화면 해상도만큼 가로와 세로를 늘려주면 최종 스크린 좌표가 완성된다.   

###### 그림 10-9 NDC에서 화면 공간으로의 변환
![NDC에서 화면 공간으로의 변환](/img/)

[그림 10-9](#그림-10-9-ndc에서-화면-공간으로의-변환)와 같은 방법으로 가로와 세로를 늘리면 물체가 찌그러지는 문제가 발생한다.     
대부분의 경우 최종 화면의 크기 비율이 1:1로 균등하지 않기 때문이다.     
예를 들어 [그림 10-10](#그림-10-10-종횡비를-고려하지-않고-확대하는-경우-발생하는-문제)과 같이 NDC 영역에 원의 상이 투영됐는데, 화면 해상도에 따라 가로와 세로를 다른 비율로 늘리면 사용자가 보는 최종 화면에서는 찌그러진 타원이 보이게 된다.

###### 그림 10-10 종횡비를 고려하지 않고 확대하는 경우 발생하는 문제
![종횡비를 고려하지 않고 확대하는 경우 발생하는 문제](/img/)

문제의 원인이 되는 ***화면의 가로 세로 비***를 ***종횡비(Aspect ratio)*** 라고 한다.     
모니터 화면은 보통 16:10이나 4:3처럼 가로 세로 비율이 다르다.

이 문제를 해결하는 방법은 화면의 종횡비를 미리 파악해, NDC 영역에서 미리 찌그러트린 후에 펼치는 것이다.     
[그림 10-11](#그림-10-11-종횡비를-고려해-처리하는-방법의-예시)의 (a)와 같이 NDC에 원을 투영할 때 종횡비를 거꾸로 뒤집은 비율을 적용해 먼저 찌그러트린다.      
그러면 (b)와 같이 사용자 화면에 펼칠 때 원이 올바르게 보인다.

###### 그림 10-11 종횡비를 고려해 처리하는 방법의 예시
![종횡비를 고려해 처리하는 방법의 예시](/img/)

종횡비는 보통 하나의 축을 1의 크기로 지정하고 다른 축의 크기를 상대적으로 측정해 나타낸다.      

NDC의 투영 결과를 찌그러트린다.     
좌우로 찌그러트리려면 $x$축 값을 변경해야 하는데, 이는 종횡비의 역수$\frac{1}{a}$을 곱하면 된다.    
따라서 NDC 좌표 $P_{ndc}$를 계산하는 공식은 다음과 같이 수정된다.

$$P_{ndc} = -\frac{d}{v_z}(\frac{v_x}{a}, v_y)$$

따라서 최종 NDC 값을 계산하는 원근 투영 행렬 $P$는 다음과 같이 설계할 수 있다.      
뷰 공간의 점 $P_{view}$의 $x$값과 $y$값으로 만든 벡터를 $\vec{v} = (v_x, v_y)$로 지정하면 $P_{ndc}$의 두 점의 좌표는 다음과 같이 계산할 수 있다.

$$P_{ndc} = P \cdot \vec{v} = 
\begin{bmatrix}
\frac{1}{a} \cdot \frac{d}{-v_z} & 0 \\
0 & \frac{d}{-v_z} \\
\end{bmatrix} \cdot 
\begin{bmatrix}
v_x \\
v_y \\
\end{bmatrix}
$$

이렇게 만들어진 원근 투영 행렬을 사용한다고 할 때, 변환할 점의 $z$값이 행렬에 사용되다 보니 ***변환할 점마다 항상 행렬을 새롭게 생성***해야 한다.

***행렬의 가장 큰 장점은 모든 변환의 행렬을 미리 곱해둔 행렬을 적용함으로써 반복되는 연산량을 줄이는 것이다***.   
하지만 이렇게 원근 투영 행렬에 변환할 점의 값이 사용되면 행렬을 사용하는 장점이 사라진다.   
따라서 원근 투영 행렬을 구성할 때 점의 값을 사용하지 않고 카메라 설정만으로 행렬을 만들 수 있어야 한다.

유도한 투영 행렬을 살펴보면, 행렬의 구성 요소는 모두 $-v_z$값을 분모로 한다.    
행렬에서 $-v_z$값을 제거하고, 대신 행렬의 결괏값에서 $-v_z$를 나누어줄 수 있다.

NDC값을 만들어내는 과정을 두 단계로 분리한다.   
첫 번째로는 앞서 설계한 원근 투영 행렬 $P$를 다음과 같이 변경하고 행렬에 곱하는 벡터의 값을 $\vec{v} = (v_x, v_y, v_z)$로 지정한다.     
벡터 $\vec{v}$는 뷰 좌표계의 점과 동일한 값을 가진다.

$$P \cdot \vec{v} = 
\begin{bmatrix}
\frac{d}{a} & 0 & 0 \\
0 & d & 0 \\
0 & 0 & 1 \\
\end{bmatrix}
\begin{bmatrix}
v_x \\
v_y \\
v_z \\
\end{bmatrix} = 
\begin{bmatrix}
\frac{d}{a} \cdot v_x \\
d \cdot v_y \\
-v_z \\
\end{bmatrix}
$$

이 행렬 곱에서 생성된 벡터는 얻어야 할 NDC 좌표와는 다르지만 원근 투영 행렬 $P$는 점과 무관하게 카메라 설정 값으로만 구성된다.      
그렇다면 모든 점에 대해서 보편적으로 설계된 원근 투영 행렬 $P$를 사용할 수 있다.    
이렇게 원근 투영 행렬 $P$로 변환되는 좌표계를 ***클립 좌표(Clip coordinate)*** 라고 부르며 클립 좌표의 점 $P_{clip}$은 다음과 같이 계산된다.

$$P_{clip} = (\frac{d \cdot v_x}{a}, d \cdot v_y, -v_z)$$

두 번째로는 클립 좌표의 점 $P_{clip}$의 각 요소를 $P_{clip}$의 세 번째 값인 $-v_z$로 나눈다.    
그러면 NDC의 좌표를 얻을 수 있다.

$$P_{ndc} = (\frac{d \cdot v_x}{-v_z \cdot a}, \frac{d \cdot v_y}{-v_z}, 1)$$

# 35. 동차 좌표계
***NDC는 2차원 평면의 좌표***지만, ***모든 점에 사용 가능한 원근 투영 행렬을 사용***하도록 ***계산 과정을 두 단계로 구분***하고, ***사용하는 벡터의 값도 한 차원 높다***.    
이렇게 한 차원 높인 벡터를 사용하는 것을 게임 제작에서는 보통 ***동차 좌표계(Homogenous coordinate system)*** 를 사용한다고 표현한다.      
***동차 좌표계의 동차는 모든 항의 차수가 같음의 의미***하는 수학 용어다.  

[그림 10-12](#그림-10-12-사영-공간에서-점이-평행-이동할-때-투영된-점의-변화)와 같이 형성된 3차원의 사영 공간에서 평행하게 점을 이동시키면서 평면에 투영된 좌푯값이 어떻게 바뀌는지 관찰할 수 있다.    
사영 공간의 점과 투영된 점의 좌표는 카메라로부터 멀어질수록 원점에 가까워지고, 카메라에 가까워질수록 커지는 ***반비례 관계***를 가진다.

###### 그림 10-12 사영 공간에서 점이 평행 이동할 때 투영된 점의 변화
![사영 공간에서 점이 평행 이동할 때 투영된 점의 변화](/img/)

3차원 사영 공간의 점을 $(x', y', z')$로 표기하고 해당 점이 투영된 NDC 좌표를 $(x, y)$로 표기한다.   
NDC 좌푯값은 사영 공간의 마지막 차원 값 $z'$에 반비례로 영향을 받으므로 다음과 같은 관계가 성립한다.

###### 식 10-2

$$x = \frac{x'}{z'} \quad y = \frac{y'}{z'}$$

NDC 공간에서 [그림 10-13](#그림-10-13-ndc-좌표에서의-직선-방정식)과 같은 직선의 방정식 $y = ax + b$를 생각해보며, 화면에 보이는 NDC 공간의 직선이 사영 공간의 점들이 투영되어 만들어졌다고 가정한다.

###### 그림 10-13 NDC 좌표에서의 직선 방정식
![NDC 좌표에서의 직선 방정식](/img/)

직선의 방정식을 사영 공간의 좌표로 표현한다.    
[식 10-2](#식-10-2)를 참고해 $x$와 $y$를 치환하면 사영 공간의 좌표로 표기한 직선의 방정식은 다음과 같다.

$$\frac{y'}{z'} = a\frac{x'}{z'} + b$$

이 식의 양번에 $z'$를 곱하면 상수가 사라지고 세 미지수의 차수가 모두 1차식으로 동일한 수식이 구성된다.

$$y' = ax' + bz'$$

이렇게 ***미지수에 대한 차수가 모두 동일한 방정식***을 ***동차 방정식***이라고 부르며, 이런 이유로 ***사영 공간이 사용하는 좌표계를 동차좌표계라고도 부른다***.   
원근 투영 행렬 $P$를 설계하기 위해 계산 과정을 두 단계로 나눠 진행했는데, 첫 번째 단계로 구한 좌표를 클립 좌표라고 부르며 이는 투영 되기 전의 사영 공간의 좌표를 의미한다.      
따라서 원근 투영 변환에서 등장한 ***사영 공간, 클립 공간, 동차 공간은 모두 동일한 공간***을 가리키고, 클립 좌표, 동차 좌표 역시 동일한 좌표계를 가리킨다.

[그림 10-12](#그림-10-12-사영-공간에서-점이-평행-이동할-때-투영된-점의-변화)를 다시 살펴보면, 사영 공간의 점이 카메라로부터 멀어질수록 투영된 NDC 좌푯값은 원점 $(0, 0)$에 가까워진다.      
NDC의 원점은 회화의 투시 원근 기법에서 이야기하는 ***소실점(Vanishing point)*** 에 해당한다.   

###### 그림 10-14 마인데르트 호베마의 <미델 하르니스의 가로수길>
![마인데르트 호베마의 <미델 하르니스의 가로수길>](/img/)

# 36. 깊이 값
원근 투영 행렬을 활용해 3차원의 물체를 원근감 있게 표현할 수 있다.  
그러나 물체에 텍스쳐를 입힌다면 추가로 고려할 사항이 발생한다.  
사용자에게 보이는 화면은 결국 2차원 평면이므로 나중에 그린 물체가 앞에 보일 수밖에 없다.    

이 문제를 해결하는 방법은, 물체가 카메라로부터 얼마나 떨어져 있는지에 대한 정보를 기록해 앞에 있는 물체를 나중에 그리도록 설정하는 것이다.  
이를 위해서는 ***카메라로부터 물체가 얼마나 떨어졌는지 파악할 수 있는 데이터***가 필요한데 이를 ***깊이(Depth)*** 값이라고 한다.    
2차원 평면이었던 NDC 영역에 깊이 값을 추가하면 [그림 10-15](#그림-10-15-3차원으로-확장된-ndc-영역)과 같은 3차원으로 NDC 영역이 확장된다.   
깊이 값의 범위는 동일하게 $|-1, 1|$로 설정했다.

###### 그림 10-15 3차원으로 확장된 NDC 영역
![3차원으로 확장된 NDC 영역](/img/)

***카메라에 부여한 시야각은 깊이와 무관***하기 때문에 카메라에 추가 속성을 부여해야 한다.     
이를 각각 ***근평면(Near plane)*** 과 ***원평면(Far plane)*** 이라고 한다.

카메라 시야를 구성하는 사영 공간을 근평면과 원평면으로 잘라주면 [그림 10-16](#그림-10-16-카메라에-설정한-절두체)과 같이 사각뿔에서 뾰족한 부분이 잘린 형태가 나오는데 이를 ***절두체(Frustum)*** 라고 한다.

###### 그림 10-16 카메라에 설정한 절두체
![카메라에 설정한 절두체](/img/)

절두체로 생성되는 3차원 NDC 영역의 범위는 [그림 10-17](#그림-10-17-3차원으로-확장한-ndc의-범위)과 같이 구성된다.     
NDC의 깊이 값은 멀어질수록 증가하기 때문에 ***3차원 NDC 공간은 왼손 좌표계를 형성***한다.

###### 그림 10-17 3차원으로 확장한 NDC의 범위
![3차원으로 확장한 NDC의 범위](/img/)

원근 투영 행렬은 다른 행렬과의 곱을 위해 $3 \times 3$ 크기의 행렬을 인위적으로 $4 \times 4$ 크기로 늘렸는데, 이제는 깊이 값을 계산할 수 있도록 모든 행렬을 알차게 활용할 수 있게 되었다.

기존 원근 투영 행렬의 3행을 4행으로 옮기고 3행은 깊이 값을 구하는 용도로 변경한다.  
뷰 공간의 점을 나타내는 $\vec{v}$의 값을 $(v_x, v_y, v_z, 1)$로 지정하면 원근 투영 행렬 $P$는 다음과 같이 구성된다.

$$P \cdot \vec{v} = 
\begin{bmatrix}
\frac{d}{a} & 0 & 0 & 0 \\
0 & d & 0 & 0 \\
i & j & k & l \\
0 & 0 & -1 & 0 \\
\end{bmatrix}
\begin{bmatrix}
v_x \\
v_y \\
v_z \\
1 \\
\end{bmatrix} =
\begin{bmatrix}
\frac{d}{a} \cdot v_x \\
d \cdot v_y \\
? \\
-v_z \\
\end{bmatrix}
$$

깊이 값을 계산하는 데 사용하는 3행은 네 개의 미지수 $i, j, k, l$로 지정한다.    
깊이 값은 뷰 좌표계의 $x$축과 $y$축에 각각 직교하므로 영향을 받지 않는다.   
그러므로 앞의 두 요소 $i$와 $j$값은 0으로 설정해야 한다.    
이제 3행에는 두 개의 미지수 $k$와 $l$이 남는데, 이를 구하기 위해서는 두 개의 샘플 데이터가 필요하다.

$$P \cdot \vec{v} =
\begin{bmatrix}
\frac{d}{a} & 0 & 0 & 0 \\
0 & d & 0 & 0 \\
0 & 0 & k & l \\
0 & 0 & -1 & 0 \\
\end{bmatrix}
\begin{bmatrix}
v_x \\
v_y \\
v_z \\
1 \\
\end{bmatrix} = 
\begin{bmatrix}
\frac{d}{a} \cdot v_x \\
d \cdot v_y \\
? \\
-v_z \\
\end{bmatrix}
$$

두 미지수를 얻기 위해 카메라에 설정된 근평면과 원평면의 값을 사용한다.      
카메라로부터 근평면까지의 거리를 $n$, 원평면까지의 거리를 $f$로 설정한다.   
카메라의 중심으로부터 시선 방향으로 $n$만큼 이동한 근평면 상에 위치한 점을 생각해보면, 뷰 공간에서 카메라 시선 방향은 $-z$축이므로 뷰 공간에서 이 점의 좌표는 $(0, 0, -n, 1)$이 된다.   
이는 깊이 값의 시작 지점이기 때문에 NDC 좌표 $(0, 0, -1)$에 대응한다.   
동일하게 뷰 공간의 원 평면상의 좌표는 $(0, 0, -f, 1)$인데, 이는 깊이 값의 끝지점이기 때문에 NDC 좌표 $(0, 0, 1)$에 대응한다.

***원근 투영 행렬에 뷰 공간의 점을 곱한 결과는 클립 좌표가 된다***.   
근평면의 점을 $P_1,$ 원평면의 점을 $P_2$라고 할 때 이들은 다음과 같이 계산된다.

$$P_1 = 
\begin{bmatrix}
\frac{d}{a} & 0 & 0 & 0 \\
0 & d & 0 & 0 \\
0 & 0 & k & l \\
0 & 0 & -1 & 0 \\
\end{bmatrix}
\begin{bmatrix}
0 \\
0 \\
-n \\
1 \\
\end{bmatrix} = 
\begin{bmatrix}
0 \\
0 \\
? \\
n \\
\end{bmatrix}
$$

$$P_2 = 
\begin{bmatrix}
\frac{d}{a} & 0 & 0 & 0 \\
0 & d & 0 & 0 \\
0 & 0 & k & l \\
0 & 0 & -1 & 0 \\
\end{bmatrix}
\begin{bmatrix}
0 \\
0 \\
-f \\
1 \\
\end{bmatrix} = 
\begin{bmatrix}
0 \\
0 \\
? \\
f \\
\end{bmatrix}
$$

원근 투영 행렬의 $k$와 $l$을 모르기 때문에 클립 좌표의 세 번째 요소를 계산할 수 없다.   
하지만 클립 좌표의 네 번째 요소로 모든 요소를 나눈 값은 NDC 좌표를 가리키고, NDC 좌표의 $z$값은 각각 -1과 1임을 알고 있다.  
따라서 근평면의 클립 좌표는 $(0, 0, -n, n)$이 되고, 원평면의 클립 좌표는 $(0, 0, f, f)$이 되어야 한다.  
[그림 10-18](#그림-10-18-뷰-공간의-좌표와-ndc-값의-비교)은 근평면과 원평면의 위치를 세 가지 좌표로 표현한 예시다.

###### 그림 10-18 뷰 공간의 좌표와 NDC 값의 비교
![뷰 공간의 좌표와 NDC 값의 비교](/img/)

따라서 다음 식을 얻을 수 있다.

$$P_1 = 
\begin{bmatrix}
\frac{d}{a} & 0 & 0 & 0 \\
0 & d & 0 & 0 \\
0 & 0 & k & l \\
0 & 0 & -1 & 0 \\
\end{bmatrix}
\begin{bmatrix}
0 \\
0 \\
-n \\
1 \\
\end{bmatrix} = 
\begin{bmatrix}
0 \\
0 \\
-n \\
n \\
\end{bmatrix}
$$

$$P_2 = 
\begin{bmatrix}
\frac{d}{a} & 0 & 0 & 0 \\
0 & d & 0 & 0 \\
0 & 0 & k & l \\
0 & 0 & -1 & 0 \\
\end{bmatrix}
\begin{bmatrix}
0 \\
0 \\
-f \\
1 \\
\end{bmatrix} = 
\begin{bmatrix}
0 \\
0 \\
f \\
f \\
\end{bmatrix}$$

두 행렬의 3행과 뷰 공간의 점을 내적하면 다음 두 식을 얻을 수 있다.

$$-kn + l = -n$$

$$-kf + l = f$$

$n$과 $f$는 카메라에 설정된 상수이므로 두 식을 서로 빼, $l$을 소거한 후 $k$값을 구하면 다음과 같다.

$$k = \frac{-(n + f)}{(-n + f)} = \frac{n + f}{n - f}$$

여기서 구한 $k$를 대입해 $l$을 계산한 결과는 다음과 같다.

$$l = \frac{2nf}{(n - f)}$$

깊이 값까지 산출해주는 최종 원근 투영 행렬 $P$는 다음과 같다.

$$P = 
\begin{bmatrix}
\frac{d}{a} & 0 & 0 & 0 \\
0 & d & 0 & 0 \\
0 & 0 & \frac{n + f}{n - f} & \frac{2nf}{n - f} \\
0 & 0 & -1 & 0 \\
\end{bmatrix}
$$

이렇게 유도된 원근 투영 행렬은 ***모든 구성 요소가 카메라의 설정 값만 사용***하기 때문에 ***모든 점에 사용되는 렌더링 파이프라인의 행렬로 활용***할 수 있다.

# 37. 원근 보정 매핑
기존의 방식으로 각 픽셀의 무게중심좌표를 구한 후, 이로부터 UV 값을 계산하고 이에 대응하는 텍스처의 색상을 가져와 텍스처 매핑을 구현할 경우, 평행하게 그려져야 할 텍스처가 처지거나 올라가는 문제가 발생한다.

[그림 10-19](#그림-10-19-시야각에-걸쳐-있는-두-점과-이를-투영한-결과)는 투영 전과 투영 후의 과정을 보여준다.     
투영하기 전 사영 공간의 두 점 $P_1$과 $P_2$가 카메라 시야각에 걸쳐 있다고 가정한다.     
이를 투영 평면에 투영한 점 $N_1$과 $N_2$의 NDC 좌표의 $x$값은 각각 -1과 1이 된다.   
카메라 정면에 위치한 사영 공간의 점 $P_3$를 투영한 NDC 좌표의 점 $N_3$는 투영 평면의 정 중앙에 위치한다.

###### 그림 10-19 시야각에 걸쳐 있는 두 점과 이를 투영한 결과
![시야각에 걸쳐 있는 두 점과 이를 투영한 결과](/img/)

NDC 공간에서 점 $N_1$과 $N_2$를 이어 선분을 생성했을 때 선분의 중앙에 위치한 중점 $N_3$의 무게중심좌표는 0.5가 된다.

[그림 10-20](#그림-10-20-뷰-공간의-선을-수평으로-조정해-측정한-결과)과 같이 사영 공간의 선분 $\overline{P_1P_2}$ 내에 위치한 점 $P_3$의 무게중심좌표를 구하면 이는 0.5보다 작은 값임을 알 수 있다.

###### 그림 10-20 뷰 공간의 선을 수평으로 조정해 측정한 결과
![뷰 공간의 선을 수평으로 조정해 측정한 결과](/img/)

***사영 공간의 무게중심좌표와 NDC에서의 무게중심좌표는 서로 다르다***는 사실을 확인할 수 있다.    
이로 인해 ***텍스처가 처지거나 올라가 붙게 된다***.   
사영 공간의 무게중심좌표와 NDC에서의 무게중심좌표가 서로 차이 나는 이유는 NDC 공간으로의 변환 과정에서 사영 공간의 마지막 요소 $w$의 값 $-v_z$를 나눴기 때문이다.   
이는 ***사영 공간과 NDC 공간 사이에 형성된 반비례 관계로부터 기인***한다.

***NDC에서의 변경된 무게중심좌표를 사용하는 대신 투영되기 전 사영 공간에서의 무게중심좌표를 사용해야 한다***.     
따라서 ***투영 과정을 거꾸로 추적해 NDC에서 구한 무게중심좌표로부터 사영 공간의 무게중심좌표를 계산해야 한다***.  
이렇게 투영 전의 무게중심좌표 값을 계산해 텍스처를 매핑하는 것을 ***투영 보정 보간(Perspective correction interpolation)*** 이라고 한다.

NDC의 무게중심좌표를 사영 공간의 무게중심좌표로 돌려주는 투영 보정 보간의 계산식을 유도하기 위해서는 [그림 10-21](#그림-10-21-y---1x의-그래프)에 보이는 반비례 함수 $y = -\frac{1}{x}$이 가진 성질을 활용할 수 있다.

###### 그림 10-21 y = -1/x의 그래프
![y = -1/x의 그래프](/img/)

$y = -\frac{1}{x}$ 함수에서 $x$축에 위치한 세 수 2, 4, 6이 대응된 $y$값은 각각 $-\frac{1}{2}$, $-\frac{1}{4}$, $-\frac{1}{6}$이다.  
$x$축에 위치한 세 수 중에서 가운데 위치한 4의 무게중심좌표 $a$는 다음 식에 의해 0.5가 된다.

$$4 = a \cdot 2 + (1 - a) \cdot 6$$

4에 대응하는 $y$값 $-\frac{1}{4}$의 무게중심좌표를 구한다.  
다음 식에 의해 해당 값의 무게중심좌표는 0.25다.

$$-\frac{1}{4} = a \cdot -\frac{1}{2} + (1 - a) \cdot -\frac{1}{6}$$

$y$축의 무게중심좌표 0.25로부터 $x$축의 무게중심좌표 0.5를 계산해주는 식을 찾을 수 있다면, 이를 응용해 사영 공간에서의 무게중심값을 계산할 수 있다.

$y$축에서의 무게중심좌표를 $q_1$과 $q_2$로 지정하고 이를 사용해 $y$축의 두 점 $y_1$과 $y_2$ 사이의 점 $y'$를 구하는 수식을 다음과 같이 정리한다.    
무게중심좌표의 정의에서 두 무게중심좌표의 함 $q_1 + q_2$의 값은 1이다.

###### 식 10-3

$$y' = q_1 \cdot y_1 + q_2 \cdot y_2$$

반비례가 적용되기 전 $x$축의 수식을 정리한다.   
$x$축에서의 무게중심좌표를 $t_1$과 $t_2$로 지정하고 이를 사용해 $x$축의 두 점 $x_1$과 $x_2$ 사이의 점 $x'$을 구하는 수식은 다음과 같다.     
이 수식에서도 두 무게중심좌표의 합 $t_1 + t_2$의 값은 1이다.

$$x' = t_1 \cdot x_1 + t_2 \cdot x_2$$

두 값 $x'$와 $y'$는 서로 반비례 관계이므로 [식 10-3](#식-10-3)의 각 $y$값을 $x$값으로 표현하면 다음 식이 성립한다.

$$\frac{1}{x'} = q_1 \cdot \frac{1}{x_1} + q_2 \cdot \frac{1}{x_2}$$

주어진 두 점 $y_1$과 $y_2$의 값과 둘의 무게중심좌표 $q_1$과 $q_2$를 사용해 $x'$값을 계산할 수 있다.

$$x' = \frac{1}{(q_1 \cdot \frac{1}{x_1} + q_2 \cdot \frac{1}{x_2})}$$

양변에 분모를 곱하면 다음 식이 성립된다.

$$x' \cdot (q_1 \cdot \frac{1}{x_1} + q_2 \cdot \frac{1}{x_2}) = 1$$

$$q_1 \cdot \frac{x'}{x_1} + q_2 \cdot \frac{x'}{x_2} = 1$$

두 무게중심좌표의 합은 1임을 이용해 위 식을 다음과 같이 변환한다.

$$q_1 \cdot \frac{x'}{x_1} + q_2 \cdot \frac{x'}{x_2} = t_1 + t_2$$

양변의 덧셈항을 분리하면 다음의 관계를 얻을 수 있다.

###### 식 10-4

$$t_1 = \frac{x'}{x_1}q_1,\ t_2 = \frac{x'}{x_2}q_2$$

앞선 예에서 $y$축에서의 무게중심좌표는 각각 0.25와 0.75였다.

$$q_1 = \frac{1}{4},\ q_2 = \frac{3}{4}$$

[식 10-4](#식-10-4)를 적용하면 다음과 같이 $x$축에서의 무게중심좌표 0.5가 잘 계산됨을 확인할 수 있다.

$$t_1 = \frac{x'}{x_1}q_1 = \frac{4}{2} \cdot \frac{1}{4} = 0.5$$

$$t_2 = \frac{x'}{x_2}q_2 = \frac{4}{6} \cdot \frac{3}{4} = 0.5$$

두 점의 조합에 대한 무게중심좌표를 확장해 삼각형을 구성하는 세 점의 조합에도 동일하게 적용할 수 있다.       
두 점으로 구성된 [식 10-4](#식-10-4)를 세 점으로 확장한 수식은 다음과 같다.

$$x' = \frac{1}{(q_1 \cdot \frac{1}{x_1} + q_2 \cdot \frac{1}{x_2} + q_3 \cdot \frac{1}{x_3})}$$

$$t_1 = \frac{x'}{x_1}q_1,\ t_2 = \frac{x'}{x_2}q_2,\ t_3 = \frac{x'}{x_3}q_3$$

[식 10-5](#식-10-5)를 사용해 NDC에서 구한 무게중심좌표를 사영 공간의 무게중심좌표로 변환한다.     
사영 공간에서 NDC로 변환될 때 나누느 값은 뷰 공간의 $z$값이므로, 위 식에서 $x$를 $-z$로 치환하면 최종 투영 보정 보간의 식을 얻을 수 있다.

###### 식 10-5

$$z' = \frac{1}{(q_1 \cdot \frac{1}{z_1} + q_2 \cdot \frac{1}{z_2} + q_3 \cdot \frac{1}{z_3})}$$

$$t_1 = \frac{z'}{z_1}q_1,\ t_2 = \frac{z'}{z_2}q_2,\ t_3 = \frac{z'}{z_3}q_3$$

투영 보정 보간의 수식을 활용해 찌그러진 텍스처를 똑바로 펴줄 수 있다.   
이를 ***원근 보정 매핑(Perspective correction mapping)*** 이라고 한다.

# 38. 깊이 버퍼
다수의 게임 오브젝트를 그리는 경우 카메라로부터 멀리 떨어진 게임 오브젝트를 먼저 그리고 가까운 오브젝트를 다음에 그리도록 순서를 조절해야 원근감이 올바르게 표현된다.   
하지만 같은 거리에 있는 두 게임 오브젝트가 서로 겹쳐 있다면, 물체 단위로 그리는 순서를 조절하는 것으로는 문제를 해결할 수 없다.     
근본적인 해결 방법은 ***게임 오브젝트의 단위가 아닌 삼각형의 픽셀 단위로 깊이를 비교하고 가까운 곳에 있는 픽셀만 그리는 것***이다.    
이를 구현하기 위해 ***화면의 픽셀마다 현재의 깊이 값을 보관해주는 별도의 저장 공간***이 필요한데, 이를 ***깊이 버퍼(Depth buffer)*** 라고 한다.

최종 픽셀을 찍는 과정에서 ***현재 깊이 값을 깊이 버퍼에 저장된 값과 비교해 현재 깊이 값이 작은 경우에만 픽셀을 찍도록 로직을 구성***하면 그리기 순서 문제를 해결하면서 물체에 가려져 그리지 않아도 되는 픽셀을 파악해 그리기를 건너뛸 수 있다.    
이 작업을 ***깊이 테스팅(Depth testing)*** 이라고 한다.

# 39. 절두체 컬링
게임 콘텐츠가 원활하게 동작하기 위해서는 사용자 입력에 따라 월드 공간에 놓인 물체들을 실시간으로 빠르게 그려내야 한다.  
가장 효과적인 방법은 시야에 보이는 물체만 그리는 것이다.    
이의 대표적인 기법으로는 ***벡터 외적을 활용한 백페이스 컬링***을 들 수 있다.

다수의 게임 오브젝트가 월드 공간에 넓게 퍼져 있는 경우, 카메라 시야 밖에 위치한 게임 오브젝트까지 모두 그리는 것은 비효율적인 작업이다.     
게임에서 그래픽을 구현할 때는 효과적인 렌더링을 위해 [그림 11-1](#그림-11-1-절두체를-구성하는-6개의-평면)의 절두체 영역에 속한 게임 오브젝트만 그린다.   
그렇다면 절두체의 영역 밖에 있는 게임 오브젝트를 파악하고 걸러내는 기능이 필요한데 이를 ***절두체 컬링(Frustum culling)*** 이라고 한다.

절두체 컬링은 [그림 11-1](#그림-11-1-절두체를-구성하는-6개의-평면)에서 절두체를 구성하는 6개의 평면에 대해 각각 평면의 방정식을 세우고, 평면의 방정식을 활용해 대상 게임 오브젝트의 위치가 평면의 바깥에 있는지 확인하는 절차로 진행된다.    
만일 ***게임 오브젝트가 6개의 평면 중 하나라도 바깥쪽에 위치해 있다면 그리기에서 제외된다***.

###### 그림 11-1 절두체를 구성하는 6개의 평면
![절두체를 구성하는 6개의 평면](/img/)

# 39.1. 평면의 방정식
절두체 컬링을 구현하기에 앞서 절두체를 구성하는 평면의 방정식을 알아야한다.     
세 점이 주어지면 세 점으로부터 두 벡터를 생성해 평면 상의 모든 점을 생성할 수 있다.     
그렇기에 ***하나의 평면을 정의하려면 최소 3개의 점이 필요하다***.     
***3차원 공간의 평면은 앞면과 뒷면이 존재***하기 때문에, 이를 구분할 수 있는 정보도 있어야 한다.

그래서 평면을 정의할 때는 [그림 11-2](#그림-11-2-평면을-이루는-최소-구성-요소)의 (a)와 같이 세 점의 정보를 사용하기보다 (b)에서 제시하는 것처럼 평면이 바라보는 방향을 알려주는 법선 벡터와 평면 상에 위치한 한 점을 제공하는 방법을 사용한다.   
이때 법선 벡터는 크기를 1로 정규화시키는 것이 일반적이다.

###### 그림 11-2 평면을 이루는 최소 구성 요소
![평면을 이루는 최소 구성 요소](/img/)

평면이 향하는 방향을 나타내는 법선 벡터 $\hat{n}$의 값이 $(a, b, c)$로 주어지면, 크기가 1이므로 $a^2 + b^2 + c^2 = 1$의 조건이 성립한다.    
평면에 위치한 임의의 점 $P_0(x_0, y_0, z_0)$의 값이 주어졌다고 가정한다.     
이 두 요소는 3차원 공간에서 평면을 정의할 때 최소로 주어지는 값이다.    
이 상황에서 임의의 점 $P(x, y, z)$가 같은 평면 위에 있을 조건을 생각해보자.

평면의 방향을 나타내는 법선 벡터와 평면 위의 두 점을 지나는 벡터는 서로 직교하기 때문에 두 벡터의 내적은 0이 된다.  
따라서 법선 벡터 $\hat{n}$와 점 $P_0$에서 점 $P$로 향하는 벡터를 내적하면 다음 수식이 성립한다.

###### 식 11-1

$$
\begin{matrix}
\hat{n} \cdot (P - P_0) &=& (a, b, c) \cdot (x - x_0, y - y_0, z - z_0) = 0 \\
&=& ax + by + cz - (ax_0 + by_0 + cz_0) = 0 \\
\end{matrix}
$$

법선 벡터 $(a, b, c)$와 평면의 점 $(x_0, y_0, z_0)$는 사전에 주어진 값이므로 $-(ax_0 + by_0 + cz_0)$는 미리 계산할 수 있는 상수 값이다.  
이를 간단히 $d$로 치환한다.     
[식 11-1](#식-11-1)은 다음과 같이 간략하게 표시할 수 있는데, 이를 ***평면의 방정식(The equation of plane)*** 이라고 한다.

###### 식 11-2

$$ax + by + cz + d = 0$$

이렇게 유도한 평면의 방정식을 실제로 활용하는 데에는 마지막 상수 $d$가 가지는 의미를 파악해 두면 여러모로 유용하다.     

$$d = -(ax_0 + by_0 + cz_0)$$

상수 $d$는 법선 벡터 $(a, b, c)$와 벡터 $(x_0, y_0, z_0)$와의 내적에 음의 부호를 설정한 결과로 볼 수 있다.

$$d = -\hat{n} \cdot (x_0, y_0, z_0)$$

$(x_0, y_0, z_0)$는 점 $P_0$의 좌표지만, 이는 원점 $O$에서 점 $P_0$로 향하는 벡터의 값으로도 사용할 수 있다.    
이를 $\vec{p}$로 표시한다.      
위 공식을 정리하면 다음과 같다.

$$d = -\hat{n} \cdot \overline{OP_0} = -\hat{n} \cdot \vec{p}$$

상수 $d$에 관련된 두 벡터 $\hat{n}$과 $\vec{p}$를 시각화하면 [그림 11-3](#그림-11-3-d를-계산하기-위한-평면의-구성-요소)과 같다.

###### 그림 11-3 d를 계산하기 위한 평면의 구성 요소
![d를 계산하기 위한 평면의 구성 요소](/img/)

$\hat{n} \cdot \vec{p}$는 벡터 내적의 $\cos$ 공식으로 표현할 수 있다.

$$\hat{n} \cdot \vec{p} = |\hat{n}||\vec{p}|\cos \theta$$

현재 법선 벡터의 크기는 항상 1이므로 이 공식은 다음과 같이 간단히 정리된다.

$$\hat{n} \cdot \vec{p} = |\vec{p}|\cos \theta$$

$\hat \cdot \vec{p}$는 [그림 11-4](#그림-11-4-상수-d와-관련된-두-벡터-내적의-의미)와 같이 $\vec{p}$ 벡터를 법선 벡터 $\hat{n}$에 투영한 벡터의 크기를 의미한다.

###### 그림 11-4 상수 d와 관련된 두 벡터 내적의 의미
![상수 d와 관련된 두 벡터 내적의 의미](/img/)

평면과 법선 벡터는 서로 직교하기 때문에 방금 구한 $\hat{n} \cdot \vec{p}$의 값은 원점에서 평면까지의 최단 거리를 의미한다.  
$d$의 값은 $\hat{n} \cdot \vec{p}$가 아닌 $-\hat{n} \cdot \vec{p}$이므로 원점으로부터 평면의 최단 거리에 음의 부호를 설정한다는 특징을 가진다.      
***거리라는 측정값은 음수가 나올 수 없기 때문에*** $d$의 값은 ***원점으로부터의 최단 거리와 방향이라는 두 가지 정보를 담고 있다***.

***내적의 성질에 의해 두 벡터가 같은 방향을 바라보면 +값이 나오고, 반대 방향을 바라보면 -값이 나온다***.      
$d$의 값이 음수라면 두 벡터 $\hat{n}$과 $\vec{p}$는 같은 방향을 바라보고 있다는 의미다.

[그림 11-5](#그림-11-5-평면이-반대-방향을-향하는-경우)와 같이 평면이 원점을 향하는 반대의 경우를 가정한다.

###### 그림 11-5 평면이 반대 방향을 향하는 경우
![평면이 반대 방향을 향하는 경우](/img/)

평면이 원점을 향한다면 두 벡터는 서로 마주보는 상황이므로 내적의 값은 음수가 되고, $d$의 값은 반대 부호인 양수가 나온다.    
따라서 평면의 방정식 $d$의 값에 따라 평면이 가지는 두 가지 성질을 파악할 수 있다.

- $d$의 부호: $d$의 값이 양수면 평면이 바라보는 방향은 원점을 향하고, 음수면 원점에서 멀어지는 방향을 가진다.   
다시 말해 $d$의 값이 양수면 원점은 평면의 바깥에 위치하고, 음수면 원점은 평면의 안쪽에 위치한 것이다.
- $d$의 절댓값: 평면에서 원점까지의 최단 거리를 의미한다.

$d$의 정보는 평면의 방정식을 설계하는 데 큰 도움이 된다.    
예를 들어 [그림 11-6](#그림-11-6-원점을-품는-평면의-방정식)과 같이 평면이 원점을 품는다면 원점으로부터 거리 $d$의 값은 부호에 관계없이 없제나 0이 나오기 때문에 평면의 법선 벡터 값을 사용해 바로 $ax + by + cz = 0$이라는 평면의 방정식을 얻을 수 있다.

###### 그림 11-6 원점을 품는 평면의 방정식
![원점을 품는 평면의 방정식](/img/)

평면의 방정식을 구성하는 $d$ 값의 성질을 응용하면 주어진 점이 평면의 안쪽에 있는지 바깥쪽에 있는지도 판별할 수 있다.    
[그림 11-7](#그림-11-7-점의-내부-외부-판별)과 같은 상황을 생각해보자.

###### 그림 11-7 점의 내부 외부 판별
![점의 내부 외부 판별](/img/)

만일 임의의 점 $P$가 있을 때, 원점에서 점 $P$로 향하는 벡터 $\vec{OP}$를 법선 벡터에 내적한 값을 $p$ 표기한다.  
$p$의 부호를 통해 법선 벡터에 투영한 벡터 $\vec{OP'}$의 방향 정보를 파악할 수 있다.     
$p$가 양수면 벡터 $\vec{OP'}$는 법선 벡터와 같은 방향을 향하고, 음수면 법선 벡터와 반대 방향을 향한다.  
따라서 [그림 11-7](#그림-11-7-점의-내부-외부-판별)의 상황에서 $p$는 양수다.

$p$와 평면의 방정식의 상수 $d$를 서로 더한 값을 살펴보자.   
[그림 11-7](#그림-11-7-점의-내부-외부-판별)에서 원점이 평면 안쪽에 있으므로 $d$값은 음수다.     
음수 $d$에 양수인 $p$를 더한 값이 여전히 음수라면, 점 $P$는 평면의 안쪽에 있다고 판단할 수 있다.    
반대로 $p$와 $d$를 더한 값이 양수면 점 $P$는 평면의 바깥쪽에 있다고 판단할 수 있다.

법선 벡터가 반대인 [그림 11-8](#그림-11-8-법선-벡터가-반대-방향인-경우)인 경우에도 이 규칙은 동일하다.   
이 상황에서는 $d$값은 양수가 되고 $p$는 음수가 된다.    
$d$와 $p$를 더한 결과가 여전히 양수라면 이는 점 $P$가 평면의 바깥쪽에 있음을 의미한다.

###### 그림 11-8 법선 벡터가 반대 방향인 경우
![법선 벡터가 반대 방향인 경우](/img/)

따라서 법선 벡터 $(a, b, c)$와 $d$를 사용해 정의한 평면에 주어진 점 $P(x_1, y_1, z_1)$가 평면의 바깥쪽에 있는지를 판단하는 수식은 다음과 같다.

$$(a, b, c) \cdot (x_1, y_1, z_1) + d > 0$$

이때 $(a, b, c) \cdot (x_1, y_1, z_1) + d$의 값에 절댓값을 취하면 이는 평면에서 해당 점까지의 최단 거리를 의미한다.

###### 식 11-3

$$distance = |(a, b, c) \cdot (x_1, y_1, z_1) + d|$$

# 39.2. 평면의 방정식의 정규화
평면의 방정식에서 알아둬야 할 점은 평면의 방정식도 정규화시킬 수 있다는 점이다.     
크기가 1이 아닌 법선 벡터 $\vec{n}$이 만들어내는 평면의 방정식이 다음과 같이 주여졌다고 가정한다.

$$ax + by + cz + d = 0$$

이를 크기가 1인 법선 벡터로부터 만들어지는 평면의 방정식으로 바꿔야 한다.   
크기가 1인 법선 벡터 $\vec{n}$의 값을 $(a', b', c')$로 지정하면 평면의 방정식은 다음과 같다.

$$a'x + b'y + c'z + d' = 0$$

크기가 1이 아닌 주어진 법선 벡터를 구성하는 세 계수 $(a, b, c)$를 정규화해 $(a', b', c')$로 만드는 수식은 법선 벡터의 크기 $|\vec{n}|$으로 나누면 구할 수 있다.

$$(a', b', c') = \frac{\vec{n}}{|\vec{n}|} = \frac{\vec{n}}{\sqrt{a^2 + b^2 + c^2}} = \frac{(a, b, c)}{\sqrt{a^2 + b^2 + c^2}}$$

법선 벡터의 크기가 1일 때 평면의 방정식 값이 $d'$라면 마지막 계수 $d$를 $d'$로 변경하는 수식을 생각해야 한다.   
마지막 계수 $d$는 평면 위의 한 점으로 향하는 벡터 $\vec{p}$와 평면의 법선 벡터 $\hat{n}$을 내적한 값의 반대수를 의미한다.

$$d = -\vec{n} \cdot \vec{p} = -|\vec{n}||\vec{p}|\cos \theta$$

법선 벡터의 크기가 1일 때 평면의 방정식 값 $d'$는 다음과 같다.

$$d' = -|\vec{p}|\cos \theta$$

이로써 $d$와 $d'$의 관계는 다음과 같이 정리된다.

$$d' = \frac{d}{|\vec{n}|}$$

그렇기 때문에 $d$의 경우에도 동일하게 법선 벡터의 크기 $|\vec{n}|$으로 나누면 원하는 값 $d'$를 얻을 수 있다.

###### 식 11-4

$$\frac{ax + by + cz + d}{\sqrt{a^2 + b^2 + c^2}} = 0$$

임의의 네 수로부터 평면의 방정식을 구성한다면 [식 11-4](#식-11-4)를 사용해 평면의 방정식을 정규화시켜주는 것이 이후에 평면의 방정식을 활용할 때 더 편리하다.     
정규화된 평면의 방정식의 $d$값은 원점으로부터의 최단 거리 정보를 담고 있기 때문이다.

> 참고: ***2차원 직선의 방정식에서의 최단 거리***   
평면의 방정식은 내적에 기반을 두기 때문에 2차원 공간에서도 동일하게 활용할 수 있다.     
3차원 공간의 평면이 앞면과 뒷면을 가진 것처럼, 2차원 공간의 직선도 앞쪽과 뒤쪽을 가진다.    
2차원 공간에서의 직선의 방정식이 $ax + by + c = 0$이라고 할 때, 여기서 법선 벡터 $(a, b)$의 크기가 1이면 상수 $c$의 절댓값은 원점에서 직선까지의 최단 거리를 의미한다.  
만약 법선 벡터 $(a, b)$의 크기가 1이 아니라면 원점에서 직선까지의 최단 거리는 다음과 같다.
>
> $$\frac{|c|}{\sqrt{a^2 + b^2}}$$
>
> [그림 11-9](#그림-11-9-직선과-점-사이의-최단-거리)와 같은 임의의 한 점 $(x_1, y_1)$에서 임의의 직선 $ax + by + c = 0$까지의 최단 거리는 [식 11-3](#식-11-3)을 참고해 평면의 방정식을 정규화한 값과 내적을 활용해 다음과 같이 구할 수 있다.
>
> ###### 그림 11-9 직선과 점 사이의 최단 거리
> ![직선과 점 사이의 최단 거리](/img/)

# 39.3. 평면의 방정식을 활용한 절두체 표현
절두체를 구성하는 6개의 평면에 대한 방정식을 직접 계산하고 이를 활용해 ***카메라 시야 영역에서 벗어난 게임 오브젝트들을 솎아내는 기능인 절두체 컬링***을 구현할 수 있다.  

###### 그림 11-10 절두체의 y축 상단 평면
![절두체의 y축 상단 평면](/img/)

[그림 10-16](#그림-10-16-카메라에-설정한-절두체)을 참고해 절두체 상단 평면을 무한하게 확장하면 상단 평면은 원점을 품게 된다.    
이는 근평면과 원평면을 제외한 나머지 평면에 대해서도 동일하다.  
그렇다면 근평면과 원평면을 제외한 네 평면을 구성하는 평면의 방정식의 $d$값은 0이므로 크기가 1인 법선 벡터만 구하면 근평면과 원평면을 제외한 평면의 방정식을 얻을 수 있다.   
뷰 공간의 측면에서 절두체를 투영한 모습은 [그림 11-11](#그림-11-11-절두체-상단-평면의-법선-벡터를-구하는-과정)과 같이 그려진다.

###### 그림 11-11 절두체 상단 평면의 법선 벡터를 구하는 과정
![절두체 상단 평면의 법선 벡터를 구하는 과정](/img/)

측면에서 바라본 평면의 좌표계에서 오른쪽 방향은 뷰 공간의 $-z$축에 대응되고 위쪽 방향은 $y$축에 대응된다.   
평면에서 오른쪽을 향하는 $(0, 0, -1)$의 벡터를 반시계 방향으로 $\frac{\theta}{2}$만큼 회전한 결과는 $(0, \sin\frac{\theta}{2}, -\cos\frac{\theta}{2})$가 된다.  
평면의 법선 벡터는 여기서 $90^\circ$만큼 더 회전한 값이므로 $y$값과 $z$값을 교차시키고 $y$값에 반대 부호를 취하면 얻을 수 있다.     
이를 적용한 법선 벡터는 다음과 같다.

$$\hat{n} = (0, \cos \frac{\theta}{2}, \sin \frac{\theta}{2})$$

$d$값은 0이므로 절두체 상단을 구성하는 평면의 방정식은 다음과 같다.

###### 식 11-5

$$\cos \frac{\theta}{2}y + \sin \frac{\theta}{2}z = 0$$

이와 유사한 방식으로 나머지 세 평면의 방정식을 구하면 다음과 같다.

- 절두체 하단 평면의 방정식: $-\cos\frac{\theta}{2}y + \sin\frac{\theta}{2}z = 0$
- 절두체 좌측 평면의 방정식: $-\cos\frac{\theta}{2}x + \sin\frac{\theta}{2}z = 0$
- 절두체 우측 평면의 방정식: $\cos\frac{\theta}{2}x + \sin\frac{\theta}{2}z = 0$

원점을 지나는 평면의 방정식 4개를 구했다면 나머지 근평면과 원평면의 방정식을 구한다.    
근평면은 [그림 11-12](#그림-11-12-근평면의-특징)에서 보듯이 원점을 향하고 있으며 원점으로부터의 거리는 $n$이므로 평면의 방정식의 $d$ 값은 $n$이 된다.  
그리고 근평면의 법선 벡터의 값은 $(0, 0, 1)$이다.

###### 그림 11-12 근평면의 특징
![근평면의 특징](/img/)

근평면의 방정식은 다음과 같이 구할 수 있다.

$$(0, 0, 1) \cdot (x, y, z) - (0, 0, 1) \cdot (0, 0, -n) = 0$$

$$\therefore z + n = 0$$

원평면의 법선 벡터는 근평면에 반대 방향인 원점에서 멀어지는 $(0, 0, -1)$이며, 원점으로부터의 거리는 $f$가 된다.     
따라서 원평면의 방정식은 다음과 같이 계산된다.

$$(0, 0, -1) \cdot (x, y, z) - (0, 0, 1) \cdot (0, 0, f) = 0$$

$$\therefore -z - f = 0$$

평면의 방정식을 다룰 때 주의할 점은 방향 정보가 수록되어 있기 때문에 함부로 수식을 옮기면 안 된다는 것이다.     
원평면의 방정식의 변을 옮기면 다음과 같은 방정식이 나온다.

$$0 = z + f$$

이 방정식으로 만들어지는 평면이 놓인 위치는 원평면과 동일하지만, 평면의 방향은 원평면의 반대 방향인 원점을 향한다.      
따라서 $z + f = 0$과 $-z - f = 0$은 서로 다른 평면이라는 점에 주의해야 한다.

# 39.4. 원근 투영 행렬로부터 평면의 방정식 만들기
***원근 투영 행렬을 활용해 절두체 컬링을 좀 더 간편하게 구현할 수 있다***.    
뷰 공간의 점이 NDC 좌표까지 변환됐을 때 NDC 좌표를 구성하는 $x, y, z$ 세 축의 값이 $[-1, 1]$ 범위에 있다면 해당 점은 절두체 영역 안쪽에 있음을 의미한다.

NDC 좌푯값을 $(n_x, n_y, n_z)$으로 표기했을 때 이를 수식으로 표현하면 다음과 같다.

$$-1 \leq n_x \leq 1$$

$$-1 \leq n_y \leq 1$$

$$-1 \leq n_z \leq 1$$

이 조건에서 변환 과정을 거꾸로 추적해 수식을 발전시키면, NDC 좌표는 클립 좌표의 마지막 차원 $w$로 나눈 결괏값이므로, 위 수식을 클립 좌표 $(x, y, z, w)$로 바꿔 쓰면 다음과 같다.

$$-1 \leq \frac{x}{w} \leq 1$$

$$-1 \leq \frac{y}{w} \leq 1$$

$$-1 \leq \frac{z}{w} \leq 1$$

위 식의 양변에 $w$를 곱하면 다음과 같이 정리된다.

###### 식 11-6

$$-w \leq x \leq w$$

$$-w \leq y \leq w$$

$$-w \leq z \leq w$$

이 상황에서 거꾸로 뷰 공간에서 클립 공간으로 변환한 과정은 뷰 공간의 점 $\vec{v}$를 $(v_x, v_y, v_z, 1)$로 지정한 후에, ***원근 투영 행렬을 사용해 클립 좌표로 변환***하는 수식을 확인할 수 있다.

$$P \cdot \vec{v} = 
\begin{bmatrix}
\frac{d}{a} & 0 & 0 & 0 \\
0 & d & 0 & 0 \\
0 & 0 & \frac{n + f}{n - f} & \frac{2nf}{n - f} \\
0 & 0 & -1 & 0 \\
\end{bmatrix}
\begin{bmatrix}
v_x \\
v_y \\
v_z \\
1 \\
\end{bmatrix} = 
\begin{bmatrix}
x \\
y \\
z \\
w \\
\end{bmatrix}
$$

원근 투영행렬을 $P_{row1}$부터 $P_{row4}$까지 4개의 행벡터로 표현하면 위 연산은 행벡터와 점의 내적으로 바꿔 쓸 수 있다.

$$
\begin{bmatrix}
P_{row1} \cdot \vec{v} \\
P_{row2} \cdot \vec{v} \\
P_{row3} \cdot \vec{v} \\
P_{row4} \cdot \vec{v} \\
\end{bmatrix} = 
\begin{bmatrix}
x \\
y \\
z \\
w \\
\end{bmatrix}
$$

그러면 클립 공간의 각 요소는 행벡터와 점의 내적으로 표현된다.

$$x = P_{row1} \cdot \vec{v}$$

$$y = P_{row2} \cdot \vec{v}$$

$$z = P_{row3} \cdot \vec{v}$$

$$w = P_{row4} \cdot \vec{v}$$

[식 11-6](#식-11-6)의 부등식을 구성하는 $x, y, z, w$를 내적으로 치환하면 다음과 같이 전개된다.

$$-P_{row4} \cdot \vec{v} \leq P_{row1} \cdot \vec{v} \leq P_{row4} \cdot \vec{v}$$

$$-P_{row4} \cdot \vec{v} \leq P_{row2} \cdot \vec{v} \leq P_{row4} \cdot \vec{v}$$

$$-P_{row4} \cdot \vec{v} \leq P_{row3} \cdot \vec{v} \leq P_{row4} \cdot \vec{v}$$

위 식을 분리해 총 6개의 부등식으로 표현하면 다음과 같다.

$$(P_{row4} + P_{row1}) \cdot \vec{v} \geq 0$$

$$(P_{row4} - P_{row1}) \cdot \vec{v} \geq 0$$

$$(P_{row4} + P_{row2}) \cdot \vec{v} \geq 0$$

$$(P_{row4} - P_{row2}) \cdot \vec{v} \geq 0$$

$$(P_{row4} + P_{row3}) \cdot \vec{v} \geq 0$$

$$(P_{row4} - P_{row3}) \cdot \vec{v} \geq 0$$

6개의 부등식이 모두 참이면, 뷰 공간의 점 $\vec{v}$는 절두체 영역의 내부에 있음을 의미하고, 하나라도 만족하지 못하면 절두체 영역의 외부에 있음을 의미한다.   
괄호 안의 원근 투영 행렬의 행벡터를 계산한 4차원 벡터를 $(a, b, c, d)$로 표시했을 때 이를 뷰 공간의 점 $(x, y, z, 1)$과 내적한 결과는 다음과 같다.

$$ax + by + cz + d \geq 0$$

이는 ***평면의 방정식과 형태가 동일***하다.   
하지만 이 식에서 만들어지는 법선 벡터 $(a, b, c)$의 크기는 1이 아니므로 [식 11-4](#식-11-4)에 따라 이를 ***정규화된 평면의 방정식으로 변환***한다.

$$\frac{ax + by + cz + d}{\sqrt{a^2 + b^2 + c^2}} = 0$$

이와 같은 과정을 거쳐 구한 평면의 방향은 모두 절두체 내부를 향한다.     
절두체 컬링을 구현할 때는 해당 점이 외부에 있는지를 파악하는 수식이 필요하다.   
따라서 위에서 만든 평면이 절두체 외부를 향하도록 부호를 반전시킨다.

$$-(\frac{ax + by + cz + d}{\sqrt{a^2 + b^2 + c^2}}) = 0$$

이제 평면 밖에 위치한 상황만 검출해야 하므로 등호 대신 부등호로 교체하면 다음의 수식이 완성된다.

$$-(\frac{ax + by + cz + d}{\sqrt{a^2 + b^2 + c^2}}) > 0$$

> 참고: ***행렬로 만들어낸 평면의 방정식 검증***    
행렬로부터 만들어낸 평면의 방정식이 절두체의 성질로부터 구축한 평면의 방정식과 실제로 일치하는지 확인해 보자.
>
> $$P = 
\begin{bmatrix}
\frac{d}{a} & 0 & 0 & 0 \\
0 & d & 0 & 0 \\
0 & 0 & \frac{n + f}{n - f} & \frac{2nf}{n - f} \\
0 & 0 & -1 & 0 \\
\end{bmatrix}$$
> 
> 절두체 상단에 해당하는 벡터는 네 번째 행벡터 $(0, 0, -1, 0)$와 두 번째 행벡터 $(0, d, 0, 0)$를 빼서 얻을 수 있다.     
이를 내적해 얻는 평면의 방정식을 정규화시켜 전개한다.
>
> $$
\begin{matrix}
(P_{row4} - P_{row2}) \cdot v &=& ((0, 0, -1, 0) - (0, d, 0, 0)) \cdot (x, y, z, 1) = 0 \\
&=& (0, -d, -1, 0) \cdot (x, y, z, 1) = 0 \\
&=& -dy - z = 0 \\
&=& -\frac{1}{\tan\frac{\theta}{2}}y - z = 0 \\
&=& -\frac{\cos\frac{\theta}{2}}{\sin\frac{\theta}{2}}y - z = 0 \\
&=& -\cos\frac{\theta}{2}y - \sin\frac{\theta}{2}z = 0 \\
\end{matrix}$$
>
> $d$는 초점 거리를 의미하므로 이를 $\frac{1}{\tan\frac{\theta}{2}}$로 치환해 전개한다.     
$\tan\frac{\theta}{2}$를 $\frac{\sin\frac{\theta}{2}}{\cos\frac{\theta}{2}}$로 치환해 전개한다.     
양변에 $\sin\frac{\theta}{2}$를 곱한다.     
이렇게 만들어진 평면의 법선 벡터 $(0, -\cos\frac{\theta}{2}, -\sin\frac{\theta}{2})$의 크기는 1이므로 이는 유효한 평면의 방정식임을 알 수 있다.
>
> 위에서 유도한 평면의 방정식 $-\cos\frac{\theta}{2}y - \sin\frac{\theta}{2}z = 0$은 절두체 안쪽을 향한다.  
따라서 부호를 반전시켜 절두체 바깥쪽을 향하는 평면의 방정식 $\cos\frac{\theta}{2}y + \sin\frac{\theta}{2}z = 0$은 [식 11-5](#식-11-5)와 동일함을 확인할 수 있다.

# 40. 바운딩 볼륨
절두체 컬링만으론 카메라를 움직일 때 화면 가장자리에 있는 게임 오브젝트가 갑자기 사라지거나 튀어나오는 현상이 발생한다.     
화면 가장자리에서 튀는 현상이 발생하는 이유는 ***게임 오브젝트의 메시가 차지하는 공간 영역이 있음에도 불구하고 게임 오브젝트의 기준 위치만 가지고 절두체 컬링을 수행했기 때문***이다.

예를 들어 [그림 11-13](#그림-11-13-절두체에-걸쳐져-있지만-절두체-컬링에-의해-그리기에서-제거된-게임-오브젝트의-예시)과 같은 상황이 발생하면 기존 절두체 컬링 로직에서는 게임 오브젝트의 위치가 절두체 바깥에 있다고 판단해 그리기를 건너뛸 것이다.     
하지만 이 게임 오브젝트는 절두체 영역에 걸쳐 있기 때문에 그려줘야 한다.

###### 그림 11-13 절두체에 걸쳐져 있지만 절두체 컬링에 의해 그리기에서 제거된 게임 오브젝트의 예시
![절두체에 걸쳐져 있지만 절두체 컬링에 의해 그리기에서 제거된 게임 오브젝트의 예시](/img/)

이 문제를 해결하기 위해서는 게임 오브젝트의 위치를 대상으로 하지 않고, ***메시가 차지하는 영역을 감안해 절두체 컬링을 진행***해야 한다.   
게임 엔진은 메시가 차지하는 영역을 효과적으로 관리하기 위해 ***구(Sphere)*** 나 ***박스(Box)*** 같은 ***원시 도형(Primitive shape)*** 을 사용하는데, 이러한 원시 도형으로 설정한 공간 데이터를 ***바운딩 볼륨(Bounding volume)*** 이라고 한다.

[그림 11-14](#그림-11-14-언리얼-엔진에서-설정한-메시의-바운딩-볼륨)는 언리얼 엔진에서 관리하는 메시의 바운딩 볼륨에 대한 정보다.   
메시를 감싸는 노란색의 구와 파란색의 박스가 설정돼 있다.

###### 그림 11-14 언리얼 엔진에서 설정한 메시의 바운딩 볼륨
![언리얼 엔진에서 설정한 메시의 바운딩 볼륨](/img/)

# 40.1. 구 바운딩 볼륨의 판정
바운딩 볼륨에서 손쉽게 사용되는 원시 도형은 ***구(Sphere)*** 다.   
***구는 두 영역이 서로 겹치는지, 떨어져 있는지를 가장 쉽고 빠르게 파악할 수 있는 도형***이기 때문이다.    
어떤 점이 구의 외부에 있는지 여부를 파악하는 방법은 [그림 11-15](#그림-11-15-구를-이용한-빠르고-손쉬운-영역-판별법)의 (a)와 같이 구의 중점에서부터 점까지의 거리와 구의 반지름의 크기를 비교하는 것이다.

$$d > r_1$$

또한 두 구의 영역이 서로 떨어져 있는지 여부는 [그림 11-15](#그림-11-15-구를-이용한-빠르고-손쉬운-영역-판별법)의 (b)와 같이 ***두 구의 중점 간의 거리와 두 구의 반지름을 더한 값을 비교***하는 것만으로 쉽게 파악할 수 있다.

$$d > (r_1 + r_2)$$

###### 그림 11-15 구를 이용한 빠르고 손쉬운 영역 판별법
![구를 이용한 빠르고 손쉬운 영역 판별법](/img/)

메시에 구 바운딩 볼륨을 추가하면 구의 반지름 정보를 사용해 [그림 11-16](#그림-11-16-절두체-영역과-메시에-설정한-구-영역의-비교)과 같이 ***메시 영역이 절두체 영역의 안쪽에 있는지, 겹치는지, 벗어나는지를 파악***할 수 있다.

###### 그림 11-16 절두체 영역과 메시에 설정한 구 영역의 비교
![절두체 영역과 메시에 설정한 구 영역의 비교](/img/)

앞서 구했던 [식 11-3](#식-11-3)을 활용했을 때 구의 중점 좌표와 평면의 방정식의 법선 벡터 $(a, b, c)$와의 내적 값에 $d$값을 더한 값이 0보다 크다면 구는 평면의 바깥쪽에 위치한다는 의미다.  
이 값이 구의 반지름 $r$보다 더 크다면 해당 구의 영역은 평면으로부터 완전히 벗어난다.    
이런 경우에는 게임 오브젝트를 그리지 않도록 처리해야 한다.  
평면으로부터의 거리에 해당하는 [식 11-3](#식-11-3)의 값이 구의 반지름 $r$보다 작거나 같으면 구 영역은 절두체의 평면과 겹쳐져 있다고 판단할 수 있다.     
나머지 경우에는 절두체 안쪽에 위치해 있다고 판단하면 된다.      

# 40.2. AABB와의 판정
구 영역 대신 ***박스(Box)*** 영역을 사용해서 좀 더 정교한 절두체 컬링 작업을 수행할 수 있다.  
이를 위해서 메시 데이터로부터 박스 영역을 생성하는 방법을 알아야 하는데, 먼저 박스 영역을 구성하는 각 축의 최댓값과 최솟값을 설정하고, 메시를 구성하는 점을 순회하면서 각 차원의 값을 비교한다.     
현재 박스 영역에 저장된 최댓값보다 크거나 최솟값보다 작다면 박스 영역의 최댓값과 최솟값을 갱신해준다.   
모든 점에 대해 이 과정을 거치면 기저 축에 평행한 박스 영역이 형성되는데, 기저 축에 정렬되어 있다는 의미로 해당 바운딩 볼륨을 ***AABB(Axis aligned bounding box)*** 라고 부른다.    
[그림 11-14](#그림-11-14-언리얼-엔진에서-설정한-메시의-바운딩-볼륨)에서 파란색으로 표시된 바운딩 볼륨 영역이 AABB다.

로컬 공간에서 생성한 AABB 영역과 평면과의 판정은 어떻게 진행하는지 알아보자.    
[그림 11-17](#그림-11-17-법선-벡터의-부호에-따른-aabb의-비교-판정)의 (a)와 같이 평면의 법선 벡터의 모든 요소가 양수인 상황에서 AABB 영역이 평면의 바깥에 위치해 있다고 가정한다.    
이 상황에서 평면과 가장 가까운 AABB 영역의 점은 AABB의 최솟값이다.      
그렇다면 AABB 영역의 최솟값과 평면과의 차이를 측정하는 값은 양수가 나온다.      
반대로 [그림 11-17](#그림-11-17-법선-벡터의-부호에-따른-aabb의-비교-판정)의 (b)와 같이 평면의 법선 벡터의 모든 요소가 음수인 상황에서는, 평면과 가장 가까운 AABB 영역의 점은 최댓값이고, 최댓값과 평면과의 차이를 측정하는 값 또한 양수가 나온다.

###### 그림 11-17 법선 벡터의 부호에 따른 AABB의 비교 판정
![법선 벡터의 부호에 따른 AABB의 비교 판정](/img/)

AABB 영역과 법선 벡터의 $x, y, z$축은 서로 직교하고 있으므로 각 축의 데이터는 독립적으로 동작한다.      
따라서 ***각 법선 벡터의 요소마다 양수인 경우에는 해당 요소의 최솟값을, 음수인 경우에는 해당 요소의 최댓값을 사용하는 것으로 평면에서 가장 가까운 AABB의 점을 구할 수 있다***.    
예를 들어 [그림 11-18](#그림-11-18-한-쪽만-양수인-경우의-판정-방법)과 같이 $x$축과 $z$축의 법선 벡터가 음수고 $y$축만 양수라면 평면과 가장 가까운 AABB의 좌표는 $(Max, Min, Max)$가 된다.

###### 그림 11-18 한 쪽만 양수인 경우의 판정 방법
![한 쪽만 양수인 경우의 판정 방법](/img/)

***평면에서 가장 가까운 AABB의 좌표와 평면과의 차이를 측정했을 때 그 값이 양수가 나온다면, AABB 영역은 완전히 평면의 바깥에 위치해 있다고 판정할 수 있다***.

AABB 영역이 절두체의 평면과 교차되는 경우를 어떻게 판별할지 생각해보자.     
평면에서 가장 가까운 AABB의 좌표와 평면과의 차이를 측정한 값이 음수가 나오는 경우, ***평면에서 가장 가까운 AABB의 좌표와 정반대에 위치한 점으로 다시 평면과의 테스트를 진행해 평면과의 교차 여부를 확인***한다.   
***정반대에 위치한 점과 절두체 평면과의 차이를 측정한 값이 양수가 나오면*** [그림 11-19](#그림-11-19-aabb-영역과-평면이-교차하는-경우)와 같이 ***절두체 영역과 AABB 영역은 서로 교차한다***.

###### 그림 11-19 AABB 영역과 평면이 교차하는 경우
![AABB 영역과 평면이 교차하는 경우](/img/)

# 41. 삼각형 클리핑
동차 좌표계에서 물체가 깨지는 현상을 알아보기 위해 [그림 11-20](#그림-11-20-카메라-바로-아래에-거대한-사각형-메시가-위치한-경우)과 같이 거대한 삼각형을 카메라의 앞뒤에 배치한다.

###### 그림 11-20 카메라 바로 아래에 거대한 사각형 메시가 위치한 경우
![카메라 바로 아래에 거대한 사각형 메시가 위치한 경우](/img/)

[그림 11-21](#그림-11-21-카메라-뒤에-위치한-점을-거꾸로-투영하는-경우의-문제)과 같이 대형 삼각형을 구성하는 세 점 중에서 한 점이 카메라 뒤쪽에 위치하는 경우를 생각해보자.   
이를 투영하면 카메라 뒤쪽에 위치한 점은 무한 원점을 중심으로 뒤집혀 투영된다.

따라서 뒤집혀 투영된 점을 사용해 그대로 삼각형을 그리면 엉뚱한 삼각형이 그려진다.

###### 그림 11-21 카메라 뒤에 위치한 점을 거꾸로 투영하는 경우의 문제
![카메라 뒤에 위치한 점을 거꾸로 투영하는 경우의 문제](/img/)

평면이 올바르게 보이려면 카메라 뒤쪽에 있는 점을 파악해 점이 거꾸로 뒤집혀 투영되지 않도록 예방해야 한다.   

원근 투영 행렬을 곱해 생성된 클립 좌표계의 $w$값은 뷰 공간에서의 깊이 값을 의미한다.    
따라서 카메라 정면에 위치한 점의 $w$값은 0보다 크고, 카메라 뒤에 있는 점의 $w$값은 0보다 작으며, 카메라 초점에 위치한 점의 $w$값은 0이 된다.

따라서 문제 해결을 위해 음의 $w$ 영역에 걸쳐 있는 삼각형을 파악하고 이들이 엉뚱하게 투영되지 않도록 삼각형 영역을 잘라내야 한다.    
이를 ***삼각형 클리핑(Triangle clipping)*** 이라고 한다.   
***삼각형 클리핑 작업은 월드 공간의 좌표를 사용하지 않고 투영 행렬을 적용한 후의 좌표를 사용***한다.      
***사영 공간에서 삼각형 클리핑 작업을 진행하는 것이 더 간편하기 때문***이다.      
이는 ***사영 공간의 좌표를 클립 좌표로 부르는 이유***다.

[그림 11-22](#그림-11-22-문제를-방지하기-위한-사전-투영-작업)과 같이 위에서 절두체를 내려다본 상황을 생각해보자.     
그리려는 삼각형의 두 점의 $w$값은 양수이고, 나머지 하나는 음수인 상황이다.      
이 경우 뒤집혀 투영되는 문제를 해결하기 위해 붉은색으로 표시된 음의 영역을 잘라내는 작업이 필요하다.    
음의 영역에 위치한 점 $P_1$을 $w = 0$ 평면에 투영한 두 점 $P_{c1}$과 $P_{c2}$의 좌표를 구해야 한다.

###### 그림 11-22 문제를 방지하기 위한 사전 투영 작업
![문제를 방지하기 위한 사전 투영 작업](/img/)

점 $P_1$과 점 $P_2, P_3$를 이은 두 선분이 있을 때 점 $P_{c1}$과 $P_{c2}$의 좌표는 각 선분 위의 점이다.      
이 중에서 점 $P_{c1}$의 좌표는 ***아핀 결합의 직선의 방정식***을 사용해 다음과 같이 구할 수 있다.

###### 식 11-7

$$P_{c1} = P_1 \cdot (1 - t_1) + P_2 \cdot t_1$$

점 $P_{c1}$은 $w = 0$인 직선에 위치하므로 $P_{c1}$의 $w$값은 0이다.     
따라서 점 $P_1, P_2$의 $w$값을 각각 $w_1, w_2$로 표기한다면 다음의 수식이 성립한다.

$$w_1(1 - t_1) + w_2t_1 = 0$$

이 식을 $t_1$에 대해 전개하면 다음 값을 구할 수 있다.

$$t_1 = \frac{w_1}{w_1 - w_2}$$

$t_1$의 값을 구한 후 [식 11-7](#식-11-7)에 대입하면 점 $P_{c1}$의 최종 좌표를 얻을 수 있다.     
다른 점 $P_{c2}$도 동일한 방법으로 구할 수 있다.    
여기서 주의해야 할 점은 삼각형을 잘라낸 후에 $w = 0$ ***평면에 투영된 두 점과 투영되지 않은 두 점의 영역은 삼각형이 아닌 사각형을 이룬다***는 것이다.     
따라서 점을 투영한 후에는 사각형을 [그림 11-23](#그림-11-23-투영-후-사각형을-두-개의-삼각형으로-분할하기)과 같이 두 개의 삼각형으로 분할해야 한다.    
분할할 때에는 ***면의 방향이 동일하도록 정점의 순서도 자르기 전의 삼각형의 순서와 동일해야 한다***.

###### 그림 11-23 투영 후 사각형을 두 개의 삼각형으로 분할하기
![투영 후 사각형을 두 개의 삼각형으로 분할하기](/img/)

예를 들어 자르기 전 삼각형의 정점 배치 순서가 $P_1 \rightarrow P_2 \rightarrow P_3$였다면 [그림 11-23](#그림-11-23-투영-후-사각형을-두-개의-삼각형으로-분할하기)의 두 삼각형은 다음과 같이 정점의 순서를 유지해야 한다.

- 삼각형 1의 순서: $P_{c1} \rightarrow P_2 \rightarrow P_3$
- 삼각형 2의 순서: $P_{c1} \rightarrow P_3 \rightarrow P_{c2}$

[그림 11-24](#그림-11-24-두-점이-카메라-뒤에-위치한-경우)와 같이 두 점이 음의 영역에 위치한 상황을 가정한다.     
두 개의 선분을 만들고 아핀 결합 식을 사용해 $w = 0$ 평면에 위치한 점을 계산할 수 있다.

###### 그림 11-24 두 점이 카메라 뒤에 위치한 경우
![두 점이 카메라 뒤에 위치한 경우](/img/)

두 점이 음의 영역에 있는 경우에는 언제나 삼각형이 만들어지므로, 두 점의 위치 값만 갱신하는 것으로 삼각형을 손쉽게 잘라낼 수 있다.

삼각형의 세 점이 모두 음의 영역에 있다면 해당 삼각형은 시야에 없음을 의미하므로 그리기를 생략하면 된다.     
마지막으로, 삼각형의 세 점이 모두 양의 영역에 있다면 삼각형을 그대로 그리면 된다.

정리하면 동차 좌표계 상에서 삼각형을 분할하는 작업은 다음과 같은 순서로 진행된다.

1. 잘라낼 영역에 몇 개의 점이 속해 있는지 파악한다.
2. 잘라낼 영역에 점이 없으면 삼각형을 그대로 그린다.
3. 잘라낼 영역에 한 점이 속해 있으면 평면과의 교차점을 구하고 교차점으로부터 삼각형을 두 개로 분할한다.
4. 잘라낼 영역에 두 점이 속해 있으면 교차점을 구해 갱신한다.
5. 잘라낼 영역에 세 점이 모두 속해 있으면 그리지 않는다.

이러한 클리핑 규칙은 절두체를 구성하는 모든 평면에 적용할 수 있다.      
[그림 11-23](#그림-11-23-투영-후-사각형을-두-개의-삼각형으로-분할하기)의 결과에 이어서 오른쪽 절두체 영역을 잘라내는 상황을 가정한다.     
1번 삼각형에 대해서 오른쪽 절두체 영역을 잘라낸다면 [그림 11-25](#그림-11-25-오른쪽-평면에-대해-추가로-분할한-삼각형)와 같은 상황이 된다.    
잘라내는 영역에 삼각형의 한 점이 속해 있으므로 해당 삼각형은 다시 두 개로 분할돼야 한다.

###### 그림 11-25 오른쪽 평면에 대해 추가로 분할한 삼각형
![오른쪽 평면에 대해 추가로 분할한 삼각형](/img/)

절두체의 오른쪽 평면은 NDC 좌표의 $x$값이 언제나 1인 평면인데, 이를 클립 좌표계로 표현하면 $\frac{x}{w} = 1$이 되며, 이는 $w = x$를 의미한다.   
삼각형을 잘라내는 평면의 식이 $w = 0$에서 $w = x$로 바뀌었을 뿐 잘라내는 원리는 동일하다.   
앞서 잘라내는 영역을 파악하기 위해 음의 영역, 즉 $w < 0$의 부등식을 사용했는데, 이번 경우에는 잘라내는 영역을 파악하기 위해 다음 식을 사용한다.

$$\frac{x}{w} > 1 \quad \therefore x > w$$

잘라낼 평면 상에 위치한 점의 좌표를 계산하는 방법도 변경된다.       
점 $P_1$과 $P_2$의 $x$값을 각각 $x_1$, $x_2$로 지정하고 잘라내는 점의 $x$값을 $x_{c1}$이라고 할 때 $x_{e1}$을 구하는 수식은 다음과 같다.

###### 식 11-8

$$x_{c1} = x_1(1 - t_1) + x_2t_1$$

이는 $w$값에 대해서도 동일하게 성립된다.

###### 식 11-9

$$w_{c1} = w_1(1 - t_1) + w_2t_1$$

오른쪽 절두체 평면에서는 $x$값과 $w$값이 동일하므로 [식 11-8](#식-11-8)과 [식 11-9](#식-11-9)의 값은 동일하다.

$$w_1(1 - t_1) + w_2t_1 = w_1(1 - t_1) + w_2t_1$$

이 식으로부터 $t_1$값을 구하는 수식은 다음과 같이 정리된다.     
이를 사용해 $w = x$ 평면에 위치한 점 $P_{c1}$과 $P_{c2}$의 좌표를 구할 수 있을 것이다.

$$t_1 = \frac{(w_1 - x_1)}{(w_1 - x_1) - (w_2 - x_2)}$$

이러한 방법으로 절두체를 구성하는 각 평면마다 삼각형 자르기를 진행하면 아무리 큰 삼각형이라도 절두체 영역에 들어맞는 다각형이 만들어진다.       
[그림 11-26](#그림-11-26-절두체에-맞게-삼각형을-잘라낼-각-평면의-방정식)은 절두체의 각 평면에 대한 방정식을 정리한다.   
절두체 영역의 위, 아래를 담당하는 $y$축 평면은 그림에서 생략됐는데, 이들의 방정식은 $w = y$와 $w = -y$이다.

###### 그림 11-26 절두체에 맞게 삼각형을 잘라낼 각 평면의 방정식
![절두체에 맞게 삼각형을 잘라낼 각 평면의 방정식](/img/)

절두체를 구성하는 각 평면의 방정식과 외부 영역에 대한 판별식, 그리고 아핀 결합의 계수를 구하는 수식은 [표 11-1]과 같다.

###### 표 11-1 삼각형 분할을 위한 각 평면의 판별식과 계수

|순서|평면|외부 판별식|아핀 결합의 계수|
|---|---|---|---|
|1|$w = 0$|$w < 0$|$\frac{w_1}{w_1 - w_2}$|
|2|$w = y$|$y > w$|$\frac{(w_1 - y_1)}{(w_1 - y_1) - (w_2 - y_2)}$|
|3|$w = -y$|$y < -w$|$\frac{(w_1 + y_1)}{(w_1 + y_1) - (w_2 + y_2)}$|
|4|$w = x$|$x > w$|$\frac{(w_1 - x_1)}{(w_1 - x_1) - (w_2 - x_2)}$|
|5|$w = -x$|$x < -w$|$\frac{(w_1 + x_1)}{(w_1 + x_1) - (w_2 + x_2)}$|
|6|$w = z$|$z > w$|$\frac{(w_1 - z_1)}{(w_1 - z_1) - (w_2 - z_2)}$|
|7|$w = -z$|$z < -w$|$\frac{(w_1 + z_1)}{(w_1 + z_1) - (w_2 + z_2)}$|

# 42. 복소수
***실수*** 외에도 ***체의 구조***를 가지는 수 집합으로는 ***복소수***가 있다.     
***복소수는 실수와 허수의 두 가지 수로 구성된 집합***이다.    
실수를 시각화할 때 ***1차원의 수직선(Number line)*** 으로 실수를 표현했다면, 복소수는 ***2차원의 평면***으로 표현된다.   
1차원을 넘어선 다차원의 수인 복소수와 복소수 연산의 성질을 이해하는 것은 ***4차원의 수인 사원수***를 이해하는 데 중요한 기반이 된다.

일상적으로 사용하는 대부분의 수는 하나의 값으로 표현하지만, 특이하게 두 개의 값으로 구성되는 수집합이 있다.     
이를 ***복소수(Complex number)*** 라고 하며, 집합 기호는 $C$로 표현한다.   
복소수는 [그림 12-1](#그림-12-1-복소수-집합의-구성)과 같이 ***실수(Real number)*** 와 ***허수(Imaginary number)*** 의 독립된 2개 요소로 구성된 수 집합이다.

###### 그림 12-1 복소수 집합의 구성
![복소수 집합의 구성](/img/)

# 42.1. 허수
복소수 체계에서 ***허수는 실수와 구분된 단위를 가진 특별한 수***다.   
***모든 실수는 제곱하면 0보다 크거나 같은 수가 나온다***.     
그런데 이러한 실수의 정의만으로는 풀리지 않는 문제가 등장하면서 이를 해결하고자 수학자들은 ***제곱해서 음수가 되는 상상의 수***를 고안하기에 이르렀는데, 이것이 바로 허수다.      
복소수 체계에서 실수와 허수는 물과 기름과 같이 완전히 분리된 성질을 가진다.     
이 둘을 구분하기 위해 허수에 $i$라는 기호를 사용하며, 이를 ***허수 단위(Imaginary unit)*** 라 부른다.      
여기서 허수 단위 $i$는 제곱했을 때 -1이 나오는 수를 말한다.

$$i^2 = -1$$

복소수 내에서 서로 완전히 분리된 실수 집합과 허수 집합은 각각 ***실수부(Real part)*** 와 ***허수부(Imaginary part)*** 로 부르고 허수부는 항상 $i$를 사용해 표기한다.      
즉 크기가 $b$인 허수부의 수는 $bi$로 표기해 실수와 구분한다.    
그래서 실수부의 값이 $a$이고 허수부의 값이 $b$인 복소수는 덧셈 기호를 사용해 다음과 같이 표기한다.

$$a + bi$$

또는 다음과 같은 순서쌍으로 표기하기도 한다.    
앞에 위치한 요소 $a$는 실수부, 뒤에 위치한 요소 $b$는 허수부를 의미한다.

$$(a, b)$$

이렇게 복소수를 정의했다면, 여기에 덧셈과 곱셈 연산을 정의해야 실제로 활용할 수 있는 수의 구조를 완성하게 된다.

# 42.2. 복소수의 구조
***복소수의 덧셈은 실수부와 허수부를 구분해 각각 더해주는 방식***이다.    
따라서 두 복소수의 덧셈은 다음과 같이 전개된다.

$$(a + bi) + (c + di) = (a + c) + (b + d)i$$

복소수의 덧셈을 순서쌍으로 표기하면 다음과 같은데 이는 ***2차원 벡터의 덧셈과 동일***하다.

$$(a, b) + (c, d) = (a + c, b + d)$$

순서쌍을 구성하는 $a, b, c, d$는 모두 실수이므로 벡터 덧셈 연산의 성질을 참고해 복소수의 덧셈 연산이 만족하는 성질도 쉽게 파악할 수 있다.   

- 결합법칙: $(a, b) + ((c, d) + (e, f)) = ((a, b) + (c, d)) + (e, f)$
- 교환법칙: $(a, b) + (c, d) = (c, d) + (a, b)$
- 항등원: $(a, b) + (0, 0) = (a, b)$
- 역원: $(a, b) + (-a, -b) = (0, 0)$

###### 표 12-1 복소수 덧셈 연산의 성질

|연산의 성질|만족 여부|
|---|---|
|덧셈에 대해 닫혀 있음|O|
|덧셈에 대한 교환법칙이 성립함|O|
|덧셈에 대한 결합법칙이 성립함|O|
|덧셈에 대한 항등원이 존재함|O|
|덧셈에 대한 역원이 존재함|O|

복소수의 덧셈은 결합법칙, 교환법칙을 만족한다.      
덧셈의 항등원은 $(0, 0)$이며, 임의의 복소수 $(a, b)$에 대한 덧셈의 역원은 $-(a, b)$가 된다.

둘째, 복소수의 곱셈은 모든 요소를 교차해 곱하는 방식으로 동작한다.      
따라서 임의의 두 복소수의 곱셈은 다음과 같이 전개된다.

$$(a + bi) \cdot (c + di) = ac - bd + (ad + bc)i$$

이를 순서쌍으로 나타내면 다음과 같다.

$$(a, b) \cdot (c, d) = (ac - bd, ad + bc)$$

실수가 갖는 체의 성질에 근거해 복소수 곱셈 연산의 성질을 분석하기 위해 순서쌍으로 나타낸 세 복소수 $(a, b), (c, d), (e, f)$를 예로 들어 살펴보자.

- 결합법칙: $(a, b) \cdot ((c, d) \cdot (e, f)) = ((a, b) \cdot (c, d)) \cdot (e, f)$
- 교환법칙: $(a, b) \cdot (c, d) = (c, d) \cdot (a, b)$
- 분배법칙: $(a, b) \cdot ((c, d) + (e, f)) = (a, b) \cdot (c, d) + (a, b) \cdot (e, f)$
- 항등원: $(a, b) \cdot (1, 0) = (a, b)$

###### 표 12-2 복소수 곱셈 연산의 성질

|연산의 성질|만족 여부|
|---|---|
|곱셈에 대해 닫혀 있음|O|
|곱셈에 대한 교환법칙이 성립함|O|
|덧셈과 곱셈에 대한 분배법칙이 성립함|O|
|곱셈에 대한 항등원이 존재함|O|

[표 12-2](#표-12-2-복소수-곱셈-연산의-성질)에서 보듯이 복소수의 곱셈은 결합법칙, 교환법칙, 분배법칙을 만족한다.     
그리고 복소수 곱셈 연산의 항등원 값은 $(1, 0)$이다.

이 중에서 아직 확인할 수 없는 성질은 곱셈의 역원이다.   
복소수 곱셈의 역원을 단순히 실수와 동일한 방식으로 역수를 사용해 $\frac{1}{(a + bi)}$로 표기할 수 있겠지만, 아직 허수를 분모로 하는 체계에 대해 정의하지 않았기 때문에 이대로 표기할 수는 없다.     
그래서 복소수의 곱셈 역원은 다른 방법을 사용하는데, 이를 위해서는 ***켤레 복소수***의 개념을 알아야 한다.

복소수의 크기는 2차원 벡터와 동일하게 실수부와 허수부의 각 요소를 제곱해 더한 다음, 제곱근을 취하는 방식으로 계산한다.      
구한 복소수의 크기는 실수와 동일하게 절댓값 기호 $||$를 써서 나타내며 ***복소수의 노름(Norm)*** 이라고도 부른다.

$$|(a, b)| = |(a, -b)| = \sqrt{a^2 + b^2}$$

특히 크기가 1인 복소수를 ***단위 복소수(Unit complex number)*** 라고 부른다.

복소수의 곱셈 역원을 파악하기 위해 ***두 복소수의 관계를 나타내는 켤레(Conjugate) 복소수***에 대해 알아보자.    
임의의 복소수를 $c$라고 하면 $c$의 켤레 복소수는 * 첨자 기호를 사용한 $c^*$나 $\overline{c}$로 표시한다.    
임의의 복소수 $a + bi$의 켤레 복소수 $c^*$는 다음과 같이 정의할 수 있다.

$$c = a + bi = (a, b)$$

$$c^* = a - bi = (a, -b)$$

켤레 복소수의 기호는 마치 연산처럼 사용할 수 있으며, 다음 성질이 성립한다.

$$(c^*)^* = c$$

$$c^*c = cc^*$$

$$(c_1c_2)^* = c_2^*c_1^*$$

***어떤 복소수에 그 켤레 복소수를 서로 곱하면 해당 복소수의 크기를 제곱한 값을 얻을 수 있다***.

$$cc^* = (a + bi) \cdot (a - bi) = a^2 + b^2 = |c|^2$$

켤레 복소수의 정의와 성질을 파악했다면 복소수 곱셈의 역원을 구한다.     
임의의 복소수 $c$에 대한 곱셈의 역원을 $c^{-1}$라고 할 때, 그 역원의 분모와 분자에 각각 켤레 복소수를 곱한다.

$$c^{-1} = \frac{1}{c} = \frac{c^*}{cc^*}$$

그러면 ***켤레 복소수의 성질에 따라 분모의 허수부가 제거되면서 역원의 표현이 가능해진다***.   
좀 더 구체적으로, 임의의 복소수 $(a, b)$에 대한 곱셈의 역원을 구하는 식을 다시 한번 풀어보면 아래와 같다.

$$(a + bi)^{-1} = \frac{1}{(a + bi)} = \frac{(a - bi)}{(a + bi)(a - bi)} = \frac{(a - bi)}{(a^2 + b^2)}$$

즉 복소수 $c$에 대한 곱셈의 역원 $c^{-1}$는 다음과 같이 켤레 복소수와 복소수 크기에 관한 식으로 나타낼 수 있다.

$$c^{-1} = \frac{c^*}{|c|^2}$$

해당 복소수 크기가 1인 단위 복소수라면 분모의 값은 1이 된다.    
따라서 ***단위 복소수의 곱셈 역원은 바로 켤레 복소수가 된다***.   
이와 같이 복소수에서 곱셈의 역원이 존재함을 확인할 수 있었다.   
따라서 ***복소수 집합은 덧셈과 곱셈에 대해 교환법칙, 결합법칙, 분배법칙이 성립되며 덧셈과 곱셈의 항등원과 역원까지 존재함***을 확인했으므로, ***체의 구조를 만족***한다.

# 43. 복소평면
실수는 수직선이라는 1차원의 직선을 사용해 시각적으로 표현한다.      
복소수는 실수부와 허수부라는 두 개의 독립된 체계를 가졌다.      
이를 시각적으로 나타내려면 직선보다는 확장된 체계를 사용해야 한다.

[그림 12-2](#그림-12-2-실벡터-공간-r2와-복소평면의-비교)의 (a)와 같이 2차원 실벡터 공간 $R^2$의 벡터 $(a, b)$를 표현하기 위해 서로 직교하는 $x$축과 $y$축을 사용한 것처럼, 복소수 역시 $(b)$와 같이 실수부에 해당하는 실수축과 허수부에 해당하는 허수축을 직각으로 교차시키는 방법으로 표현하는데, 이를 ***복소평면(Complex plane)*** 이라고 부른다.

###### 그림 12-2 실벡터 공간 R^2와 복소평면의 비교
![실벡터 공간 R^2와 복소평면의 비교](/img/)

복소평면의 두 축의 이름을 순서대로 실수축$(Re)$와 허수축$(Im)$으로 설정하면 순서쌍으로 표현한 복소수 $(a, b)$는 [그림 12-3](#그림-12-3-복소평면에서의-복소수-표현)과 같이 좌표처럼 평면 상에 표현할 수 있다.

###### 그림 12-3 복소평면에서의 복소수 표현
![복소평면에서의 복소수 표현](/img/)

크기가 1인 ***단위 복소수***를 모아 복소평면에서 표현하면 [그림 12-4](#그림-12-4-복소평면에서의-단위-복소수)와 같이 ***단위원***의 형태가 만들어진다.

###### 그림 12-4 복소평면에서의 단위 복소수
![복소평면에서의 단위 복소수](/img/)

# 43.1. 단위 복소수와의 곱
단위 복소수는 곱셈에 대해 특별한 성질을 만족한다.   
먼저 실수부가 0이고 크기가 1인 복소수 $i$를 예로 들어서 곱셈의 성질을 파악해보자.

허수부가 0인 임의의 복소수 $(a, 0)$에 $i$라는 단위 복소수를 곱하면 다음과 같이 전개된다.

$$(a + 0i) \cdot (0 + i) = (0 + ai) = (0, a)$$

실수 $a$와 허수 $i$와의 곱셈 연산의 결과 $(0, a)$를 복소평면 상에 나타내보면 [그림 12-5](#그림-12-5-a-0과-0-1을-곱한-결과)와 같이 복소수 $(a, 0)$을 $90^\circ$ 회전시킨 결과와 같다.

###### 그림 12-5 (a, 0)과 (0, 1)을 곱한 결과
![(a, 0)과 (0, 1)을 곱한 결과](/img/)

복소수 $(0, a)$에 단위 복소수 $i$를 한 번 더 곱하면, $(-a, 0)$이 나온다.    
$(-a, 0)$에 또 $i$를 곱하면 $(0, -a)$가 나오고, $(0, -a)$에 $i$를 곱하면 $(a, 0)$이 되어 원래 값으로 돌아온다.      
이를 정리하면 [그림 12-6](#그림-12-6-복소수-i를-연속으로-곱한-결과)과 같다.

###### 그림 12-6 복소수 i를 연속으로 곱한 결과
![복소수 i를 연속으로 곱한 결과](/img/)

이로써 임의의 복소수에 단위 복소수 $i$를 곱한 결과는 해당 복소수를 $90^\circ$ 회전시킨 결과와 같음을 유추할 수 있다.    
즉 임의의 복소수 $(a, b)$에 복소수 $i$를 곱한 결과는 항상 실수부와 허수부의 값이 바뀌어 다음과 같은 식으로 표현된다.

$$(a, b) \cdot (0, 1) = (-b, a)$$

이는 좌표 평면에서의 $90^\circ$ 회전과 동일한 좌표값을 만들어낸다.      
따라서 임의의 복소수에 복소수 $i$를 곱하면 항상 복소평면 상에서 $90^\circ$ 회전을 한다고 볼 수 있다.

삼각함수의 공식 $\cos^2\theta + \sin^2\theta = 1$을 이용해 단위원을 형성하는 임의의 단위 복소수 $(a, b)$를 다음과 같이 삼각함수로 표현해볼 수 있다.

###### 식 12-1

$$(a, b) = \cos \theta + i \sin \theta = (\cos \theta, \sin \theta)$$

> 참고: ***복소수의 표기***     
복소수를 표기하는 방법은 $a + bi$와 $a + ib$ 두 가지 방식이 있다.   
$a$와 $b$에 삼각함수를 사용하는 경우에는 일반적으로 $a + ib$ 방식을 사용한다.   
따라서 [식 12-1](#식-12-1)은 $\cos \theta + i \sin \theta$로 표기한다.

이와 같이 삼각함수로 나타낸 단위 복소수에 임의의 복소수 $(x, y)$를 곱하면 복소수의 곱셈 식은 다음과 같이 전개된다.  

$$(\cos \theta, \sin \theta) \cdot (x, y) = (x \cos \theta - y \sin \theta, y \cos \theta + x \sin \theta)$$

이는 2차원 공간의 회전행렬 $R$에 2차원 벡터 $(x, y)$를 곱한 결과와 같다.    

$$R = 
\begin{bmatrix}
\cos \theta & -\sin \theta \\
\sin \theta & \cos \theta \\
\end{bmatrix}
$$

$$
\begin{bmatrix}
\cos \theta & -\sin \theta \\
\sin \theta & \cos \theta \\
\end{bmatrix}
\begin{bmatrix}
x \\
y \\
\end{bmatrix} = 
\begin{bmatrix}
x \cos \theta - y \sin \theta \\
x \sin \theta + y \cos \theta \\
\end{bmatrix}
$$

따라서 ***임의의 복소수에 단위 복소수를 곱하는 것은 복소평면에서의 회전 변환을 의미***한다.

###### 그림 12-7 복소수를 회전시키는 단위 복소수와의 곱셈
![복소수를 회전시키는 단위 복소수와의 곱셈](/img/)

서로 다른 각을 갖는 2개의 단위 복소수를 곱한 결과를 살펴보자.

$$(\cos \alpha, \sin \alpha) \cdot (\cos \beta, \sin \beta) = (\cos \alpha \cos \beta - \sin \alpha \sin \beta, \sin \alpha \cos \beta + \sin \beta \cos \alpha)$$

이 식은 삼각함수의 덧셈 정리에 의해 다음과 같이 간단하게 표기된다.

$$(\cos(\alpha + \beta), \sin(\alpha + \beta))$$

이로써 ***서로 다른 두 각을 회전 변환한 후 곱셈 연산을 하는 것은 두 각의 합을 회전 변환하는 것과 동일함***을 확인할 수 있다.  

복소수 곱셈의 항등원 $(1, 0)$의 의미를 생각해보자.     
***복소수 곱셈의 항등원은 실수에서의 곱셈의 항등원과 동일하게 1이다***.       
복소수 1 역시 ***단위 복소수***로서, 이를 삼각함수로 표현하면 다음과 같이 각 $0^\circ$에 대응하는 수다.

$$(1, 0) = (\cos 0^\circ, \sin 0^\circ)$$

따라서 ***곱셈의 항등원을 곱한다는 의미는 아무런 변화가 일어나지 않는*** $0^\circ$***의 회전 변환이라 해석할 수 있다***.    
***실수에서 크기가 1인 수는 오직 1과 -1 두 가지만 존재한다***.    
이 두 수를 한 차원 높은 복소수에서 바라보면 각각은 $(1, 0)$과 $(-1, 0)$에 대응되고, 이들과의 곱은 각각 $0^\circ$와 $180^\circ$의 회전 변환으로 해석할 수 있는 것이다.

# 43.2. 켤레 복소수의 회전 변환
복소평면에서 켤레 복소수의 의미를 시각적으로 해석해보자.    
임의의 복소수 $(a, b)$의 켤레 복소수는 $(a, -b)$이다.   
어떤 복소수와 그 켤레 복소수를 복소평면에 나타내면 [그림 12-8](#그림-12-8-복소평면에서-켤레-복소수의-표현)과 같다.

###### 그림 12-8 복소평면에서 켤레 복소수의 표현
![복소평면에서 켤레 복소수의 표현](/img/)

***임의의 복소수와 그 켤레 복소수는 실수부 축***$(Re)$***을 중심으로 서로 대칭된 형태를 이룬다***.
 
단위 복소수를 $(\cos \theta, \sin \theta)$라고 표현할 때 이의 켤레 복소수는 $(\cos \theta, -\sin \theta)$가 된다.   
여기서 ***삼각함수의 성질***을 활용하면 켤레 복소수는 다음과 같이 표현할 수 있다.

$$(\cos \theta, -\sin \theta) = (\cos(-\theta), \sin(-\theta))$$

단위 복소수가 [그림 12-9](#그림-12-9-단위-복소수와-그-켤레-복소수)와 같이 실수 축에 위치한 단위 복소수 $(1, 0)$을 각 $\theta$만큼 회전한 수를 의미한다면, 켤레 복소수는 반대 방향인 $-\theta$만큼 회전한 수를 의미한다.

###### 그림 12-9 단위 복소수와 그 켤레 복소수
![단위 복소수와 그 켤레 복소수](/img/)

임의의 복소수 $(a, b)$에 단위 복소수를 곱하면 [그림 12-10](#그림-12-10-복소수에-단위-복소수를-곱한-결과와-그-켤레를-곱한-결과와의-비교)의 보라색의 궤적을 따라 반시계 방향의 회전이 발생하는 데 반해, 단위 복소수의 켤레 복소수를 곱하면 청록색의 궤적을 따라 시계 방향의 회전이 발생한다.

###### 그림 12-10 복소수에 단위 복소수를 곱한 결과와 그 켤레를 곱한 결과와의 비교
![복소수에 단위 복소수를 곱한 결과와 그 켤레를 곱한 결과와의 비교](/img/)

단위 복소수와 그 켤레 복소수를 곱한 값은 복소수의 크기의 제곱이므로 1이 된다.

$$c \cdot c^* = a^2 + b^2 = \sin^2\theta + \cos^2\theta = 1$$

이 식을 변환의 관점에서 해석하면 각 $\theta$만큼 회전한 후에 바로 $-\theta$만큼 거꾸로 회전하는 변환을 의미한다.    
이 결과는 아무런 회전도 일어나지 않는 $0^\circ$ 회전 변환을 의미하므로 복소수 곱셈의 항등원 $(1, 0)$이 됨을 다시 한번 확인할 수 있다.

# 44. 복소수와 행렬의 관계
***복소수를 수의 관점이 아닌 변환의 관점에서 바라본다면 2차원 복소평면 상의 복소수는 2차원 행렬에 대응할 수 있다***.      
회전을 수행하는 단위 복소수와 2차원의 회전 변환행렬이 동일하다고 가정하고 수식을 전개하면 다음과 같다.

$$\cos \theta + i \sin \theta = 
\begin{bmatrix}
\cos \theta & -\sin \theta \\
\sin \theta & \cos \theta \\
\end{bmatrix}
$$

회전 변환행렬을 $\cos \theta$와 $\sin \theta$에 대해 분리해 정리하면 다음과 같다.

$$\cos \theta + i \sin \theta =
\cos \theta \cdot 
\begin{bmatrix}
1 & 0 \\
0 & 1 \\
\end{bmatrix}
+ \sin \theta \cdot
\begin{bmatrix}
0 & -1 \\
1 & 0 \\
\end{bmatrix}
$$

실수부에 대응하는 행렬을 $I$로, 허수 $i$에 대응되는 행렬을 $J$라고 정의한다.

$$I = 
\begin{bmatrix}
1 & 0 \\
0 & 1 \\
\end{bmatrix}
$$

$$J = 
\begin{bmatrix}
0 & -1 \\
1 & 0 \\
\end{bmatrix}
$$

실수부에 대응하는 ***행렬*** $I$***는 어떤 수에 곱했을 때 아무 변화가 없는 항등행렬임을 알 수 있는데, 이는 곱셈의 항등원*** $1$***과 동등한 개념이다***.      
한편 ***허수*** $i$***에 대응하는 행렬*** $J$***는*** $90^\circ$ ***회전 변환행렬인데 이를 두 번 곱하면*** $-I$***가 나오며, 이는*** $-1$***에 대응한다고 볼 수 있다***.

$$J \cdot J = 
\begin{bmatrix}
-1 & 0 \\
0 & -1 \\
\end{bmatrix} = 
-I$$

이는 ***두 번 곱하면*** $-1$***이 나오는 허수 단위의 성질과도 일치***한다.

$$i \cdot i = -1$$

# 45. 자연지수함수
1748년 스위스 수학자 ***레온하르트 오일러(Leonhard Euler)*** 는 실수와 허수와의 관계에서 더 나아가 삼각함수와 자연지수함수와의 관계를 나타내는 ***오일러 공식(Euler's formula)*** 을 발표했다.    
오일러 공식은 현대 디지털 문명에 필수적인 전기공학의 ***신호 처리(Signal processing)*** 분야의 기반이 되는 중요한 공식이며, 게임 그래픽 분야에서도 ***3차원 공간의 회전 문제를 해결***하는 데 징검 다리 역할을 수행해주는 유용한 공식이다.

무리수 $e$와 허수 단위 $i$, 그리고 삼각함수와의 관계를 이용해 나타낸 오일러 공식은 다음과 같다.

$$e^{i\theta} = \cos\theta + i\sin\theta$$

오일러 공식을 이해하려면 좌변의 자연지수함수 $f(x) = e^x$와 우변에 있는 두 삼각함수 $\sin$ 함수와 $\cos$ 함수의 미분을 이해하고, 이들을 급수로 표현하는 과정을 알아야 한다.     
먼저 좌변에 위치한 자연지수함수를 이해하기 위해서는 이의 밑을 이루는 특별한 상수 $e$에 대해 알아야 한다.    
이 상수를 무리수 $e$라 한다.

# 45.1. 무리수 e
무리수 $e$는 1683년도에 스위스 수학자 ***야코프 베르누이(Jakob Bernoulli)*** 가 은행의 복리 이자를 연구하던 중에 발견됐다.     
야코프 베르누이는 [식 13-1](#식-13-1)을 사용해 복리로 얻을 수 있는 수익을 연구했는데, [식 13-1](#식-13-1)에서 굉장히 큰 값을 $x$값에 대입할수록 이의 결괏값은 특정 상수에 근접한다는 사실을 알아내게 되었다.

###### 식 13-1

$$y = (1 + \frac{1}{x})^x$$

실제로 [식 13-1](#식-13-1)의 $x$에 [표 13-1](#표-13-1-y--1--1x2-함수의-x값을-증가시켜-대입한-결과)과 같이 양의 실수를 대입해보면 $x$값이 증가하면 $y$값도 증가한다.   
그런데 $x$값이 증가할수록 $y$값의 증가량은 서서히 줄어드는데, $x$가 굉장히 커질수록 2와 3사이에 있는 어떤 특정한 수에 근접하게 된다.

###### 표 13-1 y = (1 + 1/x)^2 함수의 x값을 증가시켜 대입한 결과
|x값|y값|
|---|---|
|1|$(1 + 1)^1 = 2$|
|2|$(1 + \frac{1}{2})^2 = 2.25$|
|3|$(1 + \frac{1}{3})^3 = 2.370370...$|
|100|$(1 + \frac{1}{100})^100 = 2.704813...$|
|10000|$(1 + \frac{1}{10000})^10000 = 2.7181459...$|
|1000000|$(1 + \frac{1}{1000000})^1000000 = 2.718280469...$|

이 함수의 변화를 그래프로 그리면 [그림 13-1](#표-13-1-y--1--1x2-함수의-x값을-증가시켜-대입한-결과)과 같이 전개되는데, $x$가 굉장히 커졌을 때 $y$값은 약 $2.7182818...$에 근접한다.    
이 수를 무리수 $e$라고 부른다.

###### 그림 13-1 y = (1 + 1/x)^x의 그래프
![y = (1 + 1/x)^x의 그래프](/img/)

> 참고: ***e의 표현에 대하여***     
무리수 e는 '오일러 상수 e', '상수 e', '자연 상수' 등 다양한 용어로 불리고 있다.     
대한수학회의 공식 명칭은 '자연로그의 밑(Base of the natural logarithm)'이다.    
영문권에서는 오일러의 수(Euler's number)로도 불린다.    
무리수 e가 상수라는 사실은 베르누이가 처음 발견했으나, 이 상수를 적극적으로 연구하고 e라는 이름을 붙인 수학자는 레온하르트 오일러였기 때문이다.

이러한 무리수 $e$는 극한(Limit)과 무한대($\infty$)의 개념을 사용해 [식 13-2](#식-13-2)로 표현할 수 있다.

###### 식 13-2

$$e = \lim_{x \rightarrow \infty}(1 + \frac{1}{x})^x$$

$\infty$로 표시하는 ***무한대(Infinity)*** 란 특정한 수를 가리키는 것이 아니고, 어떤 실수보다도 큰 상태를 의미한다.    
그리고 극한이란 어떤 값 $x$가 지정한 값 $a$에 한없이 가까워질 때 함수 $f(x)$가 한없이 가까워지는 값 $L$을 의미하며, 이는 다음의 수식으로 표현한다.

$$L = \lim_{x \rightarrow a}f(x)$$

극한의 결괏값이 특정한 값에 한없이 가까워진다면 이를 어떤 값에 ***수렴한다(Converge)*** 고 표현한다.   
반면에 극한의 결괏값이 특정한 값에 수렴하지 않고 무한대로 증가하거나 여러 값들을 오고가면 ***발산한다(Diverge)*** 고 표현한다.     
따라서 [식 13-2](#식-13-2)에서 함수 $(1 + \frac{1}{x})^x$에 사용하는 입력이 한없이 크면 그 결과는 무리수 $e$로 수렴한다고 설명할 수 있다.   

# 45.2. 자연지수함수
자연지수함수를 알아보기 앞서 지수의 개념에 대해 알아야한다.     
같은 수를 여러 번 곱하는 작업을 ***거듭제곱(Exponenetiation)*** 이라 하는데, 거듭제곱에서 곱하는 횟수를 ***지수(Exponent)*** , 곱하는 수는 ***밑(Base)*** 이라고 부른다.     
예를 들어 3을 5번 거듭제곱한 식은 다음과 같이 지수와 밑을 사용해 $3^5$으로 짧게 표기한다.

$$3^5 = 3 \cdot 3 \cdot 3 \cdot 3 \cdot 3$$

거듭제곱을 구성하는 밑과 지수가 가지는 연산의 특징을 ***지수법칙(Law of exponents)*** 이라고 한다.     
무리수 $e$를 밑으로 다루는 거듭제곱에 대해 알아야 하는데, 0보다 큰 수 무리수 $e$에 통용되는 3가지 지수법칙을 살펴보자.

1. 밑이 같은 거듭제곱 간의 곱셈은 지수를 더한 거듭제곱과 동일하다.

$$a^m \cdot a^n = a^{m + n}$$

2. 거듭제곱의 거듭제곱은 지수를 곱한 거듭제곱과 동일하다.

$$(a^m)^n = a^{m \cdot n}$$

거듭제곱의 개념은 수를 세는 자연수에서 비롯됐지만, ***자연수가 아닌 0으로도 확장이 가능***하다.   
곱셈의 항등원 1을 활용해 0의 거듭제곱의 값은 다음과 같이 유도할 수 있다.

$$a^m = a^{(m + 0)} = a^m \cdot a^0 = a^m \cdot 1$$

따라서 다음과 같은 세 번째 지수법칙이 성립한다.

3. 지수가 0인 거듭제곱은 항상 1의 값을 갖는다.

$$a^0 = 1$$

이러한 거듭 제곱의 지수에 미지수 $x$를 대입해 만든 함수를 ***지수함수(Exponential function)*** 라고 하며 밑이 $a$인 지수함수는 다음과 같이 표시한다.

$$f(x) = a^x$$

앞서 살펴본 지수 법칙에 따라 지수함수의 $x$값이 0이면 출력은 항상 1이 된다.     
그러므로 밑이 0보다 큰 지수함수의 그래프는 언제나 좌표 $(0, 1)$을 지난다.   
그리고 다음과 같이 무리수 $e$를 밑으로 하는 지수함수를 다음과 같이 ***자연지수함수(Natural exponential function)*** 라고 정의한다. 

$$f(x) = e^x$$

자연지수함수 $y = e^x$는 언제나 $(0, 1)$을 지나며 그래프를 그려보면 [그림 13-2](#그림-13-2-자연지수함수의-그래프)와 같이 $x$가 커질수록 급격히 증가하는 형태를 띤다.

###### 그림 13-2 자연지수함수의 그래프
![자연지수함수의 그래프](/img/)

# 46. 미분
***미분(Differentiation)*** 은 ***미분 가능한 함수를 대상으로 특정 지점에서의 접선의 기울기를 측정하는 작업***을 의미한다.   
고교 교육과정에서는 미분 가능한 함수를 뾰족점이 없이 끊이지 않고 연속으로 이어져 있는 함수로 소개한다.  
미분을 적용할 ***자연지수함수,*** $\sin$ ***함수,*** $\cos$ ***함수도 모두 미분 가능한 함수다***.     

미분을 진행하기 위해서는 ***접선의 기울기***가 무엇인지 알아야 한다.      
[그림 13-3](#그림-13-3-할선의-개념)과 같이 어떤 미분 가능한 함수가 주어졌을 때 $x$값 $a$와 $b$에 대응되는 두 좌표를 연결해 직선을 만든다.   
이를 ***할선(Secant line)*** 이라고 한다.

###### 그림 13-3 할선의 개념
![할선의 개념](/img/)

할선의 기울기는 다음과 같이 구할 수 있다.

###### 식 13-3

$$m = \frac{f(b) - f(a)}{b - a}$$

여기서 $a$를 고정시킨 상태에서 $b$를 서서히 $a$로 이동시킨다고 가정한다.    
$b$를 $a$로 이동시킴에 따라 할선의 기울기는 [그림 13-4](#그림-13-4-b가-a로-이동함에-따른-할선의-변화)와 같이 시시각각 변화한다.

###### 그림 13-4 b가 a로 이동함에 따른 할선의 변화
![b가 a로 이동함에 따른 할선의 변화](/img/)

$b$ 값이 왼쪽으로 이동해 $a$에 도달하면 [식 13-3](#식-13-3)의 분모 값은 0이 되어 할선은 더 이상 존재하지 않게 된다.     
하지만 [그림 13-5](#그림-13-5-a에-한없이-가까운-b가-만들어내는-접선)와 같이 $b$가 $a$에 한없이 가깝게 접근했다면, 할선은 여전히 존재하며, 마치 $a$ 지점에서의 기울기처럼 보인다.      
이렇게 ***한없이 가까워지는 개념을 사용해 특정 지점에서의 기울기를 나타내는 선***을 ***접선(Tangent line)*** 이라고 한다.

###### 그림 13-5 a에 한없이 가까운 b가 만들어내는 접선
![a에 한없이 가까운 b가 만들어내는 접선](/img/)

접선의 개념은 무리수 $e$에서 언급한 극한의 한없이 가까워지는 성질과 동일하다.   
따라서 $b$가 $a$로 한없이 가까워질 때 접선의 기울기 $m$ 값은 [식 13-3](#식-13-3)에 극한을 적용해 다음과 같이 계산한다.

###### 식 13-4

$$m = \lim_{b \rightarrow a} \frac{f(b) - f(a)}{b - a}$$

[식 13-4](#식-13-4)에서 $a$에 한없이 가까워진 $b$ 값은 $a$에서 한없이 작은 값 $h$를 더한 값과 같다.     
따라서 이 식에서 $f(b)$의 값을 $f(a + h)$로 바꾸고 $b - a$를 $h$로 바꾸면 [식 13-4](#식-13-4)의 접선식은 [식 13-5](#그림-13-5-a에-한없이-가까운-b가-만들어내는-접선)로 바꿔 표현할 수 있다.

###### 식 13-5

$$m = \lim_{h \rightarrow 0} \frac{f(a + h) - f(a)}{h}$$

이 값을 $a$에서의 ***미분 계수(Differential coefficient)*** 라고 한다.

# 46.1. 도함수
***미분 계수는 주어진 값에 대한 접선의 기울기를 의미***한다.  
함수가 모든 구간에서 미분이 가능하다면 이 개념을 확대해 임의의 수에 대해 미분 계수를 구할 수 있는 수식이 만들어질 것이다.       
이렇게 임의의 수 $x$에 대한 미분 계수를 구할 수 있도록 일반화한 함수를 ***도함수(Derivative)*** 또는 ***미분*** 이라고 한다.     
함수 $f(x)$의 도함수는 기호 $f'(x)$로 표시한다.

> 참고: ***미분의 뜻***     
미분은 ***도함수를 계산하는 작업(Differentiation)*** 과 ***도함수(Derivative)*** 두 가지 의미를 가진다.      
보통은 후자인 도함수를 의미하는 경우가 많다.

임의의 수 $a$에서의 미분 계수를 구하는 데 사용한 [식 13-5](#식-13-5)를 임의의 수 $x$에 대해 정리한 도함수 식은 [식 13-6](#식-13-6)과 같다.

###### 식 13-6

$$f'(x) = \lim_{h \rightarrow 0} \frac{f(x + h) - f(x)}{h}$$

이 식으로부터 다양한 함수의 도함수를 구할 수 있는데, 목표는 자연지수함수, $\sin$ 함수, $\cos$ 함수에 대한 도함수를 계산하는 것이다.     
이 함수의 도함수를 계산하려면 먼저 극한이 가지는 성질에 대해 알아야 한다.

정의역과 무관하게 항상 일정한 값을 가지는 함수를 ***상수함수***라고 하는데 일정한 값 $c$의 상수함수는 다음의 수식으로 나타낸다.

$$f(x) = c$$

상수함수의 그래프는 [그림 13-6](#그림-13-6-상수함수-y--c)과 같이 $x$축과 수평한 선의 형태를 띤다.

###### 그림 13-6 상수함수 y = c
![상수함수 y = c](/img/)

[그림 13-6](#그림-13-6-상수함수-y--c)에서 볼 수 있듯이 상수함수는 모든 정의역의 원소에 대해 항상 상수 $c$가 나온다.   
따라서 [식 13-6](#식-13-6)의 도함수를 계산하면 그 결과는 언제나 0이 된다.   
이는 상수함수의 모든 $x$에 대한 접선의 기울기가 0임을 뜻한다.

$$\lim_{h \rightarrow 0}\frac{f(x + h) - f(x)}{h} = \lim_{h \rightarrow 0}\frac{c - c}{h} = \lim_{h \rightarrow 0}\frac{0}{h} = 0$$

이와 더불어 자연지수함수와 삼각함수의 도함수를 전개하기 위해 알아둬야 할 6가지 극한의 성질은 다음과 같다.

- 극한의 성질 1: 두 함수 합의 극한값은 각 극한값의 합과 같다.

$$\lim_{x \rightarrow a}[f(x) + g(x)] = \lim_{x \rightarrow a}f(x) + \lim_{x \rightarrow a}g(x)$$

- 극한의 성질 2: 상수와 함수 곱의 극한값은 함수 극한값에 상수를 곱한 것과 같다.

$$\lim_{x \rightarrow a}cf(x) = c\lim_{x \rightarrow a}f(x)$$

- 극한의 성질 3: 두 함수 곱의 극한값은 각 극한값의 곱과 같다.

$$\lim_{x \rightarrow a}[f(x) \cdot g(x)] = \lim_{x \rightarrow a}f(x) \cdot \lim_{x \rightarrow a}g(x)$$

- 극한의 성질 4: 두 함수 나눗셈의 극한값은 각 극한값의 나눗셈과 동일하다.       
단 분모의 극한값은 0이 아니어야 한다.

$$\lim_{x \rightarrow a}[\frac{f(x)}{g(x)}] = \frac{\lim_{x \rightarrow a}f(x)}{\lim_{x \rightarrow a}g(x)}$$

- 극한의 성질 5: 함수를 거듭제곱한 극한값은 극한값을 거듭제곱한 값과 같다.

$$\lim_{x \rightarrow a}[f(x)]^n = [\lim_{x \rightarrow a}f(x)]^n$$

- 극한의 성질 6: 세 함수의 대소 관계가 $g(x) \leq f(x) \leq h(x)$와 같을 때 양변 $g(x)$와 $h(x)$의 극한값이 같다면 가운데 위치한 함수 $f(x)$의 극한값도 같다.   
즉 $\lim_{x \rightarrow a}g(x) = \lim_{x \rightarrow a}h(x) = L$이면 $\lim_{x \rightarrow a}f(x) = L$이 성립한다.   
이를 ***조임 정리(Squeeze theorem)*** 라고 한다.

극한의 성질을 숙지했다면 이를 활용해 거듭제곱 함수의 도함수에 대해 알아보자.    
일반적으로 많이 사용하는 다음과 같은 거듭제곱 함수의 도함수를 구한다.

$$f(x) = x^n$$

$n$이 자연수라고 가정하면 거듭제곱 함수의 도함수는 다음과 같은 과정을 통해 구할 수 있다.

$$
\begin{matrix}
f'(x) &=& \lim_{h \rightarrow 0} \frac{(x + h)^n - x^n}{h} \\
&=& \lim_{h \rightarrow 0} \frac{(x^n + nx^{n - 1}h + ... + nxh^{n - 1} + h^n) - x^n}{h} \\
&=& \lim_{h \rightarrow 0} \frac{h(nx^{n - 1} + ... + nxh^{n - 1} + h^{n - 1})}{h} \\
&=& n \cdot \lim_{h \rightarrow 0}(x^{n - 1} + ... + xh^{n - 2} + h^{n - 1}) \\
&=& n \cdot x^{n - 1} \\
\end{matrix}
$$

1. 분자의 $(x + h)^n$를 풀어 전개한다.
2. 첫 항 $x^n$은 소거되고, 남은 항을 $h$로 묶는다.
3. 분자와 분모가 소거된 식을 $n$으로 묶는다.
4. 극한에 의해 $h$가 있는 항들은 모두 0에 한없이 가까워진다. 따라서 $x^{n - 1}$만 남는다.

이로써 거듭제곱 함수 $f(x) = x^n$의 도함수는 다음과 같이 전개됨을 알 수 있다.

###### 식 13-7

$$f'(x) = n \cdot x^{n - 1}$$

# 46.2. 자연지수함수의 도함수
***자연지수함수*** $f(x) = e^x$***의 도함수는 다음과 같이 원함수와 동일하다는 특징을 가진다***.

$$f'(x) = e^x$$

이의 극한을 구하기 전에 무리수 $e$의 극한식으로부터 다음 수식을 유도한다.

###### 식 13-8

$$\frac{\lim_{h \rightarrow 0}(e^h - 1)}{\lim_{h \rightarrow 0}h} = 1$$

[식 13-2](#식-13-2)에서 한없이 커지는 $x$를 $\frac{1}{h}$로 바꾸면 $\frac{1}{h}$는 0으로 수렴하고 무리수 $e$의 극한식은 다음과 같이 바꿔쓸 수 있다.

$$e = \lim_{h \rightarrow 0}(1 + h)^{\frac{1}{h}}$$

여기서 좌변에도 극한을 취한다.      
이 경우 $e$는 $h$와 관련없는 상수이므로 다음과 같이 극한을 대입해도 그 결과는 동일하다.

$$\lim_{h \rightarrow 0}e = \lim_{h \rightarrow 0}(1 + h)^{\frac{1}{h}}$$

극한의 성질 5를 사용해 양변에 $h$승을 적용하면 다음과 같이 바꿀 수 있다.

$$\lim_{h \rightarrow 0}e^h = \lim_{h \rightarrow 0}(1 + h)$$

우변의 극한식은 극한의 성질 1에 의해 다음과 같이 분리된다.

$$\lim_{h \rightarrow 0}e^h = \lim_{h \rightarrow 0}1 + \lim_{h \rightarrow 0}h$$

여기서 분리된 상수함수항을 좌변으로 옮기면 다음과 같다.

$$\lim_{h \rightarrow 0}(e^h - 1) = \lim_{h \rightarrow 0}h$$

이로써 [식 13-8](#식-13-8)이 성립함을 알 수 있다.   
[식 13-8](#식-13-8)을 활용해 자연지수함수의 도함수를 구해보자.      
[식 13-6](#식-13-6)에 자연지수함수 $f(x) = e^x$를 대입해 전개하면 다음과 같다.

$$
\begin{matrix}
f'(x) &=& \lim_{h \rightarrow 0}\frac{e^{x + h} - e^x}{h} \\
&=& \lim_{h \rightarrow 0}\frac{e^x \cdot e^h - e^x}{h} \\
&=& \lim_{h \rightarrow 0}\frac{e^x(e^h - 1)}{h} \\
&=& e^x \cdot \lim_{h \rightarrow 0}\frac{e^h - 1}{h} \\
&=& e^x \cdot \frac{\lim_{h \rightarrow 0}(e^h - 1)}{\lim_{h \rightarrow 0}h} \\
&=& e^x
\end{matrix}
$$

1. 지수법칙을 사용해 분리한다.
2. $e^x$로 묶어준다.
3. $h$와 관련없는 $e^x$는 상수로 취급할 수 있으므로 극한의 성질 2를 사용해 극한식 밖으로 빼낸다.
4. 극한의 성질 4를 사용해 분모와 분자를 각각 극한값으로 분리한다.
5. [식 13-8](#식-13-8)에 의해 극한값은 1로 수렴한다.

이로써 ***자연지수함수의 도함수는 원함수와 동일함***을 확인할 수 있다.

$$f'(x) = e^x = f(x)$$

함수를 미분했을 때 그 결과가 원함수와 동일하다면 그 함수는 몇 번을 미분하더라도 그 결과는 언제나 원함수와 동일하게 유지된다.    
따라서 ***자연지수함수는 무한번 미분 가능하다***는 성질을 가진다.

# 46.3. sin 함수와 cos 함수의 도함수
삼각함수의 $\sin$ 함수와 $\cos$ 함수의 도함수를 구하기에 앞서 다음 극한식을 유도한다.

###### 식 13-9

$$\lim_{h \rightarrow 0}\frac{\sin h}{h} = 1$$

[식 13-9](#식-13-9)는 원과 부채꼴의 넓이를 구하는 공식으로부터 유도할 수 있다.      
***원(Circle)*** 의 넓이 $Area(C)$를 구하는 공식은 다음과 같다.

$$Area(C) = \pi \cdot r^2$$

원을 구성하는 각은 $2\pi$이므로 1(rad)에 해당하는 ***부채꼴(Circular Sector)*** 의 넓이는 $\pi r^2$에서 $2\pi$를 나눈 $\frac{1}{2}r^2$이 된다.     
부채꼴의 넓이는 각의 크기에 비례해 커지므로 중심각이 $\theta$(rad)인 부채꼴의 넓이 $Area(CS)$는 다음과 같다.

###### 식 13-10

$$Area(CS) = \frac{\theta}{2}r^2$$

> 주의:     
각의 범위를 실수 전 영역으로 사용하면 [식 13-10](#식-13-10)은 음수가 나올 수 있다.      
그런데 측정량인 넓이는 음수가 나올 수 없으므로, 일반적으로 [식 13-10](#식-13-10)에 절댓값을 취해줘야 한다.

[그림 13-7](#식-13-7)과 같이 원점 $O$를 중심으로 반지름이 1이고 중심각이 $\theta$(rad)인 부채꼴의 넓이는 $\frac{\theta}{2}$가 됨을 알 수 있다.    
이 부채꼴의 이름을 $CS_1$으로 지정하면 넓이는 다음과 같다.

$$Area(CS_1) = \frac{\theta}{2}$$

###### 그림 13-7 반지름이 1이고 중심각이 세타인 부채꼴의 넓이
![반지름이 1이고 중심각이 세타인 부채꼴의 넓이](/img/)

[그림 13-8](#그림-13-8-부채꼴에-포함된-삼각형-oab의-넓이)과 같이 부채꼴 $CS_1$ 내부에 들어가는 삼각형 $T$를 만든다.   
부채꼴의 점 $A$에서 수선을 내려 밑변에 닿는 점을 $B$라고 하면, 밑변의 길이는 1이고 높이에 해당하는 선분 $\overline{AB}$의 길이는 $\sin\theta$가 되어 $T$의 넓이는 다음과 같이 계산된다.

$$Area(T) = \frac{\sin\theta}{2}$$

###### 그림 13-8 부채꼴에 포함된 삼각형 OAB의 넓이
![부채꼴에 포함된 삼각형 OAB의 넓이](/img/)

[그림 13-9](#그림-13-9-삼각형에-포함된-부채꼴의-넓이)와 같이 선분 $\overline{OB}$를 반지름으로 하는 작은 부채꼴 $CS_2$을 만든다.     
작은 부채꼴 $CS_2$의 영역은 언제나 삼각형 내부에 속하게 된다.   
선분 $\overline{OB}$의 길이는 $\cos\theta$이므로 이를 반지름으로 하는 부채꼴 $CS_2$의 넓이는 [식 13-10](#식-13-10)에 의해 다음과 같이 계산된다.

$$Area(CS_2) = \frac{\theta}{2} \cdot \cos^2 \theta$$

###### 그림 13-9 삼각형에 포함된 부채꼴의 넓이
![삼각형에 포함된 부채꼴의 넓이](/img/)

부채꼴에 관련된 세 영역의 넓이 $Area(CS_1)$, $Area(T)$, $Area(CS_2)$를 구하는 공식은 다음과 같은 대소 관계가 성립된다.

$$\frac{\theta}{2} \cdot \cos^2 \theta \leq \frac{\sin \theta}{2} \leq \frac{\theta}{2}$$

여기서 넓이 $Area(CS_1)$의 역수 $\frac{2}{\theta}$를 곱해 부등식을 정리하면 다음과 같다.

$$\cos^2\theta \leq \frac{\sin\theta}{\theta} \leq 1$$

$\theta$를 $h$로 변경한 후 우변의 극한값 $\lim_{h \rightarrow 0}1$과 좌변의 극한값 $\lim_{h \rightarrow 0}\cos^2 h$를 구한다.

$$\lim_{h \rightarrow 0}\cos^2 h \leq \lim_{h \rightarrow 0}\frac{\sin h}{h} \leq \lim_{h \rightarrow 0}1$$

우변의 극한값 $\lim_{h \rightarrow 0}1$은 상수이므로 바로 1임을 확인할 수 있다.

좌변 $\lim_{h \rightarrow 0}\cos^2h$의 $\cos$ 함수는 각이 0도 수렴할 수록 그 값은 1에 수렴한다.     
따라서 이를 제곱한 극한값 역시 1에 수렴한다.        
극한의 성질 6으로 정리한 극한의 조임 정리에 의해 좌우의 극한값이 동일한 경우 가운데에 위치한 $\frac{\sin h}{h}$의 극한값 또한 1이 되어 [식 13-9](#식-13-9)가 성립함을 확인할 수 있다.       
여기에 추가로 알아두면 좋은 함수의 극한값은 다음과 같다.

###### 식 13-11

$$\lim_{h \rightarrow 0}\frac{\cos h - 1}{h} = 0$$

[식 13-11](#식-13-11)은 다음 과정을 거쳐서 유도된다.

$$
\begin{matrix}
\lim_{h \rightarrow 0}\frac{\cos h - 1}{h} &=& \lim_{h \rightarrow 0}\frac{(\cos h -1) \cdot (\cos h + 1)}{h \cdot (\cos h + 1)} \\
&=& \lim_{h \rightarrow 0}\frac{\cos^2 h - 1}{h \cdot (\cos h + 1)} \\
&=& \lim_{h \rightarrow 0}\frac{-\sin^2 h}{h \cdot (\cos h + 1)} \\
&=& \lim_{h \rightarrow 0}\sin h \cdot \lim_{h \rightarrow 0}\frac{-\sin h}{h} \cdot \lim_{h \rightarrow 0}\frac{1}{(\cos h + 1)} \\
&=& 0 \\
\end{matrix}
$$

1. 함수의 분자와 분모에 각각 $(\cos h + 1)$을 곱한다.
2. 분자에 삼각함수 공식 $\cos^2 \theta + \sin^2 \theta = 1$을 적용해 $-\sin^2 h$로 단순하게 만든다.
3. 극한의 성질 3을 사용해 각 극한을 곱으로 분리한다.
4. 각 극한값을 순서대로 구하면 0, 1, $\frac{1}{2}$이 되는데 이들을 곱하면 0이 된다.

[식 13-9](#식-13-9)와 [식 13-11](#식-13-11)을 사용해 삼각함수의 도함수를 하나씩 구한다.     
먼저 $f(x) = \sin x$라 할 때 이의 도함수를 확인한다.    

$$
\begin{matrix}
f'(x) &=& \lim_{h \rightarrow 0}\frac{\sin(x + h) - \sin x}{h} \\
&=& \lim_{h \rightarrow 0}\frac{\cos h \cdot \sin x + \cos x \cdot \sin h - \sin x}{h} \\
&=& \sin x \cdot \lim_{h \rightarrow 0}\frac{\cos h - 1}{h} + \cos x \cdot \lim_{h \rightarrow 0}\frac{\sin h}{h} \\
&=& \cos x \\
\end{matrix}
$$

1. 삼각함수의 덧셈 정리를 사용해 분리한다.
2. 극한식을 분리하고 $h$와 관련없는 $\sin x$와 $\cos x$는 극한식 밖으로 빼낸다.
3. 우변의 좌향 극한식에 [식 13-11](#식-13-11)을 적용하고 우향 극한식에는 [식 13-9](#식-13-9)를 적용하면 $\cos x$만 남는다.

따라서 $\sin$ 함수의 도함수는 $\cos$ 함수가 됨을 알 수 있다.    
함수 $f(x)$를 $\cos x$라 할 때 도함수를 구한다.

$$
\begin{matrix}
f'(x) &=& \lim_{h \rightarrow 0}\frac{\cos(x + h) - \cos(x)}{h} \\
&=& \lim_{h \rightarrow 0}\frac{\cos x \cdot \cos h - \sin x \cdot \sin h - \cos x}{h} \\
&=& \cos x \cdot \lim_{h \rightarrow 0}\frac{\cos h - 1}{h} - \sin x \cdot \lim_{h \rightarrow 0}\frac{\sin h}{h} \\
&=& -\sin x \\
\end{matrix}
$$

1. 삼각함수의 덧셈 정리를 사용해 분리한다.
2. 극한식을 분리하고 $h$와 관련없는 $\sin x$와 $\cos x$는 극한식 밖으로 빼낸다.
3. 우변의 좌항 극한식에 [식 13-11](#식-13-11)을 적용하면 $\cos x$만 남는다.

이는 앞서 구한 $\sin$ 함수의 도함수 전개와 유사하며 $\cos$ 함수의 도함수는 $-\sin x$가 됨을 알 수 있다.

$\sin$ 함수의 도함수는 $\cos$ 함수고 $\cos$ 함수의 도함수는 $-\sin$ 함수다.     
따라서 다음과 같은 식이 성립할 것이다.

$$f(x) = \sin x$$

$$f'(x) = \cos x$$

$$f''(x) = -\sin x$$

여기서 두 번 더 미분하면 원함수인 $\sin$ 함수로 돌아오게 된다.

$$f'''(x) = -\cos x$$

$$f^{(4)}(x) = \sin x$$

이렇게 네 번 미분했을 때 원함수로 돌아오는 성질은 $\cos$ 함수도 동일하다.

$$f(x) = \cos x$$

$$f'(x) = -\sin x$$

$$f''(x) = -\cos x$$

$$f'''(x) = \sin x$$

$$f^{(4)}(x) = \cos x$$

따라서 $\sin$ ***함수와*** $\cos$ ***함수는 네 번 미분하면 원함수로 돌아오기 때문에 자연지수함수와 동일한 성질을 가진 무한번 미분 가능한 함수다***.     
이들의 연관성은 급수를 통해 확인할 수 있다.

# 47. 급수
***오일러 공식에는 자연지수함수와 두 삼각함수의 미분이 사용된다***.   
***무한번 미분 가능하다는 공통점을 가진 세 함수는 각각 무한 급수로 표현***될 수 있고 세 함수가 모두 무한 급수로 표현되면 오일러 공식을 유도할 수 있다.    
무한번 미분 가능한 함수를 무한 급수로 표현하기 위해선 ***등비수열***에 대해 알아야 한다.

# 47.1. 등비수열
***수열(Sequence)*** 이란 규칙에 따라 순서에 맞게 수를 나열한 것이다.      
예를 들어 1부터 시작해서 1씩 커지는 자연수를 순서대로 나열하면 1, 2, 3, 4, ...로 이어지는 수열을 이룬다.    
이 수열은 자연수 집합과 유사하다.   
하지만 ***집합은 순서의 개념이 없고 중복을 허용하지 않는다***는 점에서 ***수열과는 엄연히 다른 개념***이다.     
이 중에서도 연속된 항들이 일정한 ***비(Ratio)*** 로 증가하는 수열을 ***등비수열(Geometric sequence)*** 이라고 하며, 등비수열 규칙에 사용된 비를 ***공비(Common ratio)*** 라고 한다.      
다음은 등비수열의 한 예시로, 연속된 두 항이 $\frac{1}{2}$배씩 증가하는 규칙을 가지므로 공비는 $\frac{1}{2}$이 된다.

$$\frac{1}{2}, \frac{1}{4}, \frac{1}{8}, \frac{1}{16}, \frac{1}{32}, ...$$

수열의 첫 번째 값을 ***초항(First term)*** 이라 부르며 $a$로 표기한다.     
공비는 $r$로, $n$번째의 항은 $a_n$으로 표기해, 다음과 같은 식으로 등비수열을 나타낸다.

$$a_n = a \cdot r^{n - 1}$$

등비수열의 $n + 1$번째 항과 $n$번째 항에 공비를 적용하면 다음과 같은 관계가 성립한다.

$$a_{n + 1} = a_n \cdot r$$

# 47.2. 급수
수열의 개념을 확장해 수열의 모든 값을 더한 것을 ***급수(Series)*** 라고 한다.      
초항 $a_0$와 $n$개의 요소로 구성된 수열의 급수는 시그마 기호($\sum$)를 활용해 간략히 표현한다.

$$\sum_{k = 0}^n a_k = a_0 + a_1 + a_2 + a_3 + ... + a_n$$

등비수열의 급수는 다음과 같이 표현할 수 있다.

$$\sum_{k = 0}^\infty a \cdot r^k$$

등비수열의 급수를 특별히 ***기하급수(Geometric series)*** 라고 한다.       
***기하급수는 무한대로 계속 증가하거나 특정 수로 수렴하는 성질이 있다***.     
공비가 $\frac{1}{2}$인 등비수열의 급수가 어떤 값 $s$에 수렴한다면 다음과 같이 표현할 수 있다.

$$s = \frac{1}{2} + \frac{1}{4} + \frac{1}{8} + \frac{1}{16} + \frac{1}{32} + ... \quad (1)$$

그렇다면 수렴하는 급수 값 $s$는 얼마인지 확인해보자.    
급수 값 $s$에 공비 $\frac{1}{2}$를 곱한 식은 다음과 같다.

$$\frac{1}{2}s = \frac{1}{2}(\frac{1}{2} + \frac{1}{4} + \frac{1}{8} + \frac{1}{16} + \frac{1}{32} + ...) \quad (2)$$

[1]에서 [2]를 빼면 좌변은 $\frac{1}{2}s$가 남고 우변은 $\frac{1}{2}$이 남는다.

$$\frac{1}{2}s = \frac{1}{2}$$

이 식이 만족하려면 $s$는 1이어야 하므로 급수 값은 1에 수렴한다.     
이 기하급수를 시각적으로 표현하면 [그림 13-10](#그림-13-10-무한한-기하급수의-수렴)과 같다.      
기하급수의 요소는 무한하지만 이를 모두 더한 값은 가로와 세로의 길이가 1인 정사각형의 넓이 1에 수렴하는 것을 확인할 수 있다.

###### 그림 13-10 무한한 기하급수의 수렴
![무한한 기하급수의 수렴](/img/)

위에서 계산한 기하급수를 구하는 과정을 일반화시켜 정리한다.     
등비수열의 초항을 $a$, 공비를 $r$이라고 했을 때, $n$개의 유한한 등비급수를 $s_n$으로 표현하면 다음 식이 성립된다.

$$s_n = a + ar + ar^2 + ar^3 + ... + ar^{n - 1} \quad (1)$$

[1]의 양변에 공비 $r$을 곱하면 다음과 같이 전개된다.

$$rs_n = ar + ar^2 + ar^3 + ... + ar^n \quad (2)$$

그리고 [1]에서 [2]를 빼면 다음 식이 나온다.

$$s_n - rs_n = a - ar^n$$

좌변을 $s_n$에 대해 묶으면 다음의 식이 유도된다.

$$
\begin{matrix}
s_n(1 - r) &=& a(1 - r^n) \\
s_n &=& \frac{a(1 - r^n)}{1 - r} \\
\end{matrix}
$$

기하급수는 무한 개의 요소를 가지므로 위 식의 $n$에 무한대의 극한을 설정하고 이를 전개해보자.

$$
\begin{matrix}
\lim_{n \rightarrow \infty} s_n &=& \lim_{n \rightarrow \infty} \frac{a(1 - r^n)}{1 - r} \\
&=& \frac{a}{1 - r} \cdot \lim_{n \rightarrow \infty}(1 - r^n) \\
&=& \frac{a}{1 - r} - \frac{a}{1 - r} \cdot \lim_{n \rightarrow \infty} r^n \\
\end{matrix}
$$

1. 극한의 성질 2에 따라 $n$이 들어가지 않는 상수를 빼낸다.
2. 극한의 성질 1에 따라 극한 내 두 항을 분리한다.

$\lim_{n \rightarrow \infty} s_n$의 극한값을 구하려면 공비 $r$이 가질 수 있는 값을 여러 개로 분리하고 각각에 대한 극한을 생각해야 한다.     
먼저 공비 $r$이 1이라면 $\frac{a}{1 - r}$의 분모가 0이 되어 극한값을 구할 수 없다.      
공비 $r$이 1인 경우의 무한급수는 어떻게 전개되는지 살펴보자.       
공비 $r$이 1이면 다음과 같이 기하급수는 $a$를 무한 번 더한 식이 되므로 급수 값은 무한대로 발산한다.

$$s_n = a + a + a + a + ...$$

$r$이 1이 아닌 경우를 생각해보면, 공비 $r$이 1이 아닌 경우 $\frac{a}{1 - r}$는 상수가 되므로 $\lim_{n \rightarrow \infty} s_n$의 극한값은 $\lim_{n \rightarrow \infty}$의 값에 따라 결정된다.

만일 공비 $r$의 크기가 1보다 크다면, 즉 $|r| > 1$인 경우에는 공비를 계속 곱할수록 크기도 계속 커져 $\lim_{n \rightarrow \infty} r^n$의 극한값은 발산한다.

$$
\begin{matrix}
-1.1^2 &=& 1.21 \\
-1.1^3 &=& -1.331 \\
-1.1^4 &=& 1.4641 \\
&...& \\
\end{matrix}
$$

공비 $r$의 크기가 1보다 작다면, 즉 $|r| < 1$인 경우에는 공비를 계속 곱할수록 그 값의 크기는 계속 작아져 이의 극한값은 0으로 수렴한다.

$$
\begin{matrix}
-0.9^2 &=& 0.81 \\
-0.9^3 &=& -0.729 \\
-9.9^4 &=& 0.6561 \\
&...& \\
\end{matrix}
$$

공비 $r$이 -1이면 $\lim_{n \rightarrow \infty} r^n$의 값은 일정한 값을 가지지 못하고 규칙적으로 1과 -1값을 오고간다.

$$
\begin{matrix}
-1^2 &=& 1 \\
-1^3 &=& -1 \\
-1^4 &=& 1 \\
&...& \\
\end{matrix}
$$

이러한 현상을 ***진동한다(Oscilate)*** 고 표현하는데, 이 역시 ***특정 값으로 수렴하지 않으므로 발산으로 취급***된다.

지금까지 살펴본 공비 $r$의 값에 따른 $\lim_{n \rightarrow \infty} s_n$의 성질을 정리하면 다음과 같다.

- $r = 1$인 경우에는 발산한다.
- $|r| > 1$인 경우에는 발산한다.
- $|r| < 1$인 경우에는 수렴한다.
- $r = -1$인 경우에는 발산한다.

이 중에서 기하급수가 수렴하기 위한 조건은 $|r| < 1$이다.    
공비가 $\frac{1}{2}$인 기하급수는 수렴 조건을 만족하기 때문에 $\lim_{n \rightarrow \infty} r^n$의 극한값은 0이 되어 $\frac{a}{1 - r}$에 수렴됐던 것이다.

기하급수에서 좀 더 확장된 형태의 급수에 대해 알아보자.      
기하급수는 더해지는 모든 항의 계수 $a$의 값이 모두 같았다.      
그런데 다음과 같이 항마다 계수가 다른 급수도 있는데, 이를 ***멱급수(Power series)*** 라고 한다.

$$\sum_{n = 0}^\infty a_n \cdot r^n = a_1 + a_2r + a_3r^2 + a_4r^3 + a_5r^4 + ...$$

즉 기하급수는 모든 계수의 값이 동일한 멱급수의 한 종류라고 할 수 있다.      
멱급수도 기하급수와 동일하게 특정 조건에 따라 수렴하거나 발산하는데, 이를 판정하기 위한 ***비판정법(Ratio test)*** 에 대해 알아야 한다.    
비판정법은 멱급수의 항의 계수가 일정한 규칙으로 전개되는 경우, 다음의 극한값을 구해 수렴, 발산 여부를 파악하는 방법이다.

$$L = \lim_{n \rightarrow \infty}|\frac{a_n + 1}{a_n}|$$

비판정법의 결과로 계산되는 $L$의 값은 다음과 같은 3가지 경우가 있다.

- $L$의 값이 1보다 작으면 급수는 언제나 수렴한다.
- $L$의 값이 1보다 크면 급수는 언제나 발산한다.
- $L$의 값이 1이면 수렴할 수도, 발산할 수도 있다.

기하 급수 예제를 멱급수의 관점에서 다시 살펴보면 기하 급수는 모든 계수의 값이 동일한 $a$이고 공비가 $r$인 멱급수의 형태를 띤다.

$$\sum_{n = 0}^\infty a \cdot r^n$$

이 식에 비판정법을 적용한 결과 값은 $n$과 무관하게 $|r|$이 나온다.

$$L = \lim_{n \rightarrow \infty}|\frac{a \cdot r^{n + 1}}{a \cdot r^n}| = |r|$$

급수가 수렴하기 위해서는 $L$의 값이 1보다 작아야 하는데 이는 $|r| < 1$을 의미한다.      
기하급수가 수렴하기 위한 조건과 동일하다.       
이와 같이 멱급수가 수렴하기 위해 $r$이 가져야 할 범위를 수렴구간이라고 하며, 범위의 절반인 1의 값을 ***수렴반지름(Radius of convergence)*** 이라고 한다.

각 항의 계수가 서로 다른 멱급수의 수렴 조건을 분석해보자.

$$\sum_{n = 1}^\infty \frac{r^n}{n} = x + \frac{1}{2}r^2 + \frac{1}{3}r^3 + \frac{1}{4}r^4 + ...$$

이 식에 비판정법을 적용하면 다음과 같이 전개된다.

$$
\begin{matrix}
L &=& \lim_{n \rightarrow \infty}|\frac{\frac{r^{n + 1}}{n + 1}}{\frac{r^n}{n}}| \\
&=& \lim_{n \rightarrow \infty}|r| \cdot \frac{n}{n + 1} \\
&=& |r| \cdot \lim_{n \rightarrow \infty} \frac{n}{n + 1} \\
&=& |r| \cdot \lim_{n \rightarrow \infty} \frac{(n + 1) - 1}{n + 1} \\
&=& |r| - |r| \cdot \lim_{n \rightarrow \infty} \frac{1}{n + 1} \\
&=& |r| \\
\end{matrix}
$$

이로써 해당 멱급수가 수렴하기 위한 조건은 $L = |r|$이 됨을 알 수 있다.      
따라서 위 멱금수 또한 기하 급수와 동일한 수렴반지름을 가짐을 알 수 있다.

# 47.3. 매클로린 급수
멱급수가 수렴하기 위한 조건을 알아봤으니, 이제 본격적으로 ***무한 미분 가능한 함수를 멱급수 형태로 바꾸는 방법***에 대해 알아야 한다.     
이러한 멱급수를 ***매클로린 급수(Macalurin series)*** 혹은 ***테일러 급수(Taylor series)*** 라고 한다.       
수렴하는 멱급수에서 공비 값을 $x$로 바꿔서 멱급수를 다음과 같은 함수 $f(x)$로 정의한다.

###### 식 13-12

$$f(x) = a_1 + a_2x + a_3x^2 + a_4x^3 + a_5x^4 + ...$$

이 멱급수에 대응되는 어떤 함수가 있다고 가정한다.   
그 함수가 무한 미분 가능하다면 멱급수의 도함수는 [식 13-7](#식-13-7)에서 살펴본 거듭제곱 함수의 미분을 사용해 다음과 같이 전개된다.

$$f'(x) = 1 \cdot a_2 + 2a_3x + 3a_4x^2 + 4a_5x^3 + ...$$

$$f''(x) = (2 \cdot 1)a_3 + (3 \cdot 2)a_4x + (4 \cdot 3)a_5x^2 + ...$$

$$f'''(x) = (3 \cdot 2 \cdot 1)a_4 + (4 \cdot 3 \cdot 2)a_5x + ...$$

원함수 $f(x)$를 $n$차 미분한 모든 도함수의 $x$값에 0을 대입하면 다음과 같이 멱급수를 구성하는 각 항의 계수값 $a_n$값과 일정한 규칙을 가지는 상수만 남는다.

###### 식 13-13

$$f(0) = a_1$$

$$f'(0) = 1 \cdot a_2$$

$$f''(0) = (2 \cdot 1)a_3$$

$$f'''(0) = (3 \cdot 2 \cdot 1)a_4$$

$$...$$

여기서 어떤 자연수보다 작은 모든 자연수의 곱을 ***계승(Factorial)*** 이라 부르는데, ! 기호를 사용해서 축약해 표현한다.     
계승을 수식으로 표현하면 다음과 같다.

$$n! = (n - 1)! \cdot n$$

$$\therefore (n - 1)! = \frac{n!}{n}$$

위의 식에서 0의 계승 0!의 값은 1임을 알 수 있다.

$$0! = (1 - 1)! = \frac{1!}{1} = 1$$

[식 13-13](#식-13-13)도 계승을 사용해 다음과 같이 간단히 표기할 수 있다.    

###### 식 13-14

$$f(0) = 0! \cdot a_1$$

$$f'(0) = 1! \cdot a_2$$

$$f''(0) = 2! \cdot a_3$$

$$f'''(0) = 3! \cdot a_4$$

$$...$$

[식 13-14](#식-13-14)의 각 도함수 식을 살펴보면 멱급수의 $n$번째 계수 $a_n$은 [식 13-15](#식-13-15)와 같이 함수 $f(x)$를 $n$번 미분한 도함수에 0을 대입한 값을 $n$ 계승 값으로 나눠주면 얻을 수 있다.

###### 식 13-15

$$a_n = \frac{f^{(n)}(0)}{n!}$$

[식 13-12](#식-13-12)의 멱급수 전개는 [식 13-16](#식-13-16)과 같이 $n$번 미분한 도함수에 0을 대입한 형태로 일반화할 수 있다.   
이를 매클로린 급수 또는 테일러 급수라고 한다.       
***매클로린 급수는 무한급수이므로 무한 미분 가능한 함수만이 이 수식을 만족한다***.

###### 식 13-16

$$f(x) = \frac{f(0)}{0!} + \frac{f'(0)}{1!}x + \frac{f''(0)}{2!}x^2 + \frac{f'''(0)}{3!}x^3 + ...$$

매클로린 급수의 표현 방법을 확인했으니 ***오일러 공식을 유도하는 데 필요한 자연지수함수,*** $\sin$ ***함수,*** $\cos$ ***함수***를 매클로린 급수 형식으로 전개하고 이들이 수렴하는지 확인한다.    
먼저 자연지수함수에 대해 알아보자.

$$f(x) = e^x$$

자연지수함수의 매클로린 급수는 다음과 같이 전개된다.

$$
\begin{matrix}
f(x) &=& \frac{f(0)}{0!} + \frac{f'(0)}{1!}x + \frac{f''(0)}{2!}x^2 + \frac{f'''(0)}{3!}x^3 + ... \\
&=& 1 + x + \frac{1}{2!}x^2 + \frac{1}{3!}x^3 + \frac{1}{4!}x^4 + \frac{1}{5!}x^5 + \frac{1}{6!}x^6 + \frac{1}{7!}x^7 ... \\
&=& \sum_{n = 0}^\infty \frac{x^n}{n!} \\
\end{matrix}
$$

자연지수함수에 대응하는 매클로린 급수가 수렴하는지 판단하기 위해 비판정법을 진행한다.

$$
\begin{matrix}
L &=& \lim_{n \rightarrow \infty} |\frac{\frac{x^{n + 1}}{(n + 1)!}}{\frac{x^n}{n!}}| \\
&=& \lim_{n \rightarrow \infty}|x| \cdot \frac{n!}{(n + 1)!} \\
&=& |x| \cdot \lim_{n \rightarrow \infty} \frac{1}{n + 1} \\
&=& |x| \cdot 0 \\
&=& 0 \\
\end{matrix}
$$

비판정을 진행한 결과는 0이 나오므로 해당 급수는 언제나 수렴함을 확인할 수 있다.     
따라서 ***자연지수함수의 매클로린 급수는 유효하다***.

###### 식 13-17

$$e^x = \sum_{n = 0}^\infty \frac{x^n}{n!}$$

$\sin$ 함수에 대해 진행한다.

$$f(x) = \sin x$$

$\sin$ 함수의 매클로린 급수는 다음과 같이 전개된다.

$$
\begin{matrix}
f(x) &=& \frac{f(0)}{0!} + \frac{f'(0)}{1!}x + \frac{f''(0)}{2!}x^2 + \frac{f'''(0)}{3!}x^3 + ... \\
&=& 0 + x - 0 - \frac{1}{3!}x^3 + 0 + \frac{1}{5!}x^5 - 0 - \frac{1}{7!}x^7 ... \\
&=& \sum_{n = 0}^\infty \frac{(-1)^nx^{2n + 1}}{(2n + 1)!} \\
\end{matrix}
$$

$\sin$ 함수에 대응하는 매클로린 급수의 비판정을 진행한다.

$$
\begin{matrix}
L &=& \lim_{n \rightarrow \infty}|\frac{\frac{(-1)^{n + 1}x^{2n + 3}}{(2n + 3)!}}{\frac{(-1)^nx^{2n + 1}}{(2n + 1)!}}| \\
&=& \lim_{n \rightarrow \infty}|x^2| \cdot \frac{(2n + 1)!}{(2n + 3)!} \\
&=& |x^2| \cdot \lim_{n \rightarrow \infty}\frac{1}{(2n + 3)(2n + 2)} \\
&=& 0 \\
\end{matrix}
$$

0이 나오므로 $\sin$ ***함수의 매클로린 급수는 유효함***을 확인할 수 있다.

###### 식 13-18

$$\sin x = \sum_{n = 0}^\infty \frac{(-1)^nx^{2n + 1}}{(2n + 1)!}$$

$\cos$ 함수에 대해 진행한다.

$$f(x) = \cos x$$

$\cos$ 함수의 매클로린 급수는 다음과 같이 전개된다.

$$
\begin{matrix}
f(x) &=& \frac{f(0)}{0!} + \frac{f'(0)}{1!}x + \frac{f''(0)}{2!}x^2 + \frac{f'''(0)}{3!}X^3 + ... \\
&=& 0 - x - \frac{1}{2!}x^2 + 0 + \frac{1}{4!}x^4 - 0 - \frac{1}{6!}x^6 ... \\
&=& \sum_{n = 0}^\infty \frac{(-1)^nx^{2n}}{(2n)!} \\
\end{matrix}
$$

$\cos$ 함수에 대응하는 매클로린 급수의 비판정을 진행해보면 $\sin$ 함수와 동일하게 0의 결과가 나옴을 확인할 수 있다.

$$
\begin{matrix}
L &=& \lim_{n \rightarrow \infty}|\frac{\frac{(-1)^{n + 1}x^{2n + 2}}{(2n + 2)!}}{\frac{(-1)^nx^{2n}}{(2n)!}} \\
&=& \lim_{n \rightarrow \infty}|x^2| \cdot \frac{(2n)!}{(2n + 2)!} \\
&=& |x^2| \cdot \lim_{n \rightarrow \infty} \frac{1}{(2n + 2)(2n + 1)} \\
&=& 0 \\
\end{matrix}
$$

따라서 $\cos$ 함수에 대응되는 매클로린 급수는 다음과 같다.

###### 식 13-19

$$\cos x = \sum_{n = 0}^\infty \frac{(-1)^nx^{2n}}{(2n)!}$$

> 참고: ***매클로린 급수의 활용***      
매클로린 급수는 컴퓨터에서 복잡한 함수의 근사값을 구할 때 유용하게 사용된다.    
예를 들어 $\sin$ 함수의 값을 컴퓨터에서 계산하고자 하는 경우 매클로린 급수를 사용하면 허용 가능한 오차 내의 이의 정밀한 값을 빠르게 계산할 수 있다.     
[식 13-18](#식-13-18)에서 $\sin$ 함수와 일치하는 매클로린 급수는 무한 개의 원소를 가지고 있으며 0을 제외한 급수식은 다음과 같다.
> 
> $$\sin x = x - \frac{1}{3!}x^3 + \frac{1}{5!}x^5 - \frac{1}{7!}x^7 ...$$
> 
> 여기서 첫항 $x$를 제외한 나머지 항을 모두 없앤다.
>
> $$\sin x \neq x$$
> 
> 함수 $f(x) = x$와 $f(x) = \sin x$의 그래프는 큰 차이가 있다.      
하지만 $f(x) = x$에 급수의 항을 하나씩 추가할수록 새로운 급수의 계산 결과는 $\sin$ 함수의 값과 점점 가까워진다.
> 
> $$\sin x \approx x - \frac{1}{3!}x^3 + \frac{1}{5!}x^5 - \frac{1}{7!}x^7$$
> 
> [그림 13-11](#그림-13-11-sin-함수와-매클로린-급수의-비교)에 $\sin$ 함수의 그래프와 한 단계씩 전개한 급수로 표현되는 함수를 비교했다.     
급수의 항을 하나씩 추가할 수록 함수의 모습은 $\sin$ 함수에 근접해지는 것을 확인할 수 있다.
> 
> ###### 그림 13-11 sin 함수와 매클로린 급수의 비교
> ![sin 함수와 매클로린 급수의 비교](/img/)     
> 
> 급수의 항을 충분히 추가하면 $\sin$ 함수 값과 급수 값 사이의 오차가 무의미한 수준까지 비슷해진다.      
그렇다면 각 급수항에 계승으로 나눈 상수를 미리 계산해두면, 급수는 덧셈과 곱셈으로만 구성된다.       
이는 컴퓨터로 굉장히 빠르게 계산할 수 있어 좀 더 효과적으로 함수 값을 구할 수 있다.

# 48. 오일러 공식
자연지수함수, $\sin$ 함수, $\cos$ 함수에 대응하는 매클로린 급수를 [식 13-17](#식-13-17), [식 13-18](#식-13-18), [식 13-19](#식-13-19)에 정리했고, 이들을 모으면 다음과 같다.

$$e^x = 1 + x + \frac{1}{2!}x^2 + \frac{1}{3!}x^3 + \frac{1}{4!}x^4 + \frac{1}{5!}x^5 + \frac{1}{6!}x^6 + \frac{1}{7!}x^7 ...$$

$$\sin x = 0 + x - 0 - \frac{1}{3!}x^3 + 0 + \frac{1}{5!}x^5 - 0 - \frac{1}{7!}x^7 ...$$

$$\cos x = 1 - 0 - \frac{1}{2!}x^2 + 0 + \frac{1}{4!}x^4 - 0 - \frac{1}{6!}x^6 + 0 ...$$

세 급수를 분석해서 서로 간의 연관성을 찾기 위해 먼저 $\sin$ 함수와 $\cos$ 함수에 대응하는 두 급수를 더한다.     
$\sin$ 함수는 매클로린 급수를 전개하는 과정에서 홀수항 부분이 0이 되고, $\cos$ 함수는 짝수항 부분이 0이 되다보니, $\sin$ 함수와 $\cos$ 함수의 매클로린 급수를 합하면 다음과 같이 서로에게 부족한 부분이 채워진다.

###### 식 13-20

$$\cos x + \sin x = 1 + x - \frac{1}{2!}x^2 - \frac{1}{3!}x^3 + \frac{1}{4!}x^4 + \frac{1}{5!}x^5 - \frac{1}{6!}x^6 - \frac{1}{7!}x^7 + ...$$

[식 13-20](#식-13-20)은 자연지수함수의 매클로린 급수와 유사한 형태가 되었지만 몇몇 항의 부호에서 차이가 발생한다.       

두 급수의 부호가 일치하려면 크기가 1이고 제곱하면 -1이 되는 수를 사용해야 한다.     
이러한 수는 실수에는 존재하지 않지만, 복소수의 허수 단위 $i$가 이를 만족한다.       
자연지수함수의 매클로린 급수에 허수 단위 $i$를 넣으면 다음과 같이 전개된다.

$$
\begin{matrix}
e^{ix} &=& 1 + ix + \frac{1}{2!}(ix)^2 + \frac{1}{3!}(ix)^3 + \frac{1}{4!}(ix)^4 + \frac{1}{5!}(ix)^5 + \frac{1}{6!}(ix)^6 + \frac{1}{7!}(ix)^7 + ... \\
&=& 1 + ix - \frac{1}{2!}x^2 - \frac{i}{3!}x^3 + \frac{1}{4!}x^4 + \frac{i}{5!}x^5 - \frac{1}{6!}x^6 - \frac{i}{7!}x^7 + ... \\
\end{matrix}
$$

자연지수함수에 허수 단위 $i$를 넣은 결과로 [식 13-20](#식-13-20)의 매클로린 급수와 동일한 부호가 만들어지는 것을 확인할 수 있다.

이제 $e^{ix}$의 매클로린 급수와 [식 13-20](#식-13-20)의 차이는 단지 짝수 항에 허수 단위 $i$가 붙어 있다는 것 뿐이다.    
$\cos x + \sin x$에서 짝수 항은 $\sin$ 함수가 담당하므로 $\sin$ 함수에 허수 $i$를 곱하면 비로소 오일러 공식의 모든 퍼즐이 맞춰진다.

###### 식 13-21

$$e^{ix} = \cos x + i \sin x$$

[식 13-21](#식-13-21)에서 $x$대신 각 $\theta$를 대입한다.   
그러면 다음과 같은 ***오일러 공식***이 유도된다.

$$e^{i\theta} = \cos \theta + i \sin \theta$$

우변의 식 $\cos \theta + i \sin \theta$는 ***복소평면에서 회전 변환을 담당하는 단위 복소수를 의미***한다.     
따라서 오일러 공식의 좌변에 위치한 $e^{i\theta}$는 ***복소평면에서의 회전 변환을 의미***한다.     
이로써 ***2차원 평면의 회전을 나타내는 방법***이 하나 더 추가됐다.

$$e^{i\theta} = (\cos \theta, \sin \theta) = 
\begin{bmatrix}
\cos \theta & -\sin \theta \\
\sin \theta & \cos \theta \\
\end{bmatrix}
$$

***행렬과 복소수를 사용해 표현했던 회전 변환***은 ***오일러 공식으로*** $e^{i\theta}$ ***라는 자연지수함수로 더욱 간단하게 표현***할 수 있게 되었다.       
예를 들어 각 $\alpha, \beta$의 회전 변환은 오일러 공식에 의해 각각 $e^{\alpha i}$와 $e^{\beta i}$로 표현할 수 있다.     
이 둘을 곱하면 $(\alpha + \beta)$의 회전 변환이 만들어지는데, 지수법칙에 의해 이 둘을 곱하면 자연스럽게 $e^{(\alpha + \beta)i}$가 만들어진다.

$$e^{(\alpha + \beta)i} = e^{\alpha i} \cdot e^{\beta i}$$

이러한 ***회전 변환을 단순화시키는 오일러 공식의 특징은 복잡한 4차원 공간의 회전을 단순화시켜 3차원 공간의 회전식을 유도하는 데 큰 역할을 한다***.

> 참고: ***세상에서 가장 아름다운 공식, 오일러 항등식***    
오일러 공식에서 $x$값에 $\pi$를 대입하면 다음과 같은 식이 성립된다.     
> 
> ###### 식 13-22
> 
> $$
\begin{matrix}
e^{i\pi} &=& \cos \pi + i \sin \pi \\
e^{i\pi} &=& -1 + 0 \\
e^{i\pi} + 1 &=& 0 \\
\end{matrix}$$
>
> 이 식은 오일러 항등식(Euler's identity)이라 불리며, 수학의 근간이 되는 5가지 특별한 상수 $e, \pi, i, 0, 1$을 하나씩 사용한다는 점에서 수학자들이 뽑은 세상에서 가장 아름다운 공식이라 일컬어진다.       
각 상수가 가지는 의미는 [표 13-2](#표-13-2-오일러-항등식이-가지는-의미)와 같다.
>
> ###### 표 13-2 오일러 항등식이 가지는 의미    
> 
> |상수|의미|
> |---|---|
> |0|덧셈의 항등원|
> |1|곱셈의 항등원|
> |$e$|무리수 $e$|
> |$\pi$|원주율|
> |$i$|허수|

# 49. 사원수 대수
***사원수는 복소수와 동일하게 허수를 사용하는 수의 집합***으로서, ***복소수가 하나의 실수부와 하나의 허수부로 구성***된 반면, ***사원수는 하나의 실수부와 세 개의 허수부로 구성***된다.       
***총 4가지 수 체계를 사용하기 때문에 사원수라고 한다***.

사원수에서는 세 허수부를 구성하는 단위를 각각 $i, j, k$로 표시한다.     

# 49.1. 사원수를 구성하는 세 허수
사원수는 3개의 허수부 $i, j, k$로 구성되어 있지만 이들은 모두 복소수의 허수 단위 $i$와 같은 성질을 가진다.

$$i^2 = -1$$

$$i^2 = j^2 = k^2 = -1$$

세 허수 중에서 두 허수의 곱은 다음과 같이 나머지 다른 허수에 대응되는데 이들은 회전의 순환 순서 $x \rightarrow y \rightarrow z \rightarrow x$와 유사하게 $i \rightarrow j \rightarrow k \rightarrow i$ 순서로 대응된다.

$$ij = k, jk - i, ki = j$$

이 식으로부터 $ij$의 값은 $k$가 되고 $kk$의 결과는 $-1$이므로 $ijk = -1$이라는 식이 성립한다.   
따라서 $ijk$ 값은 $-1$이 되며, 각 세 허수의 곱셈 결과는 다음과 같다.

$$ijk = jki = kij = -1$$

복소수가 $a + bi$의 형태를 가졌던 것처럼 사원수도 실수부와 허수부를 덧셈으로 묶고 실수를 사용해 허수부의 계수를 지정한다.       
실수부와 각 허수부의 계수를 $a, b, c, d$로 지정한 사원수는 다음과 같이 표현한다.

$$q = a + bi + cj + dk$$

사원수의 집합 기호는 $H$다.     
***사원수(Quaternion)*** 의 첫글자 $Q$는 유리수 집합에서 사용되고 있기 때문에, 사원수를 처음 고안한 수학자 윌리엄 로언 해밀턴(William Rowan Hamilton)의 이름에서 차용했다.     
***사원수는 복소수와 유사하게 덧셈과 곱셈이 존재하며, 체와 유사한 구조를 지닌다***.       

# 49.2. 사원수의 구조
사원수의 덧셈은 복소수와 유사하게 실수부와 각 허수부끼리 더하는 형태로 진행된다.

$$q_1 + q_2 = (a_1 + a_2) + (b_1 + b_2)i + (c_1 + c_2)j + (d_1 + d_2)k$$

사원수의 덧셈이 만족하는 성질은 다음과 같다.

- 결합법칙: $q_1 + (q_2 + q_3) = (q_1 + q_2) + q_3 \\ = (a_1 + a_2 + a_3) + (b_1 + b_2 + b_3)i + (c_1 + c_2 + c_3)j + (d_1 + d_2 + d_3)k$
- 교환법칙: $q_1 + q_2 = q_2 + q_1 = (a_1 + a_2) + (b_1 + b_2)i + (c_1 + c_2)j + (d_1 + d_2)k$
- 항등원: $(a + bi + cj + dk) + (0 + 0i + 0j + 0k) = (a + bi + cj + dk)$
- 역원: $(a + bi + cj + dk) + (-a - bi - cj - dk) = (0 + 0i + 0j + 0k)$

[표 14-1](#표-14-1-사원수의-덧셈-연산의-성질)에 사원수 덧셈의 성질을 정리했다.

###### 표 14-1 사원수의 덧셈 연산의 성질
|연산의 성질|만족 여부 및 값|
|---|---|
|덧셈에 대해 닫혀 있음|O|
|덧셈에 대한 교환법칙이 성립함|O|
|덧셈에 대한 결합법칙이 성립함|O|
|덧셈에 대한 항등원이 존재함|0|
|덧셈에 대한 역원이 존재함|$-(a + bi + cj + dk)$|

사원수의 곱셈은 ***해밀턴 곱(Hamilton product)*** 으로도 불리며 ***모든 요소를 교차해 곱하는 방식으로 진행***된다.       
사원수는 총 4가지 요소로 구성되므로 곱의 결과는 총 16가지 인자가 만들어지며, 임의의 두 사원수 $q_1$과 $q_2$의 곱셈 결과는 다음과 같다.

$$q_1 \cdot q_2 = (a_1a_2 - b_1b_2 - c_1c_2 - d_1d_2) + (a_1b_2 + a_2b_1 + c_1d_2 - d_1c_2)i \\ + (a_1c_2 + a_2c_1 + b_2d_1 - b_1d_2)j + (a_1d_2 + a_2d_1 + b_1c_2 - c_1b_2)k$$

사원수의 곱셈이 만족하는 성질은 다음과 같다.

- 결합법칙: $q_1 \cdot (q_2 \cdot q_3) = (q_1 \cdot q_2) \cdot q_3$
- 분배법칙: $q_1 \cdot (q_2 + q_3) = q_1 \cdot q_2 + q_1 \cdot q_3$
- 항등원: $(a + bi + cj + dk) \cdot (1 + 0i + 0j + 0k) = (a + bi + cj + dk)$

사원수 곱셈은 순서를 바꿔 계산하면 다음과 같이 결과가 달라진다.

$$q_2 \cdot q_1 = (a_1a_2 - b_1b_2 - c_1c_2 - d_1d_2) + (a_1b_2 + a_2b_1 - c_1d_2 + d_1c_2)i \\ + (a_1c_2 + a_2c_1 - b_2d_1 + b_1d_2)j + (a_1d_2 + a_2d_1 - b_1c_2 + c_1b_2)k$$

따라서 ***사원수는 곱셈에 대해 교환법칙이 성립하지 않는다***.     
[표 14-2](#표-14-2-사원수-곱셈-연산의-성질)에 사원수 곱셈 연산의 성질을 정리했다.

###### 표 14-2 사원수 곱셈 연산의 성질
|성질|만족 여부 및 값|
|---|---|
|곱셈에 대해 닫혀 있음|O|
|곱셈에 대한 교환법칙이 성립함|X|
|곱셈에 대한 결합법칙이 성립함|O|
|곱셈에 대한 항등원이 존재함|1|
|곱셈에 대한 역원이 존재함|켤레를 활용해 계산|
|덧셈과 곱셈에 대한 분배법칙이 성립함|O|

***사원수 곱셈은 교환법칙이 성립되지 않아 체의 구조를 가지고 있지 않지만 결합법칙 등 나머지 체의 성질은 모두 만족한다***.     
***체의 구조에서 교환법칙이 성립하지 않는 구조***를 ***유사체(Skew field)*** 라고 하는데, 이에 따라 ***사원수는 유사체의 구조를 지닌다***.     
따라서 ***사원수끼리 곱셈식을 전개할 때 왼쪽과 오른쪽의 순서가 바뀌지 않도록 주의***해야 한다.        

사원수의 크기는 복소수와 동일하게 각 계수를 제곱한 값을 더하고 제곱근을 취해 계산하며 절댓값 기호 $||$를 써서 표기한다.     
사원수의 크기 역시 ***노름(Norm)*** 이라 부른다.

$$|q| = \sqrt{a^2 + b^2 + c^2 + d^2}$$

사원수 중에서 ***크기가 1인 사원수***를 ***단위 사원수(Unit quaternion)*** 라고 한다.    
사원수의 ***세 허수부의 계수에 음수를 적용한 사원수***를 ***켤레 사원수***라고 부르고 $q^*$로 표기하며 다음과 같이 표현한다.

$$q^* = a - (bi + cj + dk)$$

***사원수와 켤레 사원수의 곱은 복소수와 켤레 복소수 간의 곱의 성질과 동일***하다.

$$(q^*)^* = q$$

$$(pq)^* = q^*p^*$$

***임의의 사원수에 그 켤레를 곱하면 크기의 제곱 값이 나온다***.

$$q^*q = qq^* = a^2 + b^2 + c^2 + d^2 = |q|^2$$

따라서 단위 사원수와 그의 켤레 사원수를 곱한 값은 언제나 1이 된다.      
이러한 사원수도 복소수와 동일하게 켤레 사원수의 성질을 사용해 사원수 곱의 역원을 유도할 수 있다.

$$q^{-1} = \frac{1}{q} = \frac{q^*}{qq^*} = \frac{q^*}{|q|^2}$$

여기서 크기가 1인 단위 사원수의 곱셈의 역원은 복소수와 동일하게 켤레 사원수가 된다.

사원수의 곱셈에 대해 결합법칙이 성립하지 않는다는 점을 제외하고, 복소수와 사원수는 공통점이 많이 있다.      

# 49.3. 사원수와 벡터
2개의 요소를 사용하는 복소수는 2개의 수 집합이 직교하는 복소평면으로 시각화할 수 있다.      
이와 유사하게 4개의 요소를 사용하는 사원수는 4개의 수 집합이 직교하는 4차원의 공간으로 시각화가 가능하다고 생각할 수 있지만, 4차원 공간은 일반적인 인지범위를 넘어서기 때문에 이를 시각적으로 정확하게 표현하는 것은 불가능하다.      
그래서 사원수를 다룰 때에는 4차원 공간을 1차원과 3차원으로 분리하고 3차원 공간의 성질을 관찰하는 것이 더욱 효과적이다.

###### 그림 14-1 인지 불가능한 4차원 공간의 입방체 테서랙트(Tesseract)
![인지 불가능한 4차원 공간의 입방체(Tesseract)](/img/)

따라서 ***사원수를 다룰 때에는 허수부를 사용하는 3개의 수 집합을 하나로 묶고, 나머지 실수부는 별도로 관리하는 방법을 사용***한다.     
세 허수부의 계수를 3차원 벡터로 묶는다면, 사원수는 실수와 3차원 벡터 두 가지 요소로 구성된다고 볼 수 있다.      
사원수 $q$를 실수와 3차원 벡터로 구성된 순서쌍으로 표현하면 다음과 같다.

$$q = w + xi + yj + zk = (w, \vec{v})$$

이 ***순서쌍의 원소***를 차례대로 ***실수부, 허수부***라고 하는데, 이들을 ***스칼라부, 벡터부***라고도 부른다.        
3차원 벡터를 사용해 사원수를 표현하면 사원수의 연산을 좀 더 체계적으로 정리할 수 있다.      
임의의 두 사원수를 $q_1 = (w_1, \vec{v}_1), q_2 = (w_2, \vec{v}_2)$로 표현하고 사원수의 기본 연산인 덧셈과 곱셈을 다시 표현한다.        
사원수 $q_1$과 $q_2$의 덧셈은 다음과 같은 순서쌍으로 표현할 수 있다.

$$q_1 + q_2 = (w_1 + w_2, \vec{v}_1 + \vec{v}_2)$$

사원수 $q_1$과 $q_2$의 곱셈은 벡터의 ***내적과 외적을 사용***해 다음과 같이 깔끔하게 정리할 수 있다.

$$q_1 \cdot q_2 = (w_1w_2 - (\vec{v}_1 \cdot \vec{v}_2), w_1\vec{v}_2 + w_2\vec{v}_1 + \vec{v}_1 \times \vec{v}_2)$$

사원수의 곱셈을 내적과 외적으로 정리했는데, 이를 통해 사원수의 곱셈은 교환법칙이 성립하지 않는지도 확인할 수 있다.      
허수부를 구성하는 벡터 연산이 교환법칙이 성립하지 않는 외적에 관련되어 있기 때문이다.

사원수에서 ***실수부가 0인 사원수***를 특별히 ***순허수 사원수(Pure imaginary quarternion)*** 라고 부른다.       
순허수 사원수는 세 허수로만 구성된 수를 말하는데, 이는 3차원 벡터 공간에 대응되는 개념이다.     
즉 3차원 공간이 사원수를 다루는 4차원 공간의 일부라면, 3차원 공간의 벡터 $\vec{v} = (x, y, z)$는 다음의 순허수 사원수에 대응된다고 할 수 있다.

$$xi + yj + zk = (0, \vec{v})$$

순허수 사원수 $q_1$과 $q_2$의 곱셈을 전개하면 $w_1$과 $w_2$의 값이 0이다 보니 이들이 포함된 항의 값은 모두 0이 된다.        
곱셈 결과는 아래와 같이 내적과 외적만 남아 더욱 단순해진다.

$$q_1 \cdot q_2 = (-\vec{v}_1 \cdot \vec{v}_2, \vec{v}_1 \times \vec{v}_2)$$

# 50. 사원수의 회전
자연지수함수, $\sin$ 함수, $\cos$ 함수를 매클로린 급수로 전개했을 때 세 급수가 서로 통합되기 위해서는 크기가 1이고, 제곱한 수가 -1이 되는 특별한 수가 필요하다.     
복소수 체계에서 이 조건을 만족하는 특별한 수인 허수 $i$를 사용해 다음의 오일러 공식을 전개할 수 있다.

$$e^{i\theta} = \cos \theta + i \sin \theta = (\cos \theta, \sin \theta)$$

사원수에서도 허수 $i$와 동일하게 크기가 1이고 제곱한 값이 -1인 수가 있다면 오일러 공식을 만족한다.

# 50.1. 사원수와 오일러 공식
***크기가 1인 순허수 사원수도 크기가 1이고 제곱한 값이 -1이다***.     
크기가 1인 순허수 사원수를 $q_n$으로 지정하고 이를 직접 확인한다.       
먼저 순허수 사원수 $q_n$의 요소를 $(0, \vec{n})$으로 표시한다.      
$q_n$의 크기는 1이므로 다음의 식이 성립한다.

$$\sqrt{0 + |\vec{n}|^2} = 1$$

이로써 $\vec{n}$의 크기도 1이 됨을 알 수 있으며, 내적 $\vec{n} \cdot \vec{n}$의 값도 1이 된다.

$$|\vec{n}| = \vec{n} \cdot \vec{n} = 1$$

순허수 사원수 $q_n$의 제곱을 전개하면 다음과 같다.

$$q_n^2 = q_n \cdot q_n = (-\vec{n} \cdot \vec{n}, \vec{n} \times \vec{n})$$

그런데 $\vec{n} \cdot \vec{n}$은 1이고 ***평행한 벡터의 외적은 영벡터***가 되므로 위 식은 다음과 같이 간략하게 전개된다.

$$q_n \cdot q_n = (-1, \vec{0})$$

따라서 크기가 1인 순허수 사원수 $q_n$을 제곱한 결과는 $-1$이 됨을 확인할 수 있다.       
그렇다면 오일러 공식의 전개 과정에 허수 $i$대신 순허수 사원수의 벡터 $\vec{n}$을 사용할 수 있다.        
이렇게 하면 자연상수의 지수함수로 사원수의 회전을 표현하는 것이 가능하다.       
이를 수식으로 정리하면 단위 복소수와 형태가 유사해진다.

$$e^{\vec{n}\theta} = \cos \theta + \sin \theta \cdot \vec{n} = (\cos \theta, \sin \theta \cdot \vec{n})$$

$(\cos \theta, \sin \theta \cdot \vec{n})$ 형태의 사원수는 4차원 공간에서 회전축 $\vec{n}$을 중심으로 회전 변환하는 성질을 가지는데, 이를 ***회전 사원수(Rotation quaternion)*** 라고 한다.        
회전 사원수를 $q$, 벡터 $\vec{n}$의 요소를 $(a, b, c)$로 표기하고 이를 확인한다.        
여기서 벡터 $\vec{n}$은 크기가 1인 단위 벡터이므로 $a^2 + b^2 + c^2 = 1$의 조건에 의해 다음과 같이 전개되어 회전 사원수는 언제나 단위 사원수임을 확인할 수 있다.

$$q = \cos \theta + \sin \theta \cdot \vec{n} = \cos \theta + \sin \theta (ai + bj + ck)$$

$$|q| = \cos^2 \theta + \sin^2 \theta (a^2 + b^2 + c^2) = 1$$

회전 사원수의 켤레는 다음과 같이 표현한다.

$$q^* = (\cos \theta, -\sin \theta \cdot \vec{n})$$

이는 반대 방향의 회전을 의미한다.

$$q^* = (\cos(-\theta), \sin(-\theta) \cdot \vec{n})$$

반대 방향의 회전을 의미하는 회전 사원수의 켤레 사원수는 오일러의 공식으로도 확인할 수 있다.     
단위 사원수와 그 켤레를 곱한 값은 언제나 1이 나옴을 확인했는데, 이를 자연지수함수로 표현하면 다음과 같이 0의 지수로 나타낼 수 있다.

$$q \cdot q^* = 1 = e^0$$

오일러의 공식에 의해 회전 사원수에 대응하는 지수함수는 다음과 같다.

$$q = e^{\vec{n}\theta}$$

이를 회전 사원수 $q$에 치환한 식은 다음과 같이 전개된다.ㅣ

$$e^{\vec{n}\theta} \cdot q^* = e^0$$

이를 만족하는 $q^*$의 값은 $e^{-\vec{n}\theta}$이며 이는 같은 축 $\vec{n}$을 중심으로 반대 방향으로 $\theta$ 돌리는 회전을 의미한다.

$$\therefore q^* = e^{-\vec{n}\theta} = e^{\vec{n}(-\theta)}$$

# 50.2. 회전 사원수를 이용한 3차원 공간에서의 회전
회전 사원수 $q$를 사용해 임의의 회전축 $\vec{n}$에 대해 3차원 공간의 벡터 $\vec{v}$를 각 $\theta$만큼 회전시키는 방법을 확인해보자.

일반적으로 사용하는 ***3차원 공간의 벡터*** $\vec{v}$는 ***순허수 사원수에 대응되는 개념***이다.    
벡터 $\vec{v}$의 값을 $(x, y, z)$로 표시하고, 회전축 $\vec{n}$의 값을 $(a, b, c)$로 지정한다.       
회전축은 단위 벡터이기 때문에 $a^2 + b^2 + c^2 = 1$의 조건을 가진다.        
그리고 회전축 $\vec{n}$으로 각 $\theta$만큼 회전시키는 회전 사원수 $q$는 $(\cos \theta, \sin \theta \cdot \vec{n})$의 값을 가진다.

회전 사원수 $q$를 사용해 벡터를 회전시키는 방법은 회전 사원수를 벡터의 왼쪽에 배치하고 둘을 곱하는 것이다.          
이때 ***사원수의 곱셈은 교환법칙이 성립하지 않기 때문에 곱하는 순서에 항상 신경 써야 한다***.

회전 사원수와 순허수 사원수 벡터 $\vec{v}$의 곱셈은 다음과 같이 전개된다.

$$
\begin{matrix}
\vec{v^{'}} &=& q \cdot \vec{v} \\
&=& (\cos \theta, \sin \theta \cdot \vec{n}) \cdot (0, \vec{v}) \\
&=& (-\sin \theta (\vec{n} \cdot \vec{v}), \cos \theta \vec{v} + \sin \theta (\vec{n} \times \vec{v})) \\
\end{matrix}
$$

계산 결과를 살펴보면 ***회전 사원수와 벡터를 곱한 결과는 순허수 사원수가 아닌 네 요소를 모두 사용하는 일반 사원수가 나온다***.        
따라서 이 곱의 결과는 순허수 사원수와 1:1로 대응했던 3차원 공간의 규격에서 벗어나게 되므로 3차원 공간의 요소로 사용할 수 없게 된다.     
[그림 14-2](#그림-14-2-회전-사원수를-사용해-벡터를-회전시킨-결과)에 지금까지의 상황을 정리한다.

###### 그림 14-2 회전 사원수를 사용해 벡터를 회전시킨 결과
![회전 사원수를 사용해 벡터를 회전시킨 결과](/img/)

3차원 공간에서 벡터를 회전시키는 용도로 사원수를 사용하기 위해서는 ***사원수 곱의 결과가 항상 순허수 사원수가 되는 특별한 수식***을 발견해야 한다.        

회전 사원수의 벡터 $\vec{n}$은 회전축의 역할을 수행한다.        
이는 로드리게스 회전 공식에서 언급되는 축-각 회전에 대응하는 벡터다.     
3차원 공간에서 임의의 축 $\vec{n}$에 대한 회전을 표현하면 [그림 14-3](#그림-14-3-임의의-회전축-n에-대한-회전의-표현)과 같다.

###### 그림 14-3 임의의 회전축 n에 대한 회전의 표현
![임의의 회전축 n에 대한 회전의 표현](/img/)

회전시킬 벡터를 $\vec{v}$로 정하고 이를 회전축 $\vec{n}$에 평행한 성분과 수직인 성분으로 나눈다.            
회전축에 수평인 성분을 $\vec{v_\parallel}$, 수직인 성분을 $\vec{v_\perp}$으로 표시하면 다음 식이 성립된다.

$$\vec{v} = \vec{v_\parallel} + \vec{v_\perp}$$

[그림 14-4](#그림-14-4-회전시킬-벡터-v를-평행-성분과-수직-성분으로-분리한-결과)는 벡터 $\vec{v}$를 수직 성분과 수평 성분으로 분리해 나타낸 그림이다.        
이를 각 $\theta$만큼 회전 시킨 벡터를 $\vec{v^{'}}$로 가정한다.

###### 그림 14-4 회전시킬 벡터 v를 평행 성분과 수직 성분으로 분리한 결과
![회전시킬 벡터 v를 평행 성분과 수직 성분으로 분리한 결과](/img/)

이때 원하는 최종 회전의 벡터 $\vec{v^{'}}$는 [그림 14-5](#그림-14-5-3차원-공간에서의-회전의-구현)와 같이 회전축에 수직인 성분만 회전시킨 후, 수평 성분은 그대로 더하면 구할 수 있다.

###### 그림 14-5 3차원 공간에서의 회전의 구현
![3차원 공간에서의 회전의 구현](/img/)

따라서 3차원 공간에서의 회전은 다음과 같은 식이 될 것이다.

$$\vec{v^{'}} = \vec{v_\parallel} + q \cdot \vec{v_\perp}$$

***오일러 공식***을 활용해 위 수식을 간단하게 정리한다.       
이 식에서 회전 사원수 $q$를 자연지수함수로 바꿔 표현하면 다음과 같다.

$$\vec{v^{'}} = \vec{v_\parallel} + e^{\vec{n}\theta} \cdot \vec{v_\perp}$$

우변의 두 번째 항인 회전 사원수와 벡터와의 곱셈은 다음과 같이 간략하게 전개된다.

$$
\begin{matrix}
e^{\vec{n}\theta} \cdot \vec{v_\perp} &=& (-\sin \theta (\vec{n} \cdot \vec{v_\perp}), \cos \theta \vec{v_\perp} + \sin \theta (\vec{n} \times \vec{v_\perp})) \\
&=& (0, \cos \theta \vec{v_\perp} + \sin \theta (\vec{n} \times \vec{v_\perp})) \\
\end{matrix}
$$

회전축 $\vec{n}$와 이에 직교하는 벡터 $\vec{v_\perp}$의 내적은 항상 0이다.

이로써 회전축에 수직인 벡터와 회전 사원수의 곱으로 얻어지는 사원수는 항상 실수부 값이 0인 순허수 사원수가 되므로, 이의 결과는 언제나 3차원 공간의 벡터에 대응됨을 확인할 수 있다.

3차원 공간의 회전식을 간략하게 정리하도록 연산 순서를 바꾼다.       
연산 순서를 변경하면 ***외적의 성질***에 의해 $\sin$ ***함수의 부호가 반대로 바뀐다***.

$$\vec{v_\perp} \cdot e^{\vec{n} \theta} = (0, \cos \theta \vec{v_\perp} - \sin \theta (\vec{n} \times \vec{v_\perp}))$$

그러고 나서 회전 각에 $-\theta$를 대입하면, 이는 $\sin$ 함수에만 영향을 미치므로 다음과 같이 바뀐다.

$$
\begin{matrix}
\vec{v_\perp} \cdot e^{\vec{n}(-\theta)} &=& (0, \cos(-\theta) \vec{v_\perp} - \sin(-\theta)(\vec{n} \times \vec{v_\perp})) \\
&=& (0, \cos \theta \vec{v_\perp} + \sin \theta (\vec{n} \times \vec{v_\perp})) \\
\end{matrix}
$$

두 항의 순서를 바꿔 연산한 결과는 처음 식과 동일하므로 회전축과 직교하는 벡터에 대해서는 다음과 같은 식이 성립한다.

$$e^{\vec{n}\theta} \cdot \vec{v_\perp} = \vec{v_\perp} \cdot e^{\vec{n}(-\theta)}$$

수식에 등장하지 않지만 회전축에 평행한 벡터 $\vec{v_\parallel}$의 회전 사원수 곱이 가지는 성질을 살펴보자.      
평행인 두 벡터의 외적은 영벡터가 되므로 실수부가 남고 허수부가 단순화된다.

$$e^{\vec{n}\theta} \cdot \vec{v_\parallel} = (-\sin \theta (\vec{n} \cdot \vec{v_\parallel}), \cos \theta \vec{v_\parallel})$$

이때 사원수 곱에서 ***교환법칙의 성립을 방해하던 외적 부분***이 사라졌기 때문에, 평행인 벡터와의 곱은 다음과 같이 ***항상 교환법칙이 성립***한다.

$$e^{\vec{n}\theta} \cdot \vec{v_\parallel} = \vec{v_\parallel} \cdot e^{\vec{n}\theta}$$

식을 좀 더 단순화하기 위해, 회전 사원수를 둘로 쪼개서 나타낸다.     
각 $\theta$의 회전을 수행하는 회전 사원수는 이를 절반으로 나눈 각 $\frac{\theta}{2}$의 회전 사원수를 두 번 곱한 결과와 동일하다.

$$e^{\vec{n}\theta} = e^{\vec{n}(\frac{\theta}{2})} \cdot e^{\vec{n}(\frac{\theta}{2})}$$

회전 사원수와 그 켤레 사원수와의 곱은 아무런 변화 없는 $0^\circ$ 회전을 만들어내므로, 이들의 곱은 곱셈의 항등원 1에 대응된다.

$$1 = e^{0} = e^{\vec{n}(\frac{\theta}{2})} \cdot e^{\vec{n}(-\frac{\theta}{2})}$$

직교하는 벡터와 평행하는 벡터의 성질을 파악했다면, 이를 활용해 3차원 공간에서의 회전을 전개하면 다음과 같이 정리된다.

$$
\begin{matrix}
v' &=& \vec{v_\parallel} + e^{\vec{n}\theta} \cdot \vec{v_\perp} \\
&=& e^0 \cdot \vec{v_\parallel} + e^{\vec{n}\theta} \cdot \vec{v_\perp} \\
&=& e^{\vec{n}(\frac{\theta}{2})} \cdot e^{\vec{n}(-\frac{\theta}{2})} \cdot \vec{v_\parallel} + e^{\vec{n}(\frac{\theta}{2})} \cdot e^{\vec{n}(\frac{\theta}{2})} \cdot \vec{v_\perp} \\
&=& e^{\vec{n}(\frac{\theta}{2})} \cdot \vec{v_\parallel} \cdot e^{\vec{n}(-\frac{\theta}{2})} + e^{\vec{n}(\frac{\theta}{2})} \cdot \vec{v_\perp} \cdot e^{\vec{n}(-\frac{\theta}{2})} \\
&=& e^{\vec{n}(\frac{\theta}{2})} \cdot (\vec{v_\parallel} + \vec{v_\perp}) \cdot e^{\vec{n}(-\frac{\theta}{2})} \\
&=& e^{\vec{n}(\frac{\theta}{2})} \cdot \vec{v} \cdot e^{\vec{n}(-\frac{\theta}{2})} \\
\end{matrix}
$$

1. 평행한 벡터 $\vec{v_\parallel}$의 계수 1을 지수함수로 바꿔 표현한다.
2. 평행한 벡터의 계수는 두 개의 상반되는 회전의 곱으로 표현하고, 직교하는 벡터의 계수에 적용하는 회전은 절반 회전의 곱으로 표현한다.
3. 평행한 벡터와의 곱은 교환법칙이 성립하고, 직교하는 벡터와의 곱은 연산 순서를 바꿨을 때 각의 부호가 반대로 바뀐다.
4. 사원수는 덧셈의 분배법칙이 성립하므로 묶을 수 있다.
5. 평행한 벡터와 직교하는 벡터의 합은 원 벡터 $\vec{v}$가 된다.

간략해진 최종 식에서 자연지수함수를 다시 사원수의 형태로 바꾼다.        
각 $\theta$가 아닌 이의 절반값 $\frac{\theta}{2}$만큼 돌리는 회전 사원수를 $q$로 표현한다.      
반대 방향으로 돌리는 사원수는 켤레 사원수 $q^*$가 된다.

$$e^{\vec{n}(\frac{\theta}{2})} = q$$

3차원 공간의 회전을 보장하는 사원수의 회전식은 [식 14-1](#식-14-1)과 같이 최종 정리된다.

###### 식 14-1

$$
\begin{matrix}
v' &=& e^{\vec{n}(\frac{\theta}{2})} \cdot \vec{v} \cdot e^{\vec{n}(-\frac{\theta}{2})} \\
&=& q \cdot v \cdot q^* \\
\end{matrix}
$$

회전 사원수에 사용한 각은 $\frac{\theta}{2}$이므로 여기에 사용한 사원수 $q$의 값은 다음과 같다.

$$q = (\cos \frac{\theta}{2}, \sin \frac{\theta}{2}\vec{n})$$

3차원 공간의 회전을 보장하는 사원수의 회전식이 [식 14-1](#식-14-1)로 깔끔하게 정리된다.     
절반의 각만 회전시키는 단위 사원수를 임의의 벡터와 곱했을 때 그 결과는 항상 실수부가 0인 순허수 사원수가 나오는지 확인해보자.       
회전 사원수 $q$의 실수부와 허수부를 각각 $w$와 $\vec{r}$로 표시해 식을 간단하게 전개한다.

$$q = (\cos \frac{\theta}{2}, \sin \frac{\theta}{2}\vec{n}) = (w, \vec{r})$$

[식 14-1](#식-14-1)을 내적과 외적의 형태로 바꾸면 다음과 같이 전개된다.

$$
\begin{matrix}
v' &=& q \cdot v \cdot q* \\
&=& (w, \vec{r}) \cdot (0, \vec{v}) \cdot (w, -\vec{r}) \\
&=& (-(\vec{r} \cdot \vec{v}), w\vec{v} + \vec{r} \times \vec{v}) \cdot (w, -\vec{r}) \\
&=& (-(\vec{r} \cdot \vec{v})w - (w\vec{v} + \vec{r} \times \vec{v}) \cdot (-\vec{r}), -(\vec{r} \cdot \vec{v}) \cdot -\vec{r} + w(w\vec{v} + \vec{r} \times \vec{v}) + (w\vec{v} + \vec{r} \times \vec{v}) \times -\vec{r}) \\
\end{matrix}
$$

이 결과 중에서 실수부와 허수부를 다음과 같이 각각 따로 전개한다.        
우선 첫 항인 실수부를 전개하면 다음과 같다.

$$
\begin{matrix}
-(\vec{r} \cdot \vec{v})w - (w\vec{v} + \vec{r} \times \vec{v}) \cdot (-\vec{r}) &=& -(\vec{r} \cdot \vec{v})w + w(\vec{v} \cdot \vec{r}) + (\vec{r} \times \vec{v}) \cdot \vec{r} \\
&=& -(\vec{r} \cdot \vec{v})w + w(\vec{v} \cdot \vec{r}) \\
&=& -(\vec{r} \cdot \vec{v})w + (\vec{r} \cdot \vec{v})w \\
&=& 0
\end{matrix}
$$

1. $(\vec{r} \times \vec{v}) \cdot \vec{r}$ 항의 결과는 외적으로 직교하는 벡터를 생성한 후에 이를 내적하므로 언제나 0이 나온다.
2. 내적은 교환법칙이 성립하므로 스칼라와 벡터의 순서를 동일하게 맞춰준다.

[식 14-1](#식-14-1)을 내적과 외적으로 전개했을 때 실수부 값은 언제나 0이 나온다.        
이는 [그림 14-6](#그림-14-6-실수부가-0인-3차원-공간에서의-회전을-보장하는-사원수의-곱셈-공식)과 같이 절반의 각과 그 켤레를 사용해 회전시킨 결과는 항상 3차원 공간의 벡터에 대응된다고 할 수 있다.

###### 그림 14-6 실수부가 0인 3차원 공간에서의 회전을 보장하는 사원수의 곱셈 공식
![실수부가 0인 3차원 공간에서의 회전을 보장하는 사원수의 곱셈 공식](/img/)

허수부의 결과는 어떻게 정리되는지 확인해보자.       
허수부는 사원수를 사용해 회전된 벡터 $\vec{v'}$가 나온다.       
허수부의 수식을 전개하면 다음과 같다.

$$
\begin{matrix}
\vec{v'} &=& -(\vec{r} \cdot \vec{v}) \cdot -\vec{r} + w(w\vec{v} + \vec{r} \times \vec{v}) + (w\vec{v} + \vec{r} \times \vec{v}) \times -\vec{r} \\
&=& (\vec{r} \cdot \vec{v}) \cdot \vec{r} + w^2\vec{v} + w(\vec{r} \times \vec{v}) - w(\vec{v} \times \vec{r}) - (\vec{r} \times \vec{v}) \times \vec{r} \\
&=& (\vec{r} \cdot \vec{v}) \cdot \vec{r} + w^2\vec{v} + 2w(\vec{r} \times \vec{v}) - (\vec{r} \times \vec{v}) \times \vec{r} \\
&=& (\vec{r} \cdot \vec{v}) \cdot \vec{r} + (1 - \vec{r} \cdot \vec{r}) \cdot \vec{v} + 2w(\vec{r} \times \vec{v}) - (\vec{r} \times \vec{v}) - (\vec{r} \times \vec{v}) \times \vec{r} \\
&=& \vec{v} + (\vec{r} \cdot \vec{v}) \cdot \vec{r} - (\vec{r} \cdot \vec{r}) \cdot \vec{v} + 2w(\vec{r} \times \vec{v}) - (\vec{r} \times \vec{v}) \times \vec{r} \\
&=& \vec{v} + \vec{r} \times (\vec{r} \times \vec{v}) + 2w(\vec{r} \times \vec{v}) - (\vec{r} \times \vec{v}) \times \vec{r} \\
&=& \vec{v} + 2w(\vec{r} \times \vec{v}) + 2(\vec{r} \times (\vec{r} \times \vec{v})) \\
\end{matrix}
$$

1. 외적은 순서를 바꾸면 반대 부호가 나오므로 $w(\vec{r} \times \vec{v}) - w(\vec{v} \times \vec{r})$는 $2w(\vec{r} \times \vec{v})$가 된다.
2. 회전 사원수는 단위 사원수이므로 $w^2 + |\vec{r}|^2 = 1$이 성립하는데, 이를 내적으로 바꾸면 $w^2 = 1 - \vec{r} \cdot \vec{r}$이 성립한다.
3. 벡터 삼중곱 공식을 사용해 $(\vec{r} \cdot \vec{v}) \cdot \vec{r} - (\vec{r} \cdot \vec{r}) \cdot \vec{v}$를 벡터 삼중곱 $\vec{r} \times (\vec{r} \times \vec{v})$로 치환한다.
4. 마지막 항에 위치한 외적식의 순서를 뒤집어 벡터 삼중곱으로 변환한 외적식과 함께 묶는다.

최종 값 $\vec{v} + 2w(\vec{r} \times \vec{v}) + 2(\vec{r} \times (\vec{r} \times \vec{v}))$에서 $2(\vec{r} \times \vec{v})$를 벡터 $\vec{t}$로 치환하면 위 식은 [식 14-2](#식-14-2)와 같이 단순하게 정리된다.

###### 식 14-2

$$\vec{v'} = \vec{v} + w\vec{t} + \vec{r} \times \vec{t}$$

이로써 사원수를 사용해 3차원 공간의 벡터 $\vec{v}$를 임의의 회전축 $\vec{n}$을 중심으로 각 $\theta$만큼 회전시키는 최종 수식이 완성된다.

[식 14-2](#식-14-2)를 $\frac{\theta}{2}$가 아닌 각 $\theta$를 중심으로 전개하면 [식 9-2](#식-9-2)의 로드리게스 회전 공식이 유도된다.

$$
\begin{matrix}
\vec{v'} &=& \vec{v} + 2w(\vec{r} \times \vec{v}) + 2(\vec{r} \times (\vec{r} \times \vec{v})) \\
&=& \vec{v} + 2 \cos \frac{\theta}{2}(\sin\frac{\theta}{2}\vec{n}\times \vec{v}) + 2(\sin\frac{\theta}{2}\vec{n} \times (\sin \frac{\theta}{2} \vec{n} \times \vec{v})) \\
&=& \vec{v} + 2 \cos \frac{\theta}{2}\sin\frac{\theta}{2}(\vec{n} \times \vec{v}) + 2\sin^2 \frac{\theta}{2}(\vec{n} \times (\vec{n} \times \vec{v})) \\
&=& \vec{v} + \sin(\frac{\theta}{2} + \frac{\theta}{2})(\vec{n} \times \vec{v}) + (1 - \cos(\frac{\theta}{2} + \frac{\theta}{2})) (\vec{n} \times (\vec{n} \times \vec{v})) \\
&=& \vec{v} + \sin \theta(\vec{n} \times \vec{v}) + (1 - \cos \theta)((\vec{n} \cdot \vec{v})\vec{n} - (\vec{n} \cdot \vec{n})\vec{v}) \\
&=& \vec{v} - (1 - \cos \theta)(\vec{n} \cdot \vec{n})\vec{v} + \sin \theta(\vec{n} \times \vec{v}) + (1 - \cos \theta)(\vec{n} \cdot \vec{v})\vec{n} \\
&=& \cos \theta \vec{v} + (1 - \cos \theta)(\vec{n} \cdot \vec{v})\vec{n} + \sin \theta(\vec{n} \times \vec{v}) \\
\end{matrix}
$$

1. [식 14-2](#식-14-2)를 삼각함수와 회전축으로 바꿔 표현한다.
2. 각 요소에 사용한 모든 삼각함수 값을 계수로 빼서 정리한다.
3. 삼각함수의 배각 공식 $\sin 2\theta = 2\sin\theta \cos \theta$와 $\cos 2 \theta = 1- 2\sin^2\theta$를 사용해 $\frac{\theta}{2}$의 삼각함수를 $\theta$의 삼각함수로 변경한다.
4. 벡터 삼중곱을 내적으로 구성된 수식으로 변경한다.

이로써 회전 사원수의 벡터부에서 설정한 벡터 $\vec{n}$은 축-각 회전에서 회전축의 기능을 수행한다는 사실을 확인할 수 있다.        
그리고 각 $\theta$를 기준으로 전개했을 때보다 각 $\frac{\theta}{2}$를 기준으로 전개했을 때 식이 더 간편해진다는 것을 알 수 있다.

같은 회전축에 두 개의 다른 각을 연속해서 회전시키는 경우를 알아보자.        
첫 번째 각의 크기를 $2\alpha$, 두 번째 각의 크기를 $2\beta$로 지정하고 회전할 벡터를 $\vec{v}$, 첫 번째 회전을 적용한 벡터를 $\vec{v'}$, 두 번째 회전을 적용한 벡터를 $\vec{v''}$로 표기하면 두 회전 변환을 적용한 식은 다음과 같다.

$$\vec{v'} = q_\alpha \cdot \vec{v} \cdot q^*_\alpha$$

$$\vec{v''} = q_\beta \cdot \vec{v'} \cdot q^*_\beta$$

벡터 $\vec{v'}$를 $q_\alpha \cdot \vec{v} \cdot q^*_\alpha$로 치환하면 $\vec{v''}$를 계산하는 식은 다음과 같이 전개된다.

$$
\begin{matrix}
\vec{v''} &=& q_\beta \cdot (q_\alpha \cdot \vec{v} \cdot q_\alpha^*) \cdot q_\beta^* \\
&=& (q_\beta \cdot q_\alpha) \cdot \vec{v} \cdot (q_\alpha^* \cdot q_\beta^*) \\
&=& (q_\beta \cdot q_\alpha) \cdot \vec{v} \cdot (q_\beta \cdot q_\alpha)^* \\
&=& q_{(\alpha + \beta)} \cdot \vec{v} \cdot q^*_{(\alpha + \beta)} \\
\end{matrix}
$$

1. 사원수의 곱셈은 결합법칙을 만족하므로 벡터를 가운데 두고 양 옆으로 묶을 수 있다.
2. 켤레 사원수로 묶으면 두 사원수의 순서는 뒤집힌다.
3. 두 회전 사원수의 곱은 두 각을 더한 회전 사원수와 동일하다.

이로써 ***3차원 공간의 회전을 위해 절반의 각과 켤레 사원수를 사용하더라도 서로 다른 두 회전 사원수의 곱은 두 각을 합한 회전 사원수와 형태가 동일하다***는 점을 확인할 수 있다.        

# 51. 사원수의 변환
사원수를 활용해 3차원 벡터를 회전시키는 기능을 구현할 수 있지만, 사원수를 구성하는 요소 값은 직관적이지 않아 실제로 사용하는 회전을 설계할 때 어려움이 따른다.

3차원 공간에서 물체의 회전을 설정할 때에는 오일러 각 방식이 사원수보다 직관적이고 편리하기 때문에, 오일러 각의 값을 사원수로 변환해주는 기능을 만들면 게임 제작에 유용하게 사용할 수 있다.

# 51.1. 오일러 각에서 사원수로의 변환
***오일러 각의 각 회전은*** $x, y, z$ ***기저 축이 회전축의 역할을 수행***한다.     
3차원 공간에서 $x$축을 중심으로 각 $\theta$만큼 회전시키는 데 사용하는 회전 사원수 $q$는 다음과 같다.

$$q = (\cos \frac{\theta}{2}, \sin \frac{\theta}{2} \cdot \vec{x}) = \cos \frac{\theta}{2} + \sin \frac{\theta}{2} i$$

따라서 오일러 각을 구성하는 롤, 피치, 요 회전에 대응하는 각 사원수 $q_{roll}, q_{pitch}, q_{yaw}$는 각각 다음과 같이 표기된다.

$$q_{roll} = \cos \frac{\theta_{roll}}{2} + \sin \frac{\theta_{roll}}{2}k$$

$$q_{pitch} = \cos \frac{\theta_{pitch}}{2} + \sin \frac{\theta_{pitch}}{2}i$$

$$q_{yaw} = \cos \frac{\theta_{yaw}}{2} + \sin \frac{\theta_{yaw}}{2}j$$

오일러 각의 회전 순서를 롤, 피치, 요 순으로 적용하고, 이에 대응하는 사원수를 동일한 순서에 맞춰서 곱하면 오일러 각에 대응하는 사원수가 만들어진다.        
이를 계산하면 [식 14-3](#식-14-3)과 같다.

###### 식 14-3

$$q_{yaw} \cdot q_{pitch} \cdot q_{roll} = \cos \frac{\theta_{roll}}{2} \cos \frac{\theta_{pitch}}{2} \cos \frac{\theta_{yaw}}{2} + \sin \frac{\theta_{roll}}{2} \sin \frac{\theta_{pitch}}{2} \sin \frac{\theta_{yaw}}{2} + \\
(\cos \frac{\theta_{roll}}{2} \sin \frac{\theta_{pitch}}{2} \cos \frac{\theta_{yaw}}{2} + \sin \frac{\theta_{roll}}{2} \cos \frac{\theta_{pitch}}{2} \sin \frac{\theta_{yaw}}{2})i + \\
(\cos \frac{\theta_{roll}}{2} \cos \frac{\theta_{pitch}}{2} \sin \frac{\theta_{yaw}}{2} - \sin \frac{\theta_{roll}}{2} \sin \frac{\theta_{pitch}}{2} \cos \frac{\theta_{yaw}}{2})j + \\
(\sin \frac{\theta_{roll}}{2} \cos \frac{\theta_{pitch}}{2} \cos \frac{\theta_{yaw}}{2} - \cos \frac{\theta_{roll}}{2} \sin \frac{\theta_{pitch}}{2} \sin \frac{\theta_{yaw}}{2})k$$

# 51.2. 사원수에서 오일러 각으로의 변환
거꾸로 사원수로부터 오일러 각의 값을 변환하는 방법에 대해 알아보자.     
[식 14-3](#식-14-3)에서 실수부를 $w$, 각 허수부 값을 $x, y, z$로 치환한 후 $2(wz + xy)$를 계산한 결과를 살펴본다.       
요, 롤 피치의 절반각을 $y, r, p$로 표기하고, 이들의 $\sin$ 값을 $sy, sr, sp$로 지정하고 $\cos$ 값을 $cr, cp, cy$로 지정해 식을 전개하면 다음과 같다.

$$
\begin{matrix}
w &=& cr \cdot cp \cdot cy + sr \cdot sp \cdot sy \\
z &=& sr \cdot cp \cdot cy - cr \cdot sp \cdot sy \\
wz &=& cy^2 \cdot cr \cdot cp^2 \cdot sr - cy \cdot ct^2 \cdot cp \cdot sy \cdot sp + cy \cdot cp \cdot sy \cdot sr^2 \cdot sp - cr \cdot sy^2 \cdot sr \cdot sp^2 \\
x &=& sy \cdot sr \cdot cp + sp \cdot cy \cdot cr \\
y &=& sy \cdot cp \cdot cr - sp \cdot sr \cdot cy \\
xy &=& cr \cdot cp^2 \cdot sy^2 \cdot sr - cy \cdot cp \cdot sy \cdot sr^2 \cdot sp + cy \cdot cr^2 \cdot cp \cdot sy \cdot sp - cy^2 \cdot cr \cdot sr \cdot sp^2 \\
\end{matrix}
$$

사원수로부터 오일러 각을 구하려면 사원수를 잘 조합해 단일 각에 대한 삼각함수가 나오도록 식을 설정해야 한다.     
롤 회전에 대한 삼각함수를 만들어주는 $wz + xy$의 값을 계산한다.

$$
\begin{matrix}
wz + xy &=& cr \cdot cp^2 \cdot sr - (cy \cdot cp \cdot sy \cdot sp) + cy \cdot cp \cdot sy \cdot sp - (cr \cdot sr \cdot sp^2) \\
&=& cr \cdot sr(cp^2 - sp^2) \\
&=& \frac{\sin(2r)}{2} \cdot \cos (2p) \\
\end{matrix}
$$

삼각함수의 배각 공식을 사용해 두 배의 각으로 변환한다.

$2(wz + xy)$의 값은 $\sin\theta_{roll} \cdot \cos \theta_{pitch}$가 된다.       
같은 방식으로 $1 - 2(z^2 + x^2)$를 계산하면 $\cos \theta_{roll} \cdot \cos \theta_{pitch}$가 된다.      
그렇다면 $\sin\theta_{roll} \cdot \cos\theta_{pitch}$ 값을 $\cos\theta_{roll} \cdot \cos \theta_{pitch}$로 나누면 다음과 같이 롤 회전의 $\tan$ 값이 나온다.

$$\frac{\sin\theta_{roll} \cdot \cos\theta_{pitch}}{\cos\theta_{roll} \cdot \cos\theta_{pitch}} = \tan\theta_{roll} = \frac{2(wz + xy)}{(1 - 2(z^2 + x^2))}$$

이제 롤 회전의 값은 $\arctan$ 함수를 사용해 구할 수 있다.

$$\theta_{roll} = atan2(2(wz + xy), 1 - 2(z^2 + x^2))$$

피치 회전에 대한 삼각함수를 만들어주는 $wx - yz$ 값은 다음과 같이 전개된다.

$$
\begin{matrix}
wx - yz &=& \sin\frac{\theta_{pitch}}{2} \cdot \cos\frac{\theta_{pitch}}{2} \\
&=& \frac{1}{2}\sin\theta_{pitch} \\
\end{matrix}
$$

$\sin$ 함수의 배각 공식을 사용해 간략화 한다.

따라서 피치 회전각은 $\arcsin$ 함수를 사용해 구할 수 있다.

$$\theta_{pitch} = asin(2(wx - yz))$$

이때 주의할 점은 $\arcsin$ 함수의 정의역은 $|-1, 1|$ 범위로 제한되어 있으므로 $wx - yz$ 값이 $|-0.5, 0.5|$ 범위를 벗어나지 않는지 확인하고 벗어나는 경우에는 범위 내 가장 가까운 값으로 설정해야 한다.

요 회전은 롤 회전과 유사한 방식으로 요 회전의 $\tan$ 함수 값을 구한 후 $\arctan$ 함수를 사용한다.

$$\theta_{yaw} = atan2(2(wy + xz), 1 - 2(x^2 + y^2))$$

# 51.3. 사원수에서 회전 변환행렬로의 변환
사원수에서 회전 변환행렬로 변환하는 식을 계산해보자.        
***회전 변환행렬은 로컬 축으로 구성***되어 있기 때문에 사원수를 사용해 회전된 세 로컬 축의 값을 구하면 쉽게 해결할 수 있다.       
[식 14-2](#식-14-2)를 활용해 사원수로 로컬축을 회전한 결과를 계산한다.

사원수를 구성하는 네 요소를 $x, y, z, w$라고 할 때 $\vec{r}$의 값은 $(x, y, z)$이 되고 여기에 회전시킬 벡터 값을 $\vec{v}$에 대입하면 외적 식으로 회전된 벡터 값을 계산할 수 있다.      
먼저 회전할 벡터는 $x$축 기저벡터 $(1, 0, 0)$이다.      
이를 계산한 결과는 사원수에 의해 회전된 $x$ 로컬 축을 의미한다.

$$
\begin{matrix}
x_{local} &=& (1, 0, 0) + w(0, 2z, -2y) + (x, y, z) \times (0, 2z, -2y) \\
&=& (1, 2zw, -2yw) + (-2y^2 - 2z^2, 2xy, 2xz) \\
&=& (1 - 2(y^2 + z^2), 2(xy + zw), 2(xz - yw)) \\
\end{matrix}
$$

마찬가지로 동일한 사원수에 벡터 $(0, 1, 0), (0, 0, 1)$을 곱하면 각각 다음 식이 나온다.

$$y_{local} = (2(xy - zw), 1 - 2(x^2 + z^2), 2(yz + xw))$$

$$z_{local} = (2(xz + yw), 2(yz - xw), 1 - 2(x^2 + y^2))$$

모든 로컬 축을 구했다면, 이들을 꽂아 넣으면 회전 변환행렬을 만들 수 있다.

###### 식 14-4

$$
\begin{bmatrix}
1-2(y^2 + z^2) & 2(xy - zw) & 2(xz + yw) \\
2(xy + zw) & 1-2(x^2 + z^2) & 2(yz - xw) \\
2(xz - yw) & 2(yz + xw) & 1-2(x^2 + y^2) \\
\end{bmatrix}
$$

# 51.4. 회전 변환행렬에서 사원수로의 변환
회전 변환행렬에서 사원수를 구하는 방법을 알아보자.      
[식 14-4](#식-14-4)를 통해 사원수에서 회전행렬을 구하는 식을 확인했다.      
행렬의 요소를 조합해서 사원수를 구성하는 $x, y, z, w$ 값을 개별로 구하는 방법을 찾아야 한다.        
이는 정방행렬의 모든 대각 성분의 합을 더하는 것에서 실마리를 찾을 수 있다.      
***정방행렬의 대각 성분을 모두 더한 값***을 ***트레이스(Trace)*** 라고 하는데, [그림 14-7](#그림-14-7-정방행렬에서의-트레이스의-표현)과 같이 행렬의 성분과 연산을 표현한다.

###### 그림 14-7 정방행렬에서의 트레이스의 표현
![정방행렬에서의 트레이스의 표현](/img/)

[식 14-4](#식-14-4)의 회전 변환행렬에서 대각행렬 값을 모두 더한 트레이스 $t$는 다음과 같이 계산된다.

$$
\begin{matrix}
t &=& 1 - 2(y^2 + z^2) + 1-2(x^2 + z^2) + 1-2(x^2 + y^2) \\
&=& 3-4(x^2 + y^2 + z^2) \\
\end{matrix}
$$

여기에 1을 더하면 제곱근을 씌울 수 있는 형태가 나오는데 크기가 1인 회전 사원수의 성질에 의해 $x^2 + y^2 + z^2$의 값은 $1 - w^2$이 되므로 트레이스 값은 $4w^2$가 된다.

$$t + 1 = 4 - 4(x^2 + y^2 + z^2) = 4w^2$$

여기에 제곱근을 씌운 값에서 양수 값을 $r$로 지정하면 $r$과 트레이스 $t$의 관계는 다음과 같다.

$$r = 2w = \sqrt{t + 1}$$

사원수의 $w$값은 다음과 같이 구할 수 있다.

$$w = \frac{1}{2}r$$

여기서 구한 $w$ 값을 이용해 나머지 값 $x, y, z$를 구한다.       
회전 변환행렬을 살펴보면 대각 방향으로 대칭된 행렬의 요소를 서로 빼면 두 사원수 요소의 곱으로 정리된다.     
예를 들어 두 번째 열 벡터의 세 번째 요소에서 세 번째 열벡터의 두 번째 요소를 빼면 다음 식이 만들어진다.

$$2yz + 2xw - 2yz + 2xw = 4xw$$

이 식을 그림으로 나타내보면 [그림 14-8]과 같다.     
[그림 14-7](#그림-14-7-정방행렬에서의-트레이스의-표현)과 색상이 다른 부분은 빼는 요소를 의미한다.

###### 그림 14-8 xw값을 구하기 위한 행렬의 성분
![xw값을 구하기 위한 행렬의 성분](/img/)

비슷한 방법으로 세 번째 열벡터의 첫 번째 요소에서 첫 번째 열벡터의 세 번째 요소를 빼면 $yw$를 구할 수 있다.

$$2xz + 2yw - 2xz + 2yw = 4yw$$

마지막으로 첫 번째 열벡터의 두 번째 요소에서 두 번째 열벡터의 첫 번째 요소를 빼면 $zw$값이 얻어진다.

$$2xy + 2zw - 2xy + 2zw = 4zw$$

[그림 14-9](#그림-14-9-yw-zw-값을-구하기-위한-행렬의-성분)의 (a)에 $yw$를 구하는 식에 사용하는 행렬의 요소를, (b)에는 $zw$를 구하는 식에 사용되는 행렬의 요소를 정리한다.

###### 그림 14-9 yw, zw 값을 구하기 위한 행렬의 성분
![yw, zw 값으 구하기 위한 행렬의 성분](/img/)

이 방식으로 사원수를 구할 때는 예외 사항이 있다.      
트레이스 값이 -1보다 작거나 같으면 제곱근을 구하는 값이 0보다 작거나 같아져 $w$를 구하는 데 필요한 $r$의 해가 존재하지 않는다.      
예를 들어 $y$축으로 180도 회전하는 행렬은 $x$ 기저와 $z$ 기저를 반대 방향으로 돌리므로 다음과 같이 구성된다.

$$
\begin{bmatrix}
-1 & 0 & 0 \\
0 & 1 & 0 \\
0 & 0 & -1 \\
\end{bmatrix}
$$

이 행렬을 사용하는 경우 트레이스 값은 -1이 되고 $w$값은 0이 된다.     
0의 역수는 존재하지 않기 때문에 나머지 값들을 구할 수 없게 된다.        
이러한 경우, $w$가 아닌 다른 요소부터 계산한 후에 이로부터 다른 성분을 구하도록 계산 방법을 우회해야 한다.      
주어진 회전 변환행렬에서 첫 번째 대각 성분과 두 번째와 세 번째 대각 성분을 빼면 다음과 같다.

$$1 - 2y^2 - 2z^2 - 1 + 2x^2 + 2z^2 - 1 + 2x^2 + 2y^2 = -1 + 4x^2$$

그렇다면 이를 사용해 $x$값을 구할 수 있다.      
이 수식을 그림으로 표현하면 [그림 14-10](#그림-14-10-예외-상황에서-x값을-구하기-위한-대각-성분)과 같다.

###### 그림 14-10 예외 상황에서 x값을 구하기 위한 대각 성분
![예외 상황에서 x값을 구하기 위한 대각 성분](/img/)

$y$값은 두 번째 대각 성분에 첫 번째와 세 번째를 빼서 얻을 수 있으며 $z$값은 세 번째 대각 성분에 첫 번째와 두 번째를 빼서 얻을 수 있다.      
$y, z$값을 구하는 식을 만들기 위한 행렬의 요소를 순서대로 정리하면 [그림 14-11](#그림-14-11-y-z값을-구하기-위한-대각-성분)과 같다.

###### 그림 14-11 y, z값을 구하기 위한 대각 성분
![y, z값을 구하기 위한 대각 성분](/img/)

예외 상황을 감안해 회전 변환행렬로부터 사원수를 구하는 알고리즘이 1985년에 ***켄 슈메이크(Ken Shoemake)*** 에 의해 고안됐다.       
먼저 회전 변환행렬의 트레이스 값을 구하고 그 값이 충분히 큰지를 파악한다.       
***이론적으로 트레이스 값이 -1보다 크면*** $w$ ***값 계산이 가능하지만, -1에 가까워질수록 오차가 발생***하므로 ***트레이스 값이 0보다 큰 경우에만 트레이스 값을 토대로 사원수의 모든 요소를 구하는 로직을 적용***한다.     
***나머지 트레이스 값이 0보다 작거나 같은 경우에는 예외 상황으로 간주해 다른 값부터 구하는 것이 이 알고리즘의 핵심***이다.        
$w$를 제외하고 $x, y, z$ 중에서 가장 큰 요소를 파악한다.        
각 대각행렬의 요소 값을 비교하면 확인할 수 있다.        
예를 들어 대각행렬의 첫 번째 대각 요소와 두 번째 대각 요소의 크기를 비교했을 때 두 번째 요소 값이 크다면 $y$의 크기는 $x$보다 크다는 의미다.

$$1 - 2(y^2 + z^2) < 1 - 2(x^2 + z^2)$$

$$-y^2 < -x^2$$

이 과정을 한 번 더 거치면 $x, y, z$에서 가장 큰 요소를 찾을 수 있다.        
이렇게 파악된 가장 큰 요소의 값을 먼저 구한다.      
참고로 제곱근으로 해를 구할 때는 항상 양수를 사용한다.      
이와 같은 방법으로 가장 큰 수를 구했다면 나머지 두 요소는 $xy, yz, xz$ 값으로부터 얻을 수 있는데 이들을 구하기 위한 행렬의 요소를 [그림 14-12](#그림-14-12-순서대로-xy-yz-xz-값을-구하기-위한-행렬의-성분)에 (a), (b), (c) 순서대로 정리한다.

###### 그림 14-12 순서대로 xy, yz, xz 값을 구하기 위한 행렬의 성분
![순서대로 xy, yz, xz 값을 구하기 위한 행렬의 성분](/img/)

$x, y, z$를 모두 구했다면 마지막 $w$값은 [그림 14-8](#그림-14-8-xw값을-구하기-위한-행렬의-성분)과 [그림 14-9](#그림-14-9-yw-zw-값을-구하기-위한-행렬의-성분)에서 구한 $xw, yw, zw$의 값으로부터 구한다.     

# 52. 사원수의 보간
***사원수는 로드리게스 회전과 동일한 축-각 방식을 사용해 3차원 공간의 회전을 표현***한다.     
사원수를 사용하는 경우의 장점을 열거해보면 다음과 같다.     

- ***오일러 각과 쉽게 변환이 가능***하며 ***회전행렬 제작이 용이***하다.
- ***임의의 축에 대한 회전 표현이 가능***하기 때문에 ***짐벌락 현상을 방지***할 수 있다.
- ***임의의 축에 대한 회전 보간 값***을 구할 수 있다.
- ***4개의 숫자로 회전을 표현***하기 때문에 저장 공간을 효율적으로 쓸 수 있다.

또한 사원수는 행렬과 상호 변환이 가능하다.      
다른 회전 방식과 비교한 사원수의 장단점은 [표 14-3](#식-14-3)과 같다.

###### 표 14-3 3차원 회전 표현의 장단점 비교

||오일러 각|행렬|사원수|
|---|---|---|---|
|저장공간|가장 작다. 저장 공간의 수는 3|크다. 저장 공간의 수는 9|작다. 저장 공간의 수는 4|
|짐벌락 현상|발생|발생하지 않음|발생하지 않음|
|회전 보간|한 기저 축에 대해서만 가능|불가능|임의의 축에 가능|
|직관성|직관적이다.|직관적이지 않다.|직관적이지 않다.|

다른 회전 방식에 비해 ***사원수가 가지는 장점***은 ***회전 보간이 가능***하다는 것이다.     
사원수를 4차원 공간의 벡터로 생각하고, 두 사원수가 만들어내는 4차원 공간에서의 평면을 상상해보자.   
해당 평면에서 주어진 비율 $t$에 대응하는 사원수는 두 사원수의 위치를 선형 보간한 지점이 된다.       
두 사원수가 만든 평면에서 $\frac{1}{3}$만큼 보간된 사원수를 구하는 방법은 [그림 14-13](#그림-14-13-시작점-q_1에서-끝점-q_2까지-13-만큼-선형-보간된-사원수의-위치)과 같이 계산할 수 있다.

###### 그림 14-13 시작점 q_1에서 끝점 q_2까지 1/3 만큼 선형 보간된 사원수의 위치
![시작점 q_1에서 끝점 q_2까지 1/3 만큼 선형 보간된 사원수의 위치](/img/)

주어진 비율 $t$에 대응하는 중간 사원수를 구하는 식은 다음과 같다.

$$q(t) = (1 - t) \cdot q_1 + t \cdot q_2$$

하지만 선형 보간으로 얻어지는 사원수는 크기가 1인 단위 사원수가 아니기 때문에 해당 사원수를 회전에 사용하려면 정규화 과정을 거쳐야 한다.

$$q' = \frac{q(t)}{|q(t)|}$$

***선형 보간법은 빠르고 간편***하게 사용할 수 있지만, ***원의 궤적을 따라 발생하는 회전을 정확히 반영하지는 못한다***.      
좀 더 높은 수준의 결과물을 위해 회전의 움직임을 따르는 중간 사원수를 구하려면 두 사원수가 이루는 각을 $\theta$로 지정하고 주어진 비율 $t$를 사용해 두 각을 각각 $t\theta$와 $(1 - t)\theta$로 나눠야 한다.      
이해를 돕기 위해 비율값 $t$로 $\frac{1}{3}$이 주어졌다면 구하려는 최종 회전 사원수 값은 [그림 14-14](#그림-14-14-구면으로-보간된-사원수와-직선으로-보간된-사원수의-비교)와 같이 계산될 것이다.

###### 그림 14-14 구면으로 보간된 사원수와 직선으로 보간된 사원수의 비교
![구면으로 보간된 사원수와 직선으로 보간된 사원수의 비교](/img/)

이를 만족시키는 선형 보간식의 두 계수 $\alpha$와 $\beta$값을 찾아야 한다.

###### 식 14-5

$$q' = \alpha \cdot q_1 + \beta \cdot q_2$$

[그림 14-15](#그림-14-15-구면으로-보간된-사원수를-평면의-벡터로-표현하기)와 같이 첫 번째 사원수를 $x$축에 일치시키고 이를 회전한 값을 구한다.        
첫 번째 사원수에 해당하는 벡터를 $\vec{x}$, 두 번째 사원수에 해당하는 벡터를 $\vec{u}$라고 할 때, $\vec{x}$에 직교하는 벡터를 $\vec{y}$로, 구해야 할 중간 사원수의 벡터를 $\vec{v}$로 정한다.

###### 그림 14-15 구면으로 보간된 사원수를 평면의 벡터로 표현하기
![구면으로 보간된 사원수를 평면의 벡터로 표현하기](/img/)

[식 14-5](#식-14-5)는 다음과 같이 벡터로 바꿔 쓸 수 있다.

###### 식 14-6

$$\vec{v} = \alpha \cdot \vec{x} + \beta \cdot \vec{u}$$

두 사원수가 만드는 각을 $\theta$라고 했을 때 우리가 구하려는 벡터 $\vec{v}$는 서로 직교하는 두 기저벡터 $\vec{x}$와 $\vec{y}$의 조합으로 계산된다.

###### 식 14-7

$$\vec{v} = \cos(t\theta) \vec{x} + \sin(t\theta) \vec{y}$$

앞에서 예로 든 비율 $\frac{1}{3}$에 대한 계산은 [그림 14-16](#그림-14-16-직교하는-두-기저벡터를-사용한-중간-벡터의-계산)과 같다.

###### 그림 14-16 직교하는 두 기저벡터를 사용한 중간 벡터의 계산
![직교하는 두 기저벡터를 사용한 중간 벡터의 계산](/img/)

벡터 $\vec{x}$에 직교하는 벡터 $\vec{y}$ 값을 모르므로 벡터 $\vec{u}$와 삼각함수를 활용해 이를 구해야 한다.     
[그림 14-17](#그림-14-17-두-번째-사원수로부터-직교하는-벡터-y-구하기)을 보면 $\vec{u} - \cos \theta \vec{x}$ 값과 $\sin \theta \cdot \vec{y}$ 값은 동일한 벡터를 가리킨다.

###### 그림 14-17 두 번째 사원수로부터 직교하는 벡터 y 구하기
![두 번째 사원수로부터 직교하는 벡터 y 구하기](/img/)

이를 활용하면 벡터 $\vec{y}$의 값은 다음과 같이 구할 수 있다.

$$\vec{y} = \frac{\vec{u} - \cos \theta \vec{x}}{\sin \theta}$$

이 값을 [식 14-7](#식-14-7)에 대입하면 최종 벡터를 구하는 식은 다음과 같이 전개된다.

$$
\begin{matrix}
\vec{v} &=& \cos(t\theta)\vec{x} + \sin(t\theta)(\frac{\vec{u} - \cos\theta\vec{x}}{\sin\theta}) \\
&=& (\frac{\sin\theta\cos(t\theta) - \cos\theta\sin(t\theta)}{\sin\theta})\vec{x} + \frac{\sin(t\theta)}{\sin\theta}\vec{u} \\
&=& \frac{\sin(\theta - t\theta)}{\sin \theta}\vec{x} + \frac{\sin(t\theta)}{\sin\theta}\vec{u} \\
\end{matrix}
$$

1. $\vec{x}$와 $\vec{u}$에 대해 묶는다.
2. $\vec{x}$의 계수는 삼각함수의 합 공식에 의해 간략히 정리된다.

위 식을 [식 14-6](#식-14-6)에 대입하면 찾아야 하는 두 계수 $\alpha$와 $\beta$는 각각 다음과 같다.

$$\alpha = \frac{\sin((1 - t)\theta)}{\sin\theta}$$

$$\beta = \frac{\sin(t\theta)}{\sin\theta}$$

위에서 구한 계수를 [식 14-5](#식-14-5)에 대입하면 구면으로 보간하는 최종 식이 만들어진다.

###### 식 14-8

$$q' = \frac{\sin((1-t)\theta)}{\sin \theta} \cdot q_1 + \frac{\sin(t\theta)}{\sin\theta} \cdot q_2$$

이 방법으로 보간하는 방법을 ***구면 선형 보간(Spherical linear interpolation)*** 이라고 하며, 줄여서 ***슬럽(Slerp)*** 이라 부른다.       
사원수의 구면 선형 보간을 구현하는 데 필요한 두 계수의 식 외에 고려할 점이 몇 가지 있다.        
먼저 ***두 사원수로부터 나오는 회전 경로는 항상 긴 경로와 짧은 경로의 두 가지가 있는데, 이 중에 하나를 선택***해야 한다는 점이다.     
[그림 14-18](#그림-14-18-두-벡터의-사잇각을-구하는-방법)과 같이 원 위에 벡터 $\vec{v_1}$와 벡터 $\vec{v_2}$가 있을 때 두 벡터가 만들어내는 회전 경로는 언제나 짧은 경로 $\theta_1$과 긴 경로 $\theta_2$ 두 가지가 존재한다.     
***일반적으로는 짧은 경로를 사용***한다.

###### 그림 14-18 두 벡터의 사잇각을 구하는 방법
![두 벡터의 사잇각을 구하는 방법](/img/)

[그림 14-18](#그림-14-18-두-벡터의-사잇각을-구하는-방법)의 경우 벡터 $\vec{v_1}$에서 벡터 $\vec{v_2}$로 순서대로 구면 선형 보간을 적용하면 짧은 경로에서의 보간이 진행된다.     
하지만 두 벡터가 [그림 14-19](#그림-14-19-벡터의-각이-긴-경로의-각으로-설정된-경우)와 같이 배치되어 있다면 구면 선형 보간은 긴 경로로 진행된다.

###### 그림 14-19 벡터의 각이 긴 경로의 각으로 설정된 경우
![벡터의 각이 긴 경로의 각으로 설정된 경우](/img/)

따라서 언제나 짧은 경로로 구면 선형 보간하고자 한다면, 구면 선형 보간을 진행하기 전에 두 벡터의 사잇각이 $180^\circ$보다 작은지부터 확인해야 한다.      
이보다 큰 경우에는 짧은 경로의 결과가 나오도록 계산 방법을 조정해야 한다.

두 벡터가 이루는 각을 조사하면 쉽게 해결 할 수 있지만, 현재 사용하는 사원수에는 항상 회전시키고자 하는 각의 절반이 저장되어 있기 때문에, 이를 감안해야 한다.        
예를 들어 사원수 $(0, (1, 0, 0))$에 대해 생각해보자.        
사원수 $(0, (1, 0, 0))$을 4차원 공간의 회전에 사용한다면 이는 $(\cos \theta, \sin \theta \vec{n})$로 해석되므로 $x$축을 중심으로 $90^\circ$로 회전 변환하는 회전 사원수가 된다.     
하지만 사원수 $(0, (1, 0, 0))$을 3차원 공간의 회전에 사용한다면 $(\cos \frac{\theta}{2}, \sin \frac{\theta}{2}\vec{n})$로 해석되어야 한다.      
이 경우에는 앞에서 살펴본 $v' = q \cdot v \cdot q^*$ 공식을 거쳐 3차원 공간에서 $x$축을 중심으로 하는 $180^\circ$ 회전 변환을 만들어낸다.       
[그림 14-20](#그림-14-20-사원수에-담긴-각의-정보)은 이에 관한 예시다.        
어떤 사원수에 저장된 각이 $120^\circ$라면, 해당 사원수를 통해 구현된 3차원 공간의 회전은 그 두 배인 $240^\circ$가 된다.

###### 그림 14-20 사원수에 담긴 각의 정보
![사원수에 담긴 각의 정보](/img/)

그렇기 때문에 긴 경로를 탐지하는 조건도 바뀐다.     
해당 경로가 긴 경로인지 여부를 탐지하기 위해 두 사원수가 이루는 사잇각은 $180^\circ$가 아닌 $90^\circ$가 되어야 한다.       
그렇다면 긴 경로인지 파악하기 위한 사잇각의 최소 크기는 $90^\circ$가 되며 이는 ***내적을 사용해 판별이 가능***하다.       
두 사원수의 내적 값이 음수가 나오면 두 사원수가 이루는 사잇각이 $90^\circ$보다 크다는 의미이며, 이는 긴 경로의 회전에 사원수가 사용된다고 판단할 수 있다.       
이 경우에는 두 번째 사원수를 짧은 경로의 사원수로 바꿔주어야 한다.

짧은 경로의 사원수는 사원수를 반전시키는 것으로 간단히 처리할 수 있다.      
예를 들어 두 사원수의 사잇각이 $120^\circ$인 경우, 실제 진행되는 $240^\circ$ 회전에 대응하는 짧은 경로의 회전은 $-120^\circ$ 회전이 된다.       
짧은 경로의 $-120^\circ$ 회전에 대응하는 사원수는 그 절반인 $-60^\circ$ 사잇각을 가진 사원수가 된다.        
이는 [그림 14-21](#그림-14-21-사원수를-반전시켜-짧은-거리의-사원수를-구하는-예시)과 같이 $120^\circ$ 사잇각을 가진 사원수 $q_2$를 반전해 얻을 수 있다.

###### 그림 14-21 사원수를 반전시켜 짧은 거리의 사원수를 구하는 예시
![사원수를 반전시켜 짧은 거리의 사원수를 구하는 예시](/img/)

구면 선형 보간을 구현할 때 고려할 점은 입력으로 들어온 두 사원수의 방향이 평행하면 분모 $\sin \theta$의 값이 0이 되어 [식 14-8](#식-14-8)의 구면 선형 보간 계산이 불가능해진다는 것이다.        
이 경우 긴 경로인지를 파악하기 위해 이미 계산했던 내적을 활용해 파악할 수 있다.     
내적 값의 크기가 1이면 두 사원수는 평행한 상태이기 때문이다.        
따라서 오차까지 감안해 두 사원수의 내적이 1과 매우 근접한 경우에는 일반 선형 보간을 사용하도록 로직을 만들어야 한다.

***구면 선형 보간은 카메라의 움직임이나 캐릭터 애니메이션과 같이 시간에 따른 부드러운 회전을 구현하는 데 유용하게 사용***된다.        