# 게임 수학 정리 문서
게임 개발에 필요한 수학 개념에 대해 정리한 문서입니다.

# 목차
* [1. 수와 집합](README.md/#1-수와-집합)
    * [1.1. 연산과 수의 구조](README.md/#11-연산과-수의-구조)
    * [1.2. 수의 구조](README.md/#12-수의-구조)
    * [1.3. 수의 표현](README.md/#13-수의-표현)
* [2. 함수](README.md/#2-함수)
    * [2.1. 함수의 개념과 종류](README.md/#21-함수의-개념과-종류)
    * [2.2. 합성함수](README.md/#22-합성함수)
    * [2.3. 항등함수와 역함수](README.md/#23-항등함수와-역함수)
    * [2.4. 곱집합을 활용한 좌표 평면으로의 확장](README.md/#24-곱집합을-활용한-좌표-평면으로의-확장)
* [3. 데카르트 좌표계](README.md/#3-데카르트-좌표계)
* [4. 벡터 공간과 벡터](README.md/#4-벡터-공간과-벡터)
    * [4.1. 스칼라와 벡터](README.md/#41-스칼라와-벡터)
    * [4.2. 벡터 공간의 연산](README.md/#42-벡터-공간의-연산)
    * [4.3. 벡터의 크기와 이동](README.md/#43-벡터의-크기와-이동)
* [5. 벡터의 결합과 생성](README.md/#5-벡터의-결합과-생성)
* [6. 삼각함수](README.md/#6-삼각함수)
    * [6.1. 삼각함수의 성질](README.md/#61-삼각함수의-성질)
    * [6.2. 각의 측정법](README.md/#62-각의-측정법)
* [7. 삼각함수를 활용한 물체의 회전](README.md/#7-삼각함수를-활용한-물체의-회전)
* [8. 삼각함수의 역함수](README.md/#8-삼각함수의-역함수)
* [9. 극좌표계](README.md/#9-극좌표계)
* [10. 선형성: 예측 가능한 비례 관계](README.md/#10-선형성-예측-가능한-비례-관계)
    * [10.1. 선형 함수](README.md/#101-선형-함수)
    * [10.2. 벡터 공간의 선형 변환](README.md/#102-벡터-공간의-선형-변환)
* [11. 행렬](README.md/#11-행렬)
    * [11.1. 행렬의 기본 연산](README.md/#111-행렬의-기본-연산)
    * [11.2. 행렬의 곱셈](README.md/#112-행렬의-곱셈)
    * [11.3. 정방행렬의 곱셈](README.md/#113-정방행렬의-곱셈)
* [12. 행렬의 설계](README.md/#12-행렬의-설계)
    * [12.1. 크기 변환행렬](README.md/#121-크기-변환행렬)
    * [12.2. 회전 변환행렬](README.md/#122-회전-변환행렬)
    * [12.3. 전단 변환행렬](README.md/#123-전단-변환행렬)
    * [12.4. 삼각함수의 덧셈 정리](README.md/#124-삼각함수의-덧셈-정리)
* [13. 역행렬](README.md/#13-역행렬)
    * [13.1. 역행렬의 존재를 판별하는 행렬식](README.md/#131-역행렬의-존재를-판별하는-행렬식)
    * [13.2. 크기 변환행렬의 역행렬](README.md/#132-크기-변환행렬의-역행렬)
    * [13.3. 전단 변환행렬의 역행렬](README.md/#133-전단-변환행렬의-역행렬)
    * [13.4. 회전 변환행렬의 역행렬](README.md/#134-회전-변환행렬의-역행렬)
    * [13.5. 행렬 곱의 역행렬](README.md/#135-행렬-곱의-역행렬)
* [14. 이동 변환을 위한 아핀 공간](README.md/#14-이동-변환을-위한-아핀-공간)
* [15. 아핀 공간의 구성 요소](README.md/#15-아핀-공간의-구성-요소)
    * [15.1. 점](README.md/#151-점)
    * [15.2. 이동 벡터](README.md/#152-이동-벡터)
    * [15.3. 아핀 공간의 성질](README.md/#153-아핀-공간의-성질)
* [16. 아핀 결합](README.md/#16-아핀-결합)
    * [16.1. 두 점의 결합](README.md/#161-두-점의-결합)
* [17. 벡터의 내적](README.md/#17-벡터의-내적)
    * [17.1. 내적의 성질](README.md/#171-내적의-성질)
    * [17.2. 내적과 삼각함수의 관계](README.md/#172-내적과-삼각함수의-관계)
    * [17.3. 행렬의 곱셈을 내적으로 표현하기](README.md/#173-행렬의-곱셈을-내적으로-표현하기)
* [18. 시야 판별](README.md/#18-시야-판별)
    * [18.1. 앞뒤 판별](README.md/#181-앞뒤-판별)
    * [18.2. 시야 판별](README.md/#182-시야-판별)
* [19. 조명 효과의 구현](README.md/#19-조명-효과의-구현)
* [20. 투영 벡터](README.md/#20-투영-벡터)
* [21. 세 점의 결합](README.md/#21-세-점의-결합)
* [22. 메시](README.md/#22-메시)
* [23. 무게중심좌표](README.md/#23-무게중심좌표)
    * [23.1. 무게중심좌표의 계산](README.md/#231-무게중심좌표의-계산)
* [24. 텍스처 매핑](README.md/#24-텍스처-매핑)
* [25. 3차원 공간의 설계](README.md/#25-3차원-공간의-설계)
* [26. 3차원 공간의 트랜스폼](README.md/#26-3차원-공간의-트랜스폼)
    * [26.1. 오일러 각](README.md/#261오일러-각)
    * [26.2. 회전행렬의 유도](README.md/#262-회전행렬의-유도)
    * [26.3. 3차원 모델링 행렬](README.md/#263-3차원-모델링-행렬)
* [27. 카메라 공간](#27-카메라-공간)
* [28. 오일러 각의 특징](#28-오일러-각의-특징)
    * [28.1 짐벌락 현상](#281-짐벌락-현상)
    * [28.2 회전 보간의 계산](#282-회전-보간의-계산)
* [29. 벡터의 외적](#29-벡터의-외적)
    * [29.1. 평행성 판별](#291-평행성-판별)
    * [29.2. 법선 벡터](#292-법선-벡터)
    * [29.3. 좌우 방향 판별](#293-좌우-방향-판별)
* [30. 벡터로부터 회전행렬 생성](#30-벡터로부터-회전행렬-생성)
* [31. 렌더링 계산량을 줄여주는 백페이스 컬링](#31-렌더링-계산량을-줄여주는-백페이스-컬링)
* [32. 오일러 각의 문제를 해결하는 로드리게스 회전 공식](#32-오일러-각의-문제를-해결하는-로드리게스-회전-공식)
* [33. 삼중곱](#33-삼중곱)
    * [33.1. 스칼라 삼중곱](#331-스칼라-삼중곱)
    * [33.2. 벡터 삼중곱](#332-벡터-삼중곱)
* [34. 원근 투영 변환의 원리](#34-원근-투영-변환의-원리)
* [35. 동차 좌표계](#35-동차-좌표계)
* [36. 깊이 값](#36-깊이-값)
* [37. 원근 보정 매핑](#37-원근-보정-매핑)
* [38. 깊이 버퍼](#38-깊이-버퍼)
* [39. 절두체 컬링](#39-절두체-컬링)
    * [39.1. 평면의 방정식](#391-평면의-방정식)
    * [39.2. 평면의 방정식의 정규화](#392-평면의-방정식의-정규화)
    * [39.3. 평면의 방정식을 활용한 절두체 표현](#393-평면의-방정식을-활용한-절두체-표현)
    * [39.4. 원근 투영 행렬로부터 평면의 방정식 만들기](#394-원근-투영-행렬로부터-평면의-방정식-만들기)
* [40. 바운딩 볼륨](#40-바운딩-볼륨)
    * [40.1. 구 바운딩 볼륨의 판정](#401-구-바운딩-볼륨의-판정)
    * [40.2. aabb와의 판정](#402-aabb와의-판정)
* [41. 삼각형 클리핑](#41-삼각형-클리핑)
* [42. 복소수](#42-복소수)
    * [42.1. 허수](#421-허수)
    * [42.2. 복소수의 구조](#422-복소수의-구조)
* [43. 복소평면](#43-복소평면)
    * [43.1. 단위 복소수와의 곱](#431-단위-복소수와의-곱)
    * [43.2. 켤레 복소수의 회전 변환](#432-켤레-복소수의-회전-변환)
* [44. 복소수와 행렬의 관계](#44-복소수와-행렬의-관계)
* [45. 자연지수함수](#45-자연지수함수)
    * [45.1. 무리수 e](#451-무리수-e)
    * [45.2. 자연지수함수](#452-자연지수함수)
* [46. 미분](#46-미분)
    * [46.1. 도함수](#461-도함수)
    * [46.2. 자연지수함수의 도함수)](#462-자연지수함수의-도함수)
    * [46.3. sin 함수와 cos 함수의 도함수)](#463-sin-함수와-cos-함수의-도함수)
* [47. 급수](#47-급수)
    * [47.1. 등비수열](#471-등비수열)
    * [47.2. 급수](#472-급수)
    * [47.3. 매클로린 급수](#473-매클로린-급수)
* [48. 오일러 공식](#48-오일러-공식)
* [49. 사원수 대수](#49-사원수-대수)
    * [49.1. 사원수를 구성하는 세 허수](#491-사원수를-구성하는-세-허수)
    * [49.2. 사원수의 구조](#492-사원수의-구조)
    * [49.3. 사원수와 벡터](#493-사원수와-벡터)
* [50. 사원수의 회전](#50-사원수의-회전)
    * [50.1. 사원수와 오일러 공식](#501-사원수와-오일러-공식)
    * [50.2. 회전 사원수를 이용한 3차원 공간에서의 회전](#502-회전-사원수를-이용한-3차원-공간에서의-회전)
* [51. 사원수의 변환](#51-사원수의-변환)
    * [51.1. 오일러 각에서 사원수로의 변환](#511-오일러-각에서-사원수로의-변환)
    * [51.2. 사원수에서 오일러 각으로의 변환](#512-사원수에서-오일러-각으로의-변환)
    * [51.3. 사원수에서 회전 변환행렬로의 변환](#513-사원수에서-회전-변환행렬로의-변환)
    * [51.4. 회전 변환행렬에서 사원수로의 변환](#514-회전-변환행렬에서-사원수로의-변환)
* [52. 사원수의 보간](#52-사원수의-보간)

# 27. 카메라 공간
### 선요약

> 2차원 카메라를 구현할 때에는 이동 기능만 부여했지만 3차원 공간의 카메라에는 이동과 회전 기능을 함께 부여한다
> 
> - 월드 공간: 원본 3차원 공간
> - 뷰 공간: 월드 공간의 원점에 카메라가 있고, 카메라가 바라보는 방향에 게임 오브젝트가 위치한 상황을 가정했을 때 카메라의 $x$축과 $y$축으로 최종 화면을 생성하면 화면의 $x$축 방향은 익숙한 오른쪽이 아닌 왼쪽을 향하게 된다     
> 이는 보편적으로 인지하는 2차원 데카르트 좌표계와 다르기 때문에 카메라가 만들어내는 화면의 $x$축이 왼쪽을 향하도록 $y$축으로 $180^\circ$ 회전시켜 뷰 공간을 구성한다     
> 뷰 공간의 $z$축은 카메라의 뒤를 향하고, 뷰 공간에서 $x$축과 $z$축은 월드 공간의 $x$축과 $z$축의 반대 방향을 가지게 된다
> - 뷰 행렬: 뷰 공간으로 변환해주는 행렬      
> 카메라에는 크기의 개념이 없기 때문에, 카메라의 트랜스폼은 크기 변환을 제외한 회전과 이동 변환으로만 구성된다    
> 뷰 행렬을 구하기 위해선 카메라의 역행렬을 계산해야 한다     
> 이동 $T$의 역행렬 $T^{-1}$은 덧셈의 역원인 반대수를 사용해 구할 수 있다
> 이동의 역행렬을 적용하면 모든 좌표는 카메라를 중심으로 재배치된다      
> 직교행렬인 회전 변환행렬 $R$의 역행렬 $R^{-1}$은 전치행렬로 구할 수 있다        
> 물체는 가만히 있는데 카메라가 $30^\circ$ 회전하는 상황이라면, 화면을 바라보는 사용자는 마치 물체가 $-30^\circ$ 회전하는 것으로 느낀다       
> 최종 뷰 행렬을 완성하기 위해서 이동의 역행렬을 적용한 후 회전의 역행렬을 적용해야 한다      
> 카메라의 트랜스폼으로부터 얻어지는 모델링 행렬 $M$의 역행렬 $M^{-1}$을 만든다       
> 최종 뷰 좌표계는 $y$축으로 $180^\circ$ 회전한 구조를 가져야 하기 때문에 $x$축 기저와 $z$축 기저를 반전시킨다        
> 반전을 적용한 최종 뷰 행렬 $V$는 다음과 같다
> 
> $$V = R^{-1} \cdot T^{-1} =
\begin{bmatrix}
-x_x & -x_y & -x_z & x \cdot t \\
y_x & y_y & y_z & -y \cdot t \\
-z_x & -z_y & -z_z & z \cdot t \\
0 & 0 & 0 & 1 \\
\end{bmatrix}$$
> 
> 뷰 좌표계에서 카메라 정면에 위치한 모든 물체의 $z$값은 음수다

* * *

[본문](README-ORIGIN2.md#27-카메라-공간)

# 28. 오일러 각의 특징
### 선요약

> 오일러 각 장점:
> - 오일러 각은 3차원 공간의 회전을 지정할 때 직관적인 인터페이스를 제공한다         
> - 설정할 값이 세 가지뿐이고, 직관적인 표준기저벡터를 회전축으로 사용하기 때문에 회전을 설계하기가 용이하다    
> - 오일러 각은 적은 용량으로 3차원 공간의 회전 정보를 기록할 수 있다       
> - 행렬을 사용해 3차원 공간의 회전을 표현하려면 최소 9개의 실수 데이터가 필요하지만, 오일러 각은 3개의 데이터만 있으면 3차원 공간의 회전을 표현할 수 있다      
> - 이는 트랜스폼 정보를 줄일 수 있어 적은 용량으로 게임 데이터를 관리할 수 있게 도와준다
>
> 오일러 각 단점:
> - 짐벌락 현상

* * *

[본문](README-ORIGIN2.md#28-오일러-각의-특징)

# 28.1. 짐벌락 현상
### 선요약

> 짐벌락(Gimbal lock):
> - 오일러 각을 사용해 3차원 공간의 회전을 다룰 때에 특정 상황에서 회전 움직임이 제한되는 현상       
> - 예를 들어 얼굴 모델링을 앞 방향인 $z$축으로 $90^\circ$ 회전시킨다면 얼굴 면이 반시계 방향으로 돌아가는 회전이 발생하고, 우측 방향인 $x$축으로 $-90^\circ$ 회전시켜보면 목을 중심으로 시계 방향으로 돌아가서 위를 바라보게 된다      
> - 마지막으로 위쪽 방향인 $y$축 회전을 적용하면 얼굴 면이 돌아가는 회전이 되는데, 이는 처음 진행한 $z$축의 회전과 동일하다     
> - 결과적으로 $z$축과 $y$축은 얼굴을 돌리는 동일한 회전이 되어버려, 세 개의 축으로 자유롭게 회전하지 못하고 두 개의 축만 회전에 사용된다       
> - 이렇게 회전이 제약되는 현상을 짐벌락이라고 한다

* * *

[본문](README-ORIGIN2.md#281-짐벌락-현상)

# 28.2. 회전 보간의 계산
### 선요약

> 회전 보간(Rotational interpolation): 
> - 3차원 공간에서 시작 회전과 끝 회전을 지정하고 시간에 따라 두 회전 사이를 부드럽게 전환하는 기능은 카메라의 움직임이나 캐릭터 애니메이션을 구현하는 데 필요하다       
> - 이를 구현하기 위해서 경과된 시간에 따라 회전이 변화되도록 중간 회전 값을 계산하는 작업이 회전 보간이다      
> - 중간 회전 값은 선형 보간의 식을 사용해 얻을 수 있다     
> $\theta' = (1 - t)\theta_{start} + t\theta_{end}$      
> - 선형 보간식이 성립하려면 두 각의 회전 변환을 곱한 결과가 두 각의 합의 회전 변환과 동일해야 한다     
> - 2차원 공간의 회전에서는 두 결과가 동일하기 때문에 2차원 공간의 회전에서 선형 보간식을 사용하는 데 아무런 문제가 없다        
> - 오일러 각에서 한 축만 사용한다는 것은 2차원 평면에서의 회전과 동일하기 때문에 선형 보간식을 사용할 수 있다      
> - 하지만 두 축 이상을 사용하는 오일러 각은 선형 보간식을 사용할 수 없다       
> - 3차원 공간에서 자유로운 회전 보간을 구현하고 싶은 경우에는 로드리게스 회전 공식을 사용하거나 사원수를 사용해야 한다

* * *

[본문](README-ORIGIN2.md#282-회전-보간의-계산)

# 29. 벡터의 외적
### 선요약

> 외적(Cross product):
> - 내적이 모든 차원의 벡터에 적용할 수 있는 것과 달리 외적은 3차원 공간의 벡터에서만 사용 가능한 연산이다       
> - 3차원 벡터의 외적은 $\times$기호를 사용한다         
> - 외적은 회전의 순환 순서 $x \rightarrow y \rightarrow z \rightarrow x$에 맞춰 벡터를 순서대로 나열하는 형태다
> - 외적의 결과는 언제나 3차원 벡터가 된다      
> - 외적 계산식의 패턴은 $x$ 성분의 결과를 만들기 위해 $x$와 관련없는 나머지 두 성분 $y$와 $z$를 결합해 만들고 나머지 $y$와 $z$를 만들 때도 동일하다      
> - 외적은 교환법칙이 성립하지 않는다     
> 교환법칙이 성립하지 않는 뺄셈을 사용하기 때문이다
> - 뺄셈에서 두 수의 순서를 바꿔 계산하면 반대수가 나오는 것처럼 외적도 순서를 바꿔 연산하면 반대 방향의 벡터가 나온다        
> $a - b = -(b - a)$      
> $\vec{u} \times \vec{v} = -\vec{v} \times \vec{u}$      
> - 외적은 결합법칙이 성립하지 않는다     
> $\vec{u} \times (\vec{v} \times \vec{w}) \neq (\vec{u} \times \vec{v}) \times \vec{w}$      
> - 덧셈에 대한 분배법칙은 성립한다       
> $\vec{u} \times (\vec{v} + \vec{w}) = \vec{u} \times \vec{v} + \vec{u} \times \vec{w}$      

* * *

[본문](README-ORIGIN2.md#29-벡터의-외적)

# 29.1. 평행성 판별
### 선요약

> 외적의 성질
> - 평행한 두 벡터를 외적하면 항상 영벡터가 된다      
> $\vec{u} \times \vec{u} = (u_yu_z - u_yu_z, u_zu_x - u_zu_x, u_xu_y - u_xu_y) = (0, 0, 0)$      
> $\vec{u} \times -\vec{u} = (-u_yu_z + u_yu_z, -u_zu_x + u_zu_x, -u_xu_y + u_xu_y) = (0, 0, 0)$      
> $\vec{v} = k \cdot \vec{u}, \quad \vec{u} \times \vec{v} = (ku_yu_z - ku_yu_z, ku_zu_x - ku_zu_x, ku_xu_y - ku_xu_y)$       
> 이러한 성질은 평행성을 판별하는 데 사용된다     
> 이는 두 벡터의 직교성을 판별하는 내적의 성질과 대립된다     
> - 외적은 상대방에 직교하는 벡터 성분만 사용된다         
> 벡터 $\vec{u}$를 벡터 $\vec{v}$에 수평인 벡터 $\vec{u_\parallel}$과 수직인 벡터 $\vec{u_\perp}$로 분리하면 벡터 $\vec{u}$는 수평 성분과 수직 성분의 덧셈으로 분리할 수 있다     
> 벡터 $\vec{u}$를 분리한 벡터 $\vec{u_\perp}, \vec{u_\parallel}$와 $\vec{v}$의 외적은 다음과 같이 전개된다       
> $\vec{v} \times \vec{u} = \vec{v} \times (\vec{u_\perp} + \vec{u_\parallel}) = \vec{v} \times \vec{u_\perp} + \vec{v} \times \vec{u_\parallel}$     
> 벡터 $\vec{v}$와 평행한 벡터 $\vec{u_\parallel}$와의 외적은 크기와 관계 없이 영벡터가 된다      
> 따라서 위 식은 다음과 같이 간략하게 정리된다        
> $\vec{v} \times \vec{u} = \vec{v} \times \vec{u_\perp}$
> - 외적의 크기는 $\sin$ 함수에 비례한다      
> 두 벡터의 사잇각을 $\theta$라고 할 때 두 벡터의 사잇각이 큰 직교 성분 $\vec{u_\perp}_\alpha$의 크기는 그보다 사잇각이 작은 직교 성분 $\vec{u_\perp}_\beta$보다 크다     
> 직교 성분 $\vec{u_\perp}$의 크기는 $\sin$ 함수에 비례하므로 외적의 크기도 $\sin$ 함수에 비례하는 것이다     
> $|\vec{u} \times \vec{v}| = |\vec{u}||\vec{v}||\sin \theta|$
> - 외적으로 생성된 벡터의 크기는 행렬식이 만들어내느 넓이와 동일하다

* * *

[본문](README-ORIGIN2.md#291-평행성-판별)

# 29.2. 법선 벡터
### 선요약

> 벡터 외적은 두 벡터에 직교하는 벡터를 생성한다      
> $\vec{u}$와 $\vec{v}$의 외적 결과에 벡터 $\vec{u}$를 내적하면 결과는 항상 0이 된다
> 
> $$\vec{u} \cdot (\vec{u} \times \vec{v}) = u_xu_yv_z - u_xv_yu_z + u_yu_zv_x - u_yv_zu_x + u_zu_xv_y - u_zv_xu_y = 0$$
> 
> 동일한 방법으로 $\vec{u}$와 $\vec{v}$의 외적 결과에 벡터 $\vec{v}$를 내적해도 0이 나온다        
> 벡터 $\vec{u}, \vec{v}$의 외적 결과는 벡터 $\vec{u}, \vec{v}$에 모두 직교함을 알 수 있다        
> 두 벡터의 외적은 두 벡터가 만드는 평면에 직교하는, 평면이 향하는 방향에 대한 벡터를 만들어내는 것으로 해석할 수 있다
> 
> 법선 벡터(Normal vector)
> - 평면이 향하는 방향을 나타내는 벡터      
> - 3개의 점 $P_1, P_2, P_3$를 결합해 만든 평면을 가정하고, 점 $P_2$와 $P_3$에서 점 $P_1$을 뺀 두 벡터 $\vec{u}$와 $\vec{v}$를 생성한 후 둘을 외적하면 세점이 만들어내는 평면에 직교하는 벡터가 생성된다        
> - 외적은 교환법칙이 성립하지 않기 때문에, 연산의 순서를 바꾸면 원본 연산의 반대 방향으로 향하는 법선 벡터가 생성된다

* * *

[본문](README-ORIGIN2.md#292-법선-벡터)

# 29.3. 좌우 방향 판별
### 선요약

> 좌우 방향 판별:
> - 월드 공간의 $y$축 $\vec{y} = (0, 1, 0)$에 직교하는 평면에 캐릭터와 물체가 놓여 있고, 캐릭터의 정면을 향하는 시선 벡터 $\vec{f}$와 캐릭터에서 물체로 향하는 벡터 $\vec{v}$가 주어진 상황을 가정한다
> - 물체가 시선 방향의 왼쪽에 있다면 시선 벡터 $\vec{f}$에서 물체로 향하는 벡터 $\vec{v}$로 외적한 결과는 오른손 법칙에 따라 평면의 위쪽인 $\vec{y}$로 향한다
> - 반대로 물체가 시선 방향의 오른쪽에 있다면 외적의 결과는 평면의 아래쪽인 $-\vec{y}$로 향한다
> - 이러한 성질을 활용하면 시선 방향을 기준으로 물체가 왼쪽에 있는지 오른쪽에 있는지를 파악할 수 있다     
> - 외적의 결과는 벡터이므로, 참 거짓을 파악할 수 있도록 스칼라로 변환한다      
> 이를 위해서는 외적의 결과에 내적을 추가로 활용할 수 있다        
> 외적의 결과에 평면의 위쪽 방향을 나타내는 벡터 $\vec{y}$를 내적한다     
> 두 벡터의 방향이 같다면 내적 값은 양수, 반대 방향이라면 음수가 된다     
> 따라서 물체가 캐릭터의 시선 방향 왼쪽에 있다면 내적의 결과는 양수, 오른쪽에 있다면 음수가 된다      
> - 물체가 시선 방향에서 왼쪽에 있는 경우: $(\vec{f} \times \vec{v}) \cdot \vec{y} > 0$
> - 물체가 시선 방향에서 오른쪽에 있는 경우: $(\vec{f} \times \vec{v}) \cdot \vec{y} < 0$
> - 물체가 정확히 시선 방향과 일치하는 경우: $(\vec{f} \times \vec{v}) = 0$

* * *

[본문](README-ORIGIN2.md#293-좌우-방향-판별)

# 30. 벡터로부터 회전행렬 생성
### 선요약

> 카메라의 회전 설정:
> - 3차원 공간에서 좌우로 기울어지지 않은 카메라가 아래쪽에 위치한 물체를 바라보고 있는 상황을 가정한다
> - 오일러 각 방식을 사용해 카메라의 회전을 지정할 수 있지만, 외적을 사용하면 카메라의 시선 벡터 정보로부터 카메라의 세 가지 로컬 축을 구하고 이로부터 회전행렬까지 얻어낼 수 있다
> - 물체의 위치에서 카메라 위치를 뺀 후 크기를 1로 정규화시킨 시선 벡터 $\vec{v}$를 생성한다      
> 이 벡터는 카메라 트랜스폼의 로컬 $z$축이 된다
> - 카메라의 로컬 $x$축은 업벡터(Up vector)라고도 불리는 월드 공간의 $y$축과 카메라의 로컬 $z$축을 외적하여 얻을 수 있다      
> 월드 공간의 $y$축을 벡터 $\vec{u}$로 표시하고 이를 카메라의 로컬 $z$축과 외적한 후 이를 정규화시키면 카메라의 로컬 $x$축이 구해진다     
> - 로컬 $z$축과 로컬 $x$축을 외적하면 남은 로컬 $y$축을 구할 수 있다     
> 두 벡터가 단위 벡터이므로 외적의 결과도 단위 벡터가 된다
> 
> $$\vec{x} = \frac{\vec{u} \times \vec{z}}{|\vec{u} \times \vec{z}|}$$
> 
> $$\vec{y} = \vec{z} \times \vec{x}$$
> 
> $$\vec{z} = \frac{\vec{v}}{|\vec{v}|}$$
> 
> - 카메라 트랜스폼의 회전행렬 $R$은 로컬 벡터를 열벡터로 지정해 생성할 수 있다
> 
> $$R = 
\begin{bmatrix}
x_x & y_x & z_x & 0 \\
x_y & y_y & z_y & 0 \\
x_z & y_z & z_z & 0 \\
0 & 0 & 0 & 1 \\
\end{bmatrix}$$
> 
> - 예외 상황: 일반적인 상황에서 카메라의 위쪽 방향이 월드 공간의 $y$을 향한다고 가정한다     
> 하지만 카메라가 거꾸로 뒤집혀 있는 상황이라면, 로컬 $x$축을 구하기 위한 업벡터로 월드 공간 $y$축의 반대 방향인 $(0, -1, 0)$을 사용해야 한다

* * *

[본문](README-ORIGIN2.md#30-벡터로부터-회전행렬-생성)

# 31. 렌더링 계산량을 줄여주는 백페이스 컬링
### 선요약

> 백페이스 컬링(Backface culling): 
> - 카메라와 마주보지 않는 뒷면을 생략하는 기법      
> - 게임은 실시간으로 빠르게 렌더링을 처리해야 하기 때문에 시선에 감지되지 않는 메시(Mesh)의 뒷면(Backface)은 그리지 않고 건너뛰는 것이 효과적이다      
> - 백페이스 컬링은 메시의 삼각형을 구성하는 세 정점의 외적을 활용해 구현할 수 있다       
> - 시계 방향으로 정점이 나열되어 있으면 삼각형이 향하는 방향은 지면의 뒤편을 향하게 되고, 반시계 방향으로 정점이 나열되어 있으면 지면을 향한다
> - 삼각형의 방향과 카메라의 시선 방향을 대조해 서로 마주보면 삼각형을 그리고, 같은 방향을 바라보면 그리기를 생략하는 것이 백페이스 컬링 알고리즘이다

* * *

[본문](README-ORIGIN2.md#31-렌더링-계산량을-줄여주는-백페이스-컬링)

# 32. 오일러 각의 문제를 해결하는 로드리게스 회전 공식
### 선요약

> 축-각 회전(Axis-Angle rotation):    
> - 임의의 축에 대한 평면의 회전 방식    
> - 3차원 회전을 관리하기 위해 오일러 각을 사용하고 있지만, 오일러 각은 짐벌락 현상이 발생하고, 회전 보간이 어렵다      
> - 축-각 회전은 3차원 공간에서 지정된 임의의 축에 직교하는 평면에 회전이 진행되는 형태로 이 문제를 해결한다
> - 회전축은 회전이 발생하는 평면에 직교하는 법선 벡터다      
> 이를 벡터 $\vec{n}$으로 지정하고 편의를 위해 크기를 1로 정규화시킨다        
> 회전시킬 점을 $P$, 점 $P$가 각 $\theta$만큼 회전한 최종 점을 $P'$으로 표기하고, 월드 공간의 원점을 $O$로, 회전 평면의 중심점을 $O'$으로 지정한다        
> 이때 점 $P$의 좌표는 다음과 같이 설정한다       
> $P = (x, y, z, 1)$
> - 원점 $O$에서부터 회전시킬 점 $P$까지의 벡터를 $\vec{u}$로 지정한다        
> 점 $P$와 벡터 $\vec{u}$의 값은 마지막 차원 값만 다를 뿐 $(x, y, z)$의 값은 동일하다     
> 따라서 구해야할 점 $P'$의 좌표는 벡터 $\vec{u}$를 구한다면 얻을 수 있다     
> $\vec{u} = P - O = (x, y, z, 0)$
> - 임의의 축 $\hat{n}$에 대해 벡터 $\vec{u}$를 각 $\theta$만큼 회전시켜 벡터 $\vec{u'}$를 계산하는 축-각 회전의 공식(로드리게스 회전 공식)은 다음과 같다       
> $\vec{u'} = \cos \theta \cdot \vec{u} + (1 - \cos \theta) \cdot (\vec{u} \cdot \hat{n}) + \sin \theta \cdot (\hat{n} \times \vec{u})$
> 
> 로드리게스 회전 공식의 유도:
> - 원점에서 회전시킬 점으로 향하는 벡터 $\vec{u}$를 평면의 회전축에 해당하는 법선 벡터 $\hat{n}$에 투영한다
> - 벡터 $\vec{u}$가 투영할 벡터 $\hat{n}$의 크기가 1이므로 투영 공식에 의해 벡터 $\vec{OO'}$의 값은 $(\vec{u} \cdot \hat{n}) \cdot \hat{n}$이 되고 이를 벡터 $\vec{v}$로 설정한다        
> $\vec{OO'} = \vec{v} = (\vec{u} \cdot \hat{n}) \cdot \hat{n}$
> - 회전 평면의 중점 $O'$에서 점 $P$으로 향하는 벡터 $\vec{O'P}$는 두 벡터의 차가 되므로 $\vec{u} - \vec{v}$가 된다       
> $\vec{O'P} = \vec{u} - \vec{v}$
> - 회전 평면의 벡터 $\vec{O'P}$를 각 $\theta$만큼 회전시킨 벡터 $\vec{O'P'}$를 구한다
> - 벡터 $\vec{O'P'}$를 가로 성분과 세로 성분으로 분리하면, 가로 성분에 해당하는 벡터는 벡터 $\vec{O'P}$에 $\cos\theta$를 곱해 얻을 수 있다
> - 세로 성분에 해당하는 벡터를 구하려면 같은 방향을 향하는 벡터가 필요하다       
> 이는 법선 벡터 $\hat{n}$과 벡터 $\vec{O'P'}$를 외적해 얻을 수 있다      
> 이를 벡터 $\vec{O'Q}$로 지정한다면 벡터 $\vec{O'Q}$는 다음과 같이 구할 수 있다      
> $\vec{O'Q} = \hat{n} \times (\vec{u} - \vec{v})$        
> 벡터 $\vec{O'Q}$에 $\sin\theta$를 곱하면 세로 성분에 해당하는 벡터를 얻을 수 있다
> - 두 벡터를 모두 얻으면 다음의 수식으로 벡터 $\vec{O'P}$를 각 $\theta$만큼 회전한 벡터 $\vec{O'P'}$의 값을 얻게 된다        
> $\vec{O'P'} = \cos \theta \cdot \vec{O'P} + \sin \theta \cdot \vec{O'Q}$        
> 위 식을 벡터 $\hat{n}, \vec{u}$와 $\vec{v}$를 사용해 전개하면 다음과 같다       
> $\vec{O'P'} = \cos \theta \cdot (\vec{u} - \vec{v}) + \sin \theta \cdot (\hat{n} \times (\vec{u} - \vec{v}))$       
> 분배 법칙을 적용해 이를 풀어 전개하면 다음과 같다       
> $\vec{O'P'} = \cos \theta \cdot (\vec{u} - \vec{v}) + \sin \theta \cdot (\hat{n} \times \vec{u} - \hat{n} \times \vec{v})$
> - 벡터 $\hat{n}$과 $\vec{v}$는 평행하므로 우변의 끝에 위치한 외적 $\hat{n} \times \vec{v}$의 값은 항상 영벡터가 된다        
> 따라서 위 식은 다음과 같이 정리된다     
> $\vec{O'P'} = \cos \theta \cdot (\vec{u} - \vec{v}) + \sin \theta \cdot (\hat{n} \times \vec{u})$
> - 구해야할 최종 벡터 $\vec{OP'}$는 선분 $\vec{O'P'}$에 벡터 $\vec{v}$를 더해 얻을 수 있다       
> $\vec{OP'} = \cos \theta \cdot (\vec{u} - \vec{v}) + \sin \theta \cdot (\hat{n} \times \vec{u})$    
> - 벡터 $\vec{v}$를 $(\vec{u} \cdot \hat{n}) \cdot \hat{n}$로 치환하면 최종 수식이 유도된다      
> $\vec{u'} = \cos \theta \cdot \vec{u} + (1 - \cos \theta)(\vec{u} \cdot \hat{n}) \cdot \hat{n} + \sin \theta \cdot (\hat{n} \times \vec{u})$
> 
> 로드리게스 회전 공식을 활용하면 오일러 각으로 구현하기 어려운 임의의 축에 대한 회전 변환을 수행할 수 있다       
> 하지만 이 방식은 행렬로의 변환이 어렵다보니 렌더링 파이프라인에 연동하기가 까다롭다     
> 따라서 게임 엔진에서는 로드리게스 회전과 동일한 기능을 제공하면서도 간결하고 행렬로 변환이 용이한 사원수를 사용한다

* * *

[본문](README-ORIGIN2.md#32-오일러-각의-문제를-해결하는-로드리게스-회전-공식)

# 33. 삼중곱
### 선요약

> 삼중곱(Triple product): 
> - 벡터의 외적과 내적을 두 번 연속 사용하는 연산     
> - 벡터를 세 번 곱해야 하며, 연산 불가능한 수식이 나오면 안 된다
> - 때문에 두 경우만 유효한 삼중곱 연산이 된다
> - $\vec{u} \cdot (\vec{v} \times \vec{w})$
> - $\vec{u} \times (\vec{v} \times \vec{w})$

* * *

[본문](README-ORIGIN2.md#33-삼중곱)

# 33.1. 스칼라 삼중곱
### 선요약

> 스칼라 삼중곱(Scalar triple product):
> - $\vec{u} \cdot (\vec{v} \times \vec{w})$
> - 결과값이 스칼라가 나오며 다른 삼중곱 연산과 구분하기 위해 별도로 스칼라 삼중곱이라고 부른다
> - 좌우 판별과 백페이스 컬링에서 사용된다        
> $\hat{y} \cdot (\vec{f} \times \vec{v})$        
> $-\hat{z} \cdot (\vec{P_0P_1} \times \vec{P_0P_2})$
> 
> 스칼라 삼중곱 연산의 시각적 의미:
> - 외적으로 만든 벡터의 크기는 두 벡터가 이루는 평행사변형의 크기임과 동시에 외적으로 만들어진 법선 벡터의 크기다
> - 여기서 임의의 벡터 $\vec{u}$의 크기를 법선 벡터 $\vec{v} \times \vec{w}$에 수직으로 투영한 벡터의 높이는 $\cos$ 함수에 비례한다
> - 높이 $|\vec{u}|\cos \theta$에 평행사변형의 넓이 $|\vec{v} \times \vec{w}|$를 곱하면 육면체의 부피가 나온다        
> 이는 스칼라 삼중곱이 만들어내는 값의 절댓값과 동일하다      
> $|\vec{u}||\vec{v} \times \vec{w}|\cos\theta = |\vec{u} \cdot (\vec{v} \times \vec{w})|$        
> - 스칼라 삼중곱의 절댓값은 세 벡터 $\vec{u}, \vec{v}, \vec{w}$가 만드는 평행육면체(Parallelepiped)의 부피를 의미한다
> - 세 벡터에서 바닥에 해당하는 두 벡터를 다른 벡터로 변경해도 최종 육면체의 부피 값은 변하지 않으므로 삼중곱의 결과는 동일하다       
> $\vec{u} \cdot (\vec{v} \times \vec{w}) = \vec{v} \cdot (\vec{w} \times \vec{u}) = \vec{w} \cdot (\vec{u} \times \vec{v})$
> - 스칼라 삼중곱은 세 벡터의 선형 관계를 파악하는 데 사용된다        
> 외적으로 생성된 벡터의 크기는 두 벡터가 만드는 평행 사변형의 넓이와 동일하고, 이는 행렬식의 절댓값과 동일하다   
> 행렬식은 평면에서 평행사변형을 이루는 두 벡터가 서로 선형 독립의 관계를 가지는지 판단하는 수식이다      
> 이와 동일한 관점에서 스칼라 삼중곱은 3차원 공간의 세 벡터가 모두 선형 독립의 관계를 가지는지 판단하는 판별식으로 생각할 수 있다     
> 삼중곱의 값이 0이 나오는 경우는 평면을 이루는 두 벡터 $\vec{v}$와 $\vec{w}$가 평행이거나, 두 벡터 $\vec{v}$와 $\vec{w}$가 만드는 평면에 벡터 $\vec{u}$가 속하는 경우다      
> 전자의 경우 외적의 결과가 영벡터가 되므로 스칼라 삼중곱의 값은 0이 된다     
> 후자의 경우 외적의 결과로 만들어진 법선 벡터에 벡터 $\vec{u}$는 직교하므로 이의 내적은 0이 된다     
> 따라서 스칼라 삼중곱이 0이 아니면 세 벡터는 모두 선형 독립의 관계를 가짐을 알 수 있다

* * *

[본문](README-ORIGIN2.md#331-스칼라-삼중곱)

# 33.2. 벡터 삼중곱
### 선요약

> 벡터 삼중곱(Vector triple product):
> - $\vec{u} \times (\vec{v} \times \vec{w})$
> - 결과값이 벡터가 나오며 다른 삼중곱 연산과 구분하기 위해 벡터 삼중곱이라고 부른다
> - 삼중곱 전개(Triple product expansion), 라그랑주 공식(Lagrange's formula): $\vec{u} \times (\vec{v} \times \vec{w}) = (\vec{u} \cdot \vec{w}) \cdot - (\vec{u} \cdot \vec{v}) \cdot \vec{w}$
> - 벡터 삼중곱은 다소 복잡한 외적을 두 개의 내적 연산으로 변환한다
> - 삼중곱 전개의 우변은 결국 $a\vec{v} + b\vec{w}$ 형태의 선형 결합식이므로 벡터 삼중곱으로 만들어지는 벡터는 두 벡터 $\vec{v}$와 $\vec{w}$가 만드는 평면에 속한다
> - 벡터 삼중곱은 2차원 공간의 문제를 푸는 데도 유용하게 활용된다     
> 2차원 평면의 벡터 $\vec{u}$와 동일한 평면에 위치한 임의의 벡터 $\vec{v}$가 주어졌을 때, 동일 평면에서 벡터 $\vec{u}$와 직교하는 벡터는 $(\vec{u} \times \vec{v}) \times \vec{u}$의 벡터 삼중곱을 사용해 구할 수 있다

* * *

[본문](README-ORIGIN2.md#332-벡터-삼중곱)

# 34. 원근 투영 변환의 원리
### 선요약

> - 투시 원근법(Perpective projection): 시선을 한 점에 고정시키고, 고정된 점으로부터 화폭까지 곧게 뻗은 실을 활용해 그리는 기법
> - 원근 투영 변환(Perspective projection transformation): 공간의 모든 점이 한 점을 향해 모이는 형태의 변환       
> 3차원 공간에 투시 원근법의 원리를 적용하기 위해 필요하다        
> 원근 투영 변환은 사람의 눈이 바라보는 방식으로 가상 공간을 변환하는 것이다      
> - 화각(Field of view): 원근 투영 변환을 설계하기 위해서 눈에 보이는 범위를 가상 공간에서 눈에 대응하는 물체인 카메라에 설정한 것        
> 카메라에 화각을 설정하면 좌우와 위아래가 균등한 사각뿔 영역이 만들어진다        
> 원근 투영 변환은 $x, y, z$축이 모두 직교하는 정육면체 형태를 가진 뷰 공간을 카메라의 한 점으로 모이는 사각뿔 형태를 가진 공간으로 변환하는 작업이라고 할 수 있다        
> - 투영 평면(Projection plane): 모든 물체의 상이 맺히는 가상의 평면      
> 3차원 공간을 변환한 후에는 공간의 물체를 투영해 2차원의 모니터 평면에 담아야 한다       
> 투영 평면의 위치가 카메라로부터 멀어질수록 투영 평면은 더 커진다
> - 초점 거리(Focal length): 투영 평면의 위치를 지정하기 위해 설정한 카메라로부터 투영 평면까지의 거리
> - NDC(Normalized device coordinate): 투영 평면에 대응하는 2차원 평면의 좌표시스템을 가지는 정사각형 영역        
> 윈근 투영을 구현하기 위해서는 투영 평면의 위치를 지정해야 하고, 일반적으로 투영 평면의 위치는 계산의 편의를 위해 위 아래의 크기가 각각 1이 되는 지점으로 결정한다       
> 좌우와 상하으이 화각이 동일하므로 투영 평면은 좌우와 상하가 각각 $|-1, 1|$의 범위를 가지는 정사각형의 모습을 띠며 이 평면에 물체의 상이 맺힌다      
> NDC는 가운데 중점을 원점으로 설정한다       
> 투영 평면에 대응하는 NDC가 언제나 일정한 값을 가져야 한다면, 카메라에 설정된 화각이 변할 때, 초점 거리는 달라질 수밖에 없다     
> 화각이 커질수록 초점 거리는 가까워지고 화각이 작아질수록 초점 거리는 멀어진다       
> 화각과 초점 거리의 관계는 직각삼각형의 $\tan$ 함수로 설정된다       
> $\tan (\frac{\theta}{2}) = \frac{1}{d}$     
> 따라서 주어진 화각 $\theta$에 따른 초점 거리 $d$는 다음 식으로 계산할 수 있다       
> $d = \frac{1}{\tan (\frac{\theta}{2})}$     
> $\tan$ 함수를 사용해 초점 거리를 구하고, 뷰 공간의 점을 투영 평면 위의 점으로 대응시키는 원근 투영 변환을 설계할 때 이 역시 행렬로 설계할 수 있다면 행렬 곱의 장점을 활용해 로컬 공간의 점을 투영 평면의 점으로 한 번에 변환해주는 파이프라인을 만들 수 있다
> - 유클리드 공간(Euclidean space): $x, y, z$축이 서로 직교하고 크기가 동일한 정육면체 형태의 3차원 공간      
> 원근 투영 행렬을 설계하기 위해 카메라가 바라보는 공간은 유클리드 공간의 성질을 가져야 한다      
> 로컬 공간, 월드 공간, 뷰 공간은 모두 유클리드 공간의 형태다
> - 사영 공간(Projective space): 사각뿔 형태의 공간       
> 정육면체 형태의 유클리드 공간은 원근 투영 변환에 의해 화각으로 만들어진 사각뿔 형태로 바뀌게 된다       
> 사영 공간의 $x$축과 $y$축은 여전히 직교하기 때문에 사영 공간의 $x$축과 $y$축은 유클리드 공간과 동일한 성질을 가진다     
> 하지만 사영 공간의 $z$축은 독립적으로 행동하지 않고 $x$축과 $y$축에 모두 영향을 준다        
> 이는 초점 거리에 따라 $x$축과 $y$축이 만들어내는 투영 평면의 면적이 달라지는 이유이기도 하다
> - 종횡비(Aspect ratio): 화면의 가로 세로 비
> - 클립 좌표(Clip coordinate): 원근 투영 행렬 $P$로 변환되는 좌표계      
> 원근 투영 행렬 $P$는 모든 점에 대해서 보편적으로 사용할 수 있게 설계된다

* * *

[본문](README-ORIGIN2.md#34-원근-투영-변환의-원리)

# 35. 동차 좌표계
### 선요약

> 동차 좌표계(Homogenous coordinate system):
> - 한 차원 높인 벡터를 사용하는 좌표계
> - NDC는 2차원 평면의 좌표지만, 모든 점에 사용 가능한 원근 투영 행렬을 사용하도록 계산 과정을 두 단계로 구분하고 사용하는 벡터의 값도 한 차원 높였다
> - 동차 좌표계의 동차는 모든 항의 차수가 같음을 의미하는 수학 용어다
> 
> 사영 공간과 동차 좌표계의 연관:
> - 사영 공간의 점과 투영된 점의 좌표는 카메라로부터 멀어질수록 원점에 가까워지고, 카메라에 가까워질수록 원점에 멀어지는 반비례 관계를 가진다      
> - 3차원 사영 공간의 점을 $(x', y', z')$로 표기하고 해당 점이 투영된 NDC 좌표를 $(x, y)$로 표기한다면 NDC 좌푯값은 사영 공간의 마지막 차원 값 $z'$에 반비례로 영향을 받으므로 다음과 같은 관계가 성립한다        
> $x = \frac{x'}{z'} \qquad y = \frac{y'}{z'}$
> - NDC 공간에서 방정식 $y = ax + b$가 만들어낸 직선이 사영 공간의 점들의 투영이라고 가정하면, 이를 사영 공간의 좌표로 표현할 때 직선의 방정식은 다음과 같다      
> $\frac{y'}{z'} = a\frac{x'}{z'} + b$        
> 이 식의 양변에 $z'$를 곱하면 상수가 사라지고 세 미지수의 차수가 모두 1차식으로 동일한 수식이 구성된다       
> $y' = ax' + bz'$        
> - 미지수에 대한 차수가 모두 동일한 방정식을 동차 방정식이라고 부른다
> - 사영 공간이 사용하는 좌표계를 동차좌표계라고도 부른다
> - 원근 투영 행렬 $P$를 설계하기 위해 계산 과정을 두 단계로 나눠 진행하고, 첫 번째 단계로 구한 좌표를 클립 좌표라고 부르며 이는 투영 되기 전의 사영 공간의 좌표를 의미한다       
> 따라서 원근 투영 변환에서 등장한 사영 공간, 클립 공간, 동차 공간은 모두 동일한 공간을 가리키고, 클립 좌표, 동차 좌표 역시 동일한 좌표계를 가리킨다
> 
> 소실점(Vanishing point):
> - NDC의 원점
> - 사영 공간의 점이 카메라로부터 멀어질수록 투영된 NDC 좌푯값은 원점 $(0, 0)$에 가까워진다

* * *

[본문](README-ORIGIN2.md#35-동차-좌표계)

# 36. 깊이 값
### 선요약

> 원근 투영 행렬을 활용해 3차원의 물체를 원근감 있게 표현할 수 있지만, 물체에 텍스쳐를 입힌다면 추가로 고려할 사항이 생긴다       
> 이용자에게 보이는 화면은 결국 2차원 평면이므로 나중에 그린 물체가 앞에 보일 수밖에 없다     
> 가장 가까운 곳에 배치하더라도, 가장 먼저 그리면 카메라에서 가장 먼 곳에 배치돼 있는 것처럼 인식된다     
> 
> 이 문제를 해결하는 방법은, 물체가 카메라로부터 얼마나 떨어져 있는지에 대한 정보를 기록해 앞에 있는 물체를 나중에 그리도록 설정한다      
> 이를 위해서는 카메라로부터 물체가 얼마나 떨어졌는지 파악할 수 있는 데이터가 필요한데 이를 깊이(Depth) 값이라고 한다     
> 2차원 평면이었던 NDC 영역에 깊이 값을 추가하면 3차원으로 NDC 영역이 확장된다        
> 깊이 값의 범위는 동일하게 $|-1, 1|$로 설정한다
> 
> - 근평면(Near plane), 원평면(Far plane): 카메라에 부여한 시야각은 깊이와 무관하기 때문에 카메라에 추가로 부여한 속성
> - 절두체(Frustum): 카메라 시야를 구성하는 사영 공간을 근평면과 원평면으로 잘자내어 사각뿔에서 뾰족한 부분이 잘린 형태       
> NDC의 깊이 값은 멀어질수록 증가하기 때문에 절두체로 생성되는 3차원 NDC 공간은 왼손 좌표계를 형성한다

* * *

[본문](README-ORIGIN2.md#36-깊이-값)

# 37. 원근 보정 매핑
### 선요약

> 기존 방식으로 텍스처 매핑을 진행할 경우 평행하게 그려져야 할 텍스처가 처지거나 올라가는 문제가 발생한다     
> 이 문제는 투영 전, 사영 공간에서의 무게중심좌표와 투영 평면에 투영한 NDC 공간에서의 무게중심좌표가 다르기 때문에 발생한다       
> 사영 공간의 무게중심좌표와 NDC에서의 무게중심좌표가 서로 차이 나는 이유는 NDC 공간으로의 변환 과정에서 사영 공간의 마지막 요소 $w$의 값 $-v_z$를 나눴기 때문이다        
> 이는 사영 공간과 NDC 공간 사이에 형성된 반비례 관계로부터 기인한다
> 
> 투영 보정 보간(Perspective correction interpolation):
> - 투영 전의 무게중심좌표 값을 계산해 텍스처를 매핑하는 것     
> - 기존의 텍스처 매핑은 NDC에서의 변경된 무게중심좌표를 사용하는 것이었는데, 이를 바로 잡으려면 투영되기 전 사영 공간에서의 무게중심좌표를 사용해야 한다       
> - 따라서 투영 과정을 거꾸로 추적해 NDC에서 구한 무게중심좌표로부터 사영 공간의 무게중심좌표를 계산해야 한다

* * *

[본문](README-ORIGIN2.md#37-원근-보정-매핑)

# 38. 깊이 버퍼
### 선요약

> - 깊이 버퍼(Depth buffer): 화면의 픽셀마다 현재의 깊이 값을 보관해주는 별도의 저장 공간     
> 다수의 게임 오브젝트를 그리는 경우 카메라로부터 멀리 떨어진 게임 오브젝트를 먼저 그리고 가까운 오브젝트를 다음에 그리도록 순서를 조절해야 원근감이 올바르게 표현된다        
> 같은 거리에 있는 두 게임 오브젝트가 서로 겹쳐 있다면, 물체 단위가 아닌 삼각형의 픽셀 단위로 깊이를 비교하고 가까운 곳에 있는 픽셀만 그린다
> - 깊이 테스팅(Depth testing): 최종 픽셀을 찍는 과정에서 현재 깊이 값을 깊이 버퍼에 저장된 값과 비교해 현재 깊이 값이 작은 경우에만 픽셀을 찍도록 로직을 구성하여 그리기 순서 문제를 해결하고 물체에 가려져 그리지 않아도 되는 픽셀을 파악해 그리기를 건너뛰는 작업

* * *

[본문](README-ORIGIN2.md#38-깊이-버퍼)

# 39. 절두체 컬링
### 선요약

> 절두체 컬링(Frustum culling):
> - 절두체의 영역 밖에 있는 게임 오브젝트를 파악하고 걸러내는 기능
> - 다수의 게임 오브젝트가 월드 공간에 넓게 퍼져 있는 경우, 카메라 시야 밖에 위치한 게임 오브젝트까지 모두 그리는 것은 비효율적인 작업이기 때문에 게임에서 그래픽을 구현할 때는 효과적인 렌더링을 위해 절두체 영역에 속한 게임 오브젝트만 그린다
> - 절두체 컬링은 절두체를 구성하는 6개의 평면에 대해 각각 평면의 방정식을 세우고, 평면의 방정식을 활용해 대상 게임 오브젝트의 위치가 평면의 바깥에 있는지 확인하는 절차로 진행된다
> - 게임 오브젝트가 6개 평면 중 하나라도 바깥쪽에 위치해 있다면 그리기에서 제외된다

* * *

[본문](README-ORIGIN3.md#39-절두체-컬링)

# 39.1. 평면의 방정식
### 선요약

> 평면의 방정식:
> - 세 점이 주어지면 세 점으로부터 두 벡터를 생성해 평면 상의 모든 점을 생성할 수 있다
> - 하나의 평면을 정의하려면 최소 3개의 점이 필요한데, 3차원 공간의 평면은 앞면과 뒷면이 존재하기 때문에, 이를 구분할 수 있는 정보도 있어야 한다
> - 그래서 평면을 정의할 때는 세 점의 정보를 사용하기보다 평면이 바라보는 방향을 알려주는 법선 벡터와 평면 상에 위치한 한 점을 제공하는 방법을 사용한다       
> 이때 법선 벡터는 크기를 1로 정규화시키는 것이 일반적이다
> 
> 평면이 지니는 성질:
> - 평면이 향하는 방향을 나타내는 법선 벡터 $\hat{n}$와 평면에 위치한 임의의 점 $P_0(x_0, y_0, z_0)$의 두 요소는 3차원 공간에서 평면을 정의할 때 최소로 주어지는 값이다
> - 평면이 향하는 방향을 나타내는 법선 벡터 $\hat{n}$의 값이 $(a, b, c)$로 주어지면, 크기가 1이므로 $a^2 + b^2 + c^2 = 1$의 조건이 성립한다
> - 평면에 위치한 임의의 점 $P_0(x_0, y_0, z_0)$의 값이 주어졌다고 가정하면, 평면의 방향을 나타내는 법선 벡터와 평면 위의 두 점을 지나는 벡터는 서로 직교하기 때문에 두 벡터의 내적은 0이 된다      
> 법선 벡터 $\hat{n}$와 점 $P_0$에서 점 $P$로 향하는 벡터를 내적하면 다음 수식이 성립한다       
> $\hat{n} \cdot (P - P_0) = (a, b, c) \cdot (x - x_0, y - y_0, z - z_0) = 0$     
> $\qquad = ax + by + cz - (ax_0 + by_0 + cz_0) = 0$
> - 법선 벡터 $(a, b, c)$와 평면의 점 $(x_0, y_0, z_0)$는 사전에 주어진 값이므로 $-(ax_0 + by_0 + cz_0)$는 미리 계산할 수 있는 상수 값이다        
> 이를 간단히 $d$로 치환하면 다음과 같이 간략하게 표시할 수 있는데, 이를 평면의 방정식(The equation of plane)이라고 한다      
> $ax + by + cz + d = 0$
> 
> 상수 $d$의 의미:
> - $d = -(ax_0 + by_0 + cz_0)$
> - 상수 $d$는 법선 벡터 $(a, b, c)$와 벡터 $(x_0, y_0, z_0)$와의 내적에 음의 부호를 설정한 결과로 볼 수 있다     
> $d = -\hat{n} \cdot (x_0, y_0, z_0)$
> - $(x_0, y_0, z_0)$는 점 $P_0$의 좌표지만, 이는 원점 $O$에서 점 $P_0$로 향하는 벡터의 값으로도 사용할 수 있다       
> 이를 $\vec{p}$로 표시하고 위 공식을 정리하면 다음과 같다        
> $d = -\hat{n} \cdot \vec{OP_0} = -\hat{n} \cdot \vec{p}$
> 
> $\hat{n} \cdot \vec{p}$가 나타내는 의미:
> - $\hat{n} \cdot \vec{p} = |\hat{n}||\vec{p}|\cos\theta$
> - 현재 법선 벡터의 크기는 항상 1이므로 위 공식은 다음과 같이 간단히 정리된다        
> $\hat{n} \cdot \vec{p} = |\vec{p}|\cos\theta$
> - $\hat{n} \cdot \vec{p}$는 $\vec{p}$ 벡터를 법선 벡터 $\hat{n}$에 투영한 벡터의 크기를 의미한다
> - 평면과 법선 벡터는 서로 직교하기 때문에 $\hat{n} \cdot \vec{p}$의 값은 원점에서 평면까지의 최단 거리를 의미한다
> - 하지만 $d$의 값은 $\hat{n} \cdot \vec{p}$가 아닌 $-\hat{n} \cdot \vec{p}$이므로 원점으로부터 평면의 최단 거리에 음의 부호를 설정한다는 특징을 가진다
> - 거리라는 측정값은 음수가 나올 수 없기 때문에 $d$값은 원점으로부터의 최단 거리와 방향이라는 두 가지 정보를 담고 있다
> - 내적의 성질에 따라 두 벡터가 같은 방향을 바라보면 +값이 나오고, 반대 방향을 바라보면 -값이 나온다     
> $d$의 값이 음수라면 두 벡터 $\hat{n}$과 $\vec{p}$는 같은 방향을 바라보고 있다는 의미다
> 
> 평면이 원점을 향하는 반대의 경우:
> - 평면이 원점을 향하다면 두 벡터는 서로 마주보는 상황이므로 내적의 값은 음수가 되고, $d$의 값은 반대 부호인 양수가 나온다       
> 
> 평면의 방정식 $d$의 값에 따라 평면이 가지는 두 가지 성질:
> - $d$의 부호: $d$의 값이 양수면 평면이 바라보는 방향은 원점을 향하고, 음수면 원점에서 멀어지는 방향을 가진다        
> $d$의 값이 양수면 원점은 평면의 바깥에 위치하고, 음수면 원점은 평면의 안쪽에 위치한 것이다
> - $d$의 절댓값: 평면에서 원점까지의 최단 거리를 의미한다
> 
> 평면이 원점을 품는 경우:
> - 평면이 원점을 품는다면 원점으로부터 거리 $d$의 값은 부호에 관계없이 언제나 0이 나오기 때문에 평면의 법선 벡터 값을 사용해 바로 $ax + by + cz = 0$이라는 평면의 방정식을 얻을 수 있다
> 
> 주어진 점이 평면의 안쪽에 있는지 바깥쪽에 있는지 판별:
> - 임의의 점 $P$가 있을 때, 원점에서 점 $P$로 향하는 벡터 $\vec{OP}$를 법선 벡터에 내적한 값을 $p$로 표기하면, $p$의 부호를 통해 법선 벡터에 투영한 벡터 $\vec{OP'}$의 방향 정보를 파악할 수 있다
> - $p$가 양수면 벡터 $\vec{OP'}$는 법선 벡터와 같은 방향을 정하고, 음수면 법선 벡터와 반대 방향을 향한다
> 
> $p$와 평면의 방정식의 상수 $d$를 서로 더한 값:
> - 원점이 평면 안쪽에 있으면 $d$값은 음수다      
> 음수 $d$에 양수인 $p$를 더한 값이 여전히 음수라면, 점 $P$는 평면의 안쪽에 있다고 판단할 수 있다     
> - 반대로 $p$와 $d$를 더한 값이 양수면 점 $P$는 평면의 바깥쪽에 있다고 판단할 수 있다
> - 법선 벡터가 반대인 경우에도 이 규칙은 동일하게 적용되어 $d$값은 양수가 되고 $p$는 음수가 된다     
> - $d$와 $p$를 더한 결과가 여전히 양수라면 이는 점 $P$가 평면의 바깥쪽에 있음을 의미한다     
> - 따라서 법선 벡터 $(a, b, c)$와 $d$를 사용해 정의한 평면에 주어진 점 $P(x_1, y_1, z_1)$가 평면의 바깥쪽에 있는지를 판단하는 수식은 다음과 같다     
> $(a, b, c) \cdot (x_1, y_1, z_1) + d > 0$
> - $(a, b, c) \cdot (x_1, y_1, z_1) + d$의 값에 절댓값을 취하면 이는 평면에서 해당 점까지의 최단 거리를 의미한다     
> $distance = |(a, b, c) \cdot (x_1, y_1, z_1) + d|$

* * *

[본문](README-ORIGIN3.md#391-평면의-방정식)

# 39.2. 평면의 방정식의 정규화
### 선요약

> 평면의 방정식의 정규화:
> - 크기가 1이 아닌 주어진 법선 벡터를 구성하는 세 계수 $(a, b, c)$를 정규화해 $(a', b', c')$로 만드는 수식은 법선 벡터의 크기 $|\vec{n}|$으로 나누면 구할 수 있다        
> $(a', b', c') = \frac{\vec{n}}{|\vec{n}|} = \frac{\vec{n}}{\sqrt{a^2 + b^2 + c^2}} = \frac{(a, b, c)}{\sqrt{a^2 + b^2 + c^2}}$
> - 마지막 계수 $d$는 평면 위의 한 점으로 향하는 벡터 $\vec{p}$와 평면의 법선 벡터 $\hat{n}$을 내적한 값의 반대수를 의미한다      
> $d = -\vec{n} \cdot \vec{p} = -|\vec{n}||\vec{p}| \cos \theta$
> - 법선 벡터의 크기가 1일 때 평면의 방정식 값 $d'$는 다음과 같다     
> $d' = -|\vec{p}| \cos\theta$    
> - $d$와 $d'$의 관계는 다음과 같이 정리된다      
> $d' = \frac{d}{|\vec{n}|}$
> - $d$의 경우도 동일하게 법선 벡터의 크기 $|\vec{n}|$으로 나누면 원하는 값 $d'$를 얻을 수 있기 때문에 정규화 식은 다음과 같이 정리된다       
> $\frac{ax + by + cz + d}{\sqrt{a^2 + b^2 + c^2}} = 0$       
> - 임의의 네 수로부터 평면의 방정식을 구성한다면 위 식을 사용해 평면의 방정식을 정규화시켜주는 것이 이후에 평면의 방정식을 활용할 때 더 편리하다     
> 정규화된 평면의 방정식의 $d$값은 원점으로부터의 최단 거리 정보를 담고 있기 때문이다
> 
> 2차원 직선의 방정식에서의 최단 거리:
> - 평면의 방정식은 내적에 기반을 두기 때문에 2차원 공간에서도 동일하게 활용할 수 있다
> - 3차원 공간의 평면이 앞면과 뒷변을 가진 것처럼, 2차원 공간의 직선도 앞쪽과 뒤쪽을 가진다
> - 2차원 공간에서의 직선의 방정식이 $ax + by + c = 0$이라고 할 때, 법선 벡터 $(a, b)$의 크기가 1이면 상수 $c$의 절댓값은 원점에서 직선까지의 최댄 거리를 의미한다
> - 만약 법선 벡터 $(a, b)$의 크기가 1이 아니라면 원점에서 직선까지의 최단 거리는 다음과 같다     
> $\frac{|c|}{\sqrt{a^2 + b^2}}$
> - 임의의 한 점 $(x_1, y_1)$에서 임의의 직선 $ax + by + c = 0$까지의 최단 거리는 평면의 방정식을 정규화한 값과 내적을 활용해 다음과 같이 구할 수 있다        
> $\frac{|ax_1 + by_1 + c|}{\sqrt{a^2 + b^2}}$

* * *

[본문](README-ORIGIN3.md#392-평면의-방정식의-정규화)

# 39.3. 평면의 방정식을 활용한 절두체 표현
### 선요약

> 절두체 컬링의 구현:
> - 절두체 상단 평면을 무한하게 확장하면 상단 평면은 원점을 품게 된다     
> 이는 근평면과 원평면을 제외한 나머지 평면에 대해서도 동일하다       
> 근평면과 원평면을 제외한 네 평면을 구성하는 평면의 방정식의 $d$값은 0이므로 크기가 1인 법선 벡터만 구하면 근평면과 원평면을 제외한 평면읩 방정식을 얻을 수 있다
> - 뷰 공간의 절두체를 측면에서 바라본 평면의 좌표계에서 오른쪽 방향은 뷰 공간의 $-z$축에 대응되고 위쪽 방향은 $y$축에 대응된다
> - 평면에서 오른쪽을 향하는 $(0, 0, -1)$의 벡터를 반시계 방향으로 $\frac{\theta}{2}$만큼 회전한 결과 $(0, \sin \frac{\theta}{2}, -\cos \frac{\theta}{2})$가 된다     
> 평면의 법선 벡터는 여기서 $90^\circ$만큼 더 회전한 값이므로 $y$값과 $z$값을 교차시키고 $y$값에 반대 부호를 취하면 얻을 수 있다      
> $\hat{n} = (0, \cos\frac{\theta}{2}, \sin\frac{\theta}{2})$
> - $d$값은 0이므로 절두체 상단을 구성하는 평면의 방정식은 다음과 같다        
> $\cos\frac{\theta}{2}y + \sin\frac{\theta}{2}z = 0$
> - 유사한 방식으로 나머지 세 평면의 방정식을 구하면 다음과 같다
>     - 절두체 하단 평면의 방정식: $-\cos\frac{\theta}{2}y + \sin\frac{\theta}{2}z = 0$
>     - 절두체 좌측 평면의 방정식: $-\cos\frac{\theta}{2}x + \sin\frac{\theta}{2}z = 0$
>     - 절두체 우측 평면의 방정식: $\cos\frac{\theta}{2}x + \sin\frac{\theta}{2}z = 0$
> 
> 근평면과 원평면의 방정식:
> - 근평면은 원점을 향하고 있으며 원점으로부터의 거리는 $n$이므로 평면의 방정식의 $d$ 값은 $n$이 된다     
> - 근평면의 법선 벡터의 값은 $(0, 0, 1)$이다
> - 근평면의 방정식:      
> $(0, 0, 1) \cdot (x, y, z) - (0, 0, 1) \cdot (0, 0, -n) = 0$        
> $\qquad \therefore z + n = 0$
> - 원평면의 법선 벡터는 근평면에 반대 방향인 원점에서 멀어지는 $(0, 0, -1)$이며, 원점으로부터의 거리는 $f$가 된다
> - 원평면의 방정식:      
> $(0, 0, -1) \cdot (x, y, z) - (0, 0, 1) \cdot (0, 0, f) = 0$        
> $\qquad \therefore -z - f = 0$
> 
> 평면의 방정식을 다룰 때 주의할 점:
> - 평면의 방정식은 방향 정보가 수록되어 있기 때문에 함부로 수식을 옮기면 안 된다
> - 원평면의 방정식의 변을 옮기면 다음과 같은 방정식이 나온다     
> $0 = z + f$
> - 이 방정식으로 만들어지는 평면이 놓인 위치는 원평면과 동일하지만, 평면의 방향은 원평면의 반대 방향인 원점을 향한다     
> - 따라서 $z + f = 0$과 $-z - f = 0$은 서로 다른 평면이라는 점에 주의해야 한다

* * *

[본문](README-ORIGIN3.md#393-평면의-방정식을-활용한-절두체-표현)

# 39.4. 원근 투영 행렬로부터 평면의 방정식 만들기
### 선요약

> 원근 투영 행렬을 활용해 절두체 컬링 구현:
> - 뷰 공간의 점이 NDC 좌표까지 변환됐을 때 NDC 좌표를 구성하는 $x, y, z$ 세 축의 값이 $|-1, 1|$ 범위에 있다면 해당 점은 절두체 영역 안쪽에 있음을 의미한다
> - NDC 좌푯값을 $(n_x, n_y, n_z)$으로 가정하면 각 성분은 $-1$과 $1$ 사이에 있다
> - 이 조건에서 변환 과정을 거꾸로 추적하면 NDC 좌표는 클립 좌표의 마지막 차원 $w$로 나눈 결괏값이므로, 클립 좌표 $(x, y, z, w)$로 바꿔 쓰면 각 성분은 $-w$와 $w$ 사이에 있다
> - 원근 투영행렬을 $P_{row1}$부터 $P_{row4}$까지 4개의 행벡터로 표현하면 뷰 공간에서 클립 공간으로 변환하는 연산은 행벡터와 점의 내적으로 바꿔 쓸 수 있다
> - 그러면 클립 공간의 각 요소는 행벡터와 점의 내적으로 표현된다
> - $-w, w$와 각 성분의 관계를 나타내는 부등식의 $x, y, z, w$를 내적으로 치환하고 6개로 분리하여 6개의 부등식이 모두 참이면, 뷰 공간의 점 $\vec{v}$는 절두체 영역 내부에 있음을 의미하고, 하나라도 만족하지 못하면 절두체 영역의 외부에 있음을 의미한다
> - 부등식 괄호 안의 원근 투영 행렬 행벡터를 계산한 4차원 벡터를 $(a, b, c, d)$로 표시했을 때 이를 뷰 공간의 점 $(x, y, z, 1)$과 내적한 결과는 다음과 같다        
> $ax + by + cz + d \geq 0$
> - 이는 평면의 방정식과 형태가 동일하지만 이 식에서 만들어지는 법선 벡터 $(a, b, c)$의 크기는 1이 아니므로 이를 정규화된 평면의 방정식으로 변환해야 한다     
> $\frac{ax + by + cz + d}{\sqrt{a^2 + b^2 + c^2}} = 0$
> - 이와 같은 과정을 거쳐 구한 평면의 방향은 모두 절두체 내부를 향한다
> - 절두체 컬링을 구현할 때는 해당 점이 외부에 있는지를 파악하는 수식이 필요하다      
> 평면이 절두체 외부를 향하도록 위 식의 부호를 반전시킨다     
> $-(\frac{ax + by + cz + d}{\sqrt{a^2 + b^2 + c^2}}) = 0$
> - 평면 밖에 위치한 상황만 검출해야 하므로 등호 대신 부등호로 교체하면 다음의 수식이 완성된다        
> $-(\frac{ax + by + cz + d}{\sqrt{a^2 + b^2 + c^2}}) > 0$

* * *

[본문](README-ORIGIN3.md#394-원근-투영-행렬로부터-평면의-방정식-만들기)

# 40. 바운딩 볼륨
### 선요약

> 절두체 컬링만을 적용하면 카메라를 움직일 때 화면 가장자리에 있는 게임 오브젝트가 갑자기 사라지거나 튀어나오는 현상이 생긴다     
> 이는 게임 오브젝트의 메시가 차지하는 공간 영역이 있음에도 불구하고 게임 오브젝트의 기준 위치만 가지고 절두체 컬링을 수행했기 때문이다       
> 예를 들어 게임 오브젝트의 기준 위치는 절두체 바깥에 있고 메시는 절두체 안 쪽에 있다면 기존 절두체 컬링 로직에서는 게임 오브젝트의 위치가 절두체 바깥에 있다고 판단해 그리기를 건너뛴다      
> 하지만 이 게임 오브젝트는 절두체 영역에 걸쳐 있기 때문에 그려줘야 한다      
> 이 문제를 해결하기 위해서는 게임 오브젝트의 위치를 대상으로 하지 않고, 메시가 차지하는 영역을 감안해 절두체 컬링을 진행해야 한다        
> 
> - 원시 도형(Primitive shape): 구(Sphere)나 박스(Box) 같은 기본 도형
> - 바운딩 볼륨(Bounding Volume): 원시 도형으로 설정한 공간 데이터
> 
> 게임 엔진은 메시가 차지하는 영역을 효과적으로 관리하기 위해 원시 도형을 사용한다

* * *

[본문](README-ORIGIN3.md#40-바운딩-볼륨)

# 40.1. 구 바운딩 볼륨의 판정
### 선요약

> 바운딩 볼륨에서 손쉽게 사용되는 원시 도형은 구(Sphere)다        
> 구는 두 영역이 서로 겹치는지, 떨어져있는지를 가장 쉽고 빠르게 파악할 수 있는 도형이기 때문이다      
> 어떤 점이 구의 외부에 있는지 여부를 파악하는 방법은 구의 중점에서부터 점까지의 거리와 구의 반지름의 크기를 비교하는 것이다
> 
> $$d > r_1$$
> 
> 또한 두 구의 영역이 서로 떨어져 있는지 여부는 두 구의 중점 간의 거리와 두 구의 반지름을 더한 값을 비교하는 것만으로 쉽게 파악할 수 있다
> 
> $$d > (r_1 + r_2)$$

* * *

[본문](README-ORIGIN3.md#401-구-바운딩-볼륨의-판정)

# 40.2. AABB와의 판정
### 선요약

> - AABB(Axis aligned bounding box): 기저 축에 정렬되어 있는 바운딩 볼륨      
> 박스 영역을 구성하는 각 축의 최댓값과 최솟값을 설정하고, 메시를 구성하는 점을 순회하면서 각 차원의 값을 비교한다        
> 현재 박스 영역에 저장된 최댓값보다 크거나 최솟값보다 작다면 박스 영역의 최댓값과 최솟값을 갱신해준다        
> 모든 점에 대해 이 과정을 거치면 기저 축에 평행한 박스 영역이 형성된다
> 
> 로컬 공간에서 생성한 AABB 영역과 평면과의 판정:
> - 평면의 법선 벡터의 모든 요소가 양수인 상황에서 AABB 영역이 평면의 바깥에 위치해 있다고 가정하면, 이 상황에서 평면과 가장 가까운 AABB 영역의 점은 AABB의 최솟값이다        
> 그렇다면 AABB 영역의 최솟값과 평면과의 차이를 측정하는 값은 양수가 나온다
> - 반대로 평면의 법선 벡터의 모든 요소가 음수인 상황에서는, 평면과 가장 가까운 AABB 영역의 점은 최댓값이고, 최댓값과 평면과의 차이를 측정하는 값 또한 양수가 나온다
> - AABB 영역과 법선 벡터의 $x, y, z$축은 서로 직교하고 있으므로 각 축의 데이터는 독립적으로 동작한다     
> 따라서 각 법선 벡터의 요소마다 양수인 경우에는 해당 요소의 최솟값을, 음수인 경우에는 해당 요소의 최댓값을 사용하는 것으로 평면에서 가장 가까운 AABB의 점을 구할 수 있다     
> 예를 들어 $x$축과 $z$축의 법선 벡터가 음수고 $y$축만 양수라면 평면과 가장 가까운 AABB의 좌표는 $(Max, Min, Max)$가 된다     
> - 평면에서 가장 가까운 AABB의 좌표와 평면과의 차이를 측정했을 때 그 값이 양수가 나온다면, AABB 영역은 완전히 평면의 바깥에 위치해 있다고 판정할 수 있다
> 
> AABB 영역이 절두체의 평면과 교차되는 경우의 판별:
> - 평면에서 가장 가까운 AABB의 좌표와 평면과의 차이를 측정한 값이 음수가 나오는 경우, 평면에서 가장 가까운 AABB의 좌표와 정반대에 위치한 점으로 다시 평면과의 테스트를 진행해 평면과의 교차 여부를 확인한다      
> - 정반대에 위치한 점과 절두체 평면과의 차이를 측정한 값이 양수가 나오면 절두체 영역과 AABB 영역은 서로 교차한다

* * *

[본문](README-ORIGIN3.md#402-aabb와의-판정)

# 41. 삼각형 클리핑
### 선요약

> 삼각형 클리핑(Triangle clipping):
> - 현재까지의 내용으론 카메라 뒤편에 있는 점이 거꾸로 뒤집혀 투영되는 결과가 발생한다
> - 평면이 올바르게 보이려면 카메라 뒤쪽에 있는 점을 파악해 점이 거꾸로 뒤집혀 투영되지 않도록 에방해야 한다
> - 원근 투영 행렬을 곱해 생성된 클립 좌표계의 $w$값은 뷰 공간에서의 깊이 값을 의미한다
> - 카메라 정면에 위치한 점의 $w$값은 0보다 크고, 카메라 뒤에 있는 점의 $w$값은 0보다 작으며, 카메라 초점에 위치한 점의 $w$값은 0이 된다
> - 음의 $w$ 영역에 걸쳐 있는 삼각형을 파악하고 이들이 엉뚱하게 투영되지 않도록 삼각형 영역을 잘라내는 작업을 삼각형 클리핑(Triangle clipping)이라고 한다
> - 삼각형 클리핑 작업은 월드 공간의 좌표를 사용하지 않고 투영 행렬을 적용한 후의 좌표를 사용한다     
> 사영 공간에서 삼각형 클리핑 작업을 진행하는 것이 더 간편하기 때문이다       
> 이는 사영 공간의 좌표를 클립 좌표로 부르는 이유다
> - 뒤집혀 투영되는 문제를 해결하기 위해서는 음의 영역을 잘라내는 작업이 필요하며, 음의 영역에 위치한 점 $P_1$을 $w = 0$ 평면에 투영한 두 점 $P_{c1}$과 $P_{c2}$의 좌표를 구해야 한다
> - 점 $P_1$과 점 $P_2, P_3$를 이은 두 선분이 있을 때 점 $P_{c1}$과 $P_{c2}$의 좌표는 각 선분 위의 점이며 점 $P_{c1}, P_{c2}$의 좌표는 아핀 결합의 직선의 방정식을 사용해 구할 수 있다
> - 삼각형을 잘라낸 후에 $w = 0$ 평면에 투영된 두 점과 투영되지 않은 두 점의 영역은 삼각형이 아닌 사각형을 이루기 때문에 점을 투영한 후에는 사각형을 두 개의 삼각형으로 분할해야 한다     
> 분할할 때에는 면의 방향이 동일하도록 정점의 순서도 자르기 전의 삼각형의 순서와 동일해야 한다

* * *

[본문](README-ORIGIN3.md#41-삼각형-클리핑)

# 42. 복소수
### 선요약

복소수(Complex number): 
- 체의 구조를 가지는 집합이다
- 실수(Real number)와 허수(Imaginary number)의 독립된 2개 요소로 구성된 수 집합이다
- 집합 기호는 $C$로 표현한다

* * *

[본문](README-ORIGIN3.md#42-벡터-공간의-연산)

# 42.1. 허수
### 선요약

> - 허수(Imaginary number): 제곱해서 음수가 되는 상상의 수
> - 허수 단위(Imaginart unit): 제곱했을 때 -1이 나오는 수 $i$     
> $i^2 = -1$
> - 실수부(Real part): 복소수 내에서 완전히 분리된 실수 집합
> - 허수부(Imaginary part): 복소수 내에서 완전히 분리된 허수 집합     
> 허수부는 항상 $i$를 사용해 표기한다
> - 복소수 표기: $a + bi$, $(a, b)$

* * *

[본문](README-ORIGIN3.md#421-허수)

# 42.2. 복소수의 구조
### 선요약

> 복소수의 덧셈:
> - 실수부와 허수부를 구분해 각각 더해주는 방식       
> $(a + bi) + (c + di) = (a + c) + (b + d)i$      
> $(a, b) + (c, d) = (a + c, b + d)$
> - 순서쌍을 구성하는 $a, b, c, d$는 모두 실수이므로 벡터 덧셈 연산의 성질을 참고해 복소수의 덧셈 연산이 만족하는 성질을 파악할 수 있다
> - 덧셈에 대해 닫혀 있음
> - 덧셈에 대한 교환법칙이 성립함
> - 덧셈에 대한 결합법칙이 성립함
> - 덧셈에 대한 항등원이 존재함
> - 덧셈에 대한 역원이 존재함
> 
> 복소수의 곱셈:
> - 모든 요소를 교차해 곱하는 방식        
> $(a + bi) \cdot (c + di) = ac - bd + (ad + bc)i$        
> $(a, b) \cdot (c, d) = (ac - bd, ad + bc)$
> - 실수가 갖는 체의 성질에 근거해 복소수 곱셈 연산의 성질을 분석할 수 있다
> - 곱셈에 대해 닫혀 있음
> - 곱셈에 대한 교환법칙이 성립함
> - 덧셈과 곱셈에 대한 분배법칙이 성립함
> - 곱셈에 대한 항등원이 존재함
> 
> 복소수의 크기:
> - 2차원 벡터와 동일하게 실수부와 허수부의 각 요소를 제곱해 더한 다음, 제곱근을 취하는 방식으로 계산한다
> - 구한 복소수의 크기는 실수와 동일하게 절댓값 기호 $||$를 써서 나타낸다
> - 복소수의 노름(Norm)이라고도 부른다
> - $|(a, b)| = |(a, -b)| = \sqrt{a^2 + b^2}$
> 
> 단위 복소수(Unit complex number):
> - 크기가 1인 복소수
> 
> 켤레 복소수(Conjugate complex number):
> - 임의의 복소수를 $c$라고 하면 $c$의 켤레 복소수는 * 첨자 기호를 사용한 $c^*$나 $\overline{c}$로 표시한다
> - 임의의 복소수 $a + bi$의 켤레 복소수 $c^*$는 다음과 같이 정의할 수 있다       
> $c = a + bi = (a, b)$       
> $c^* = a - bi = (a, b)$
> - 켤레 복소수의 기호는 연산처럼 사용할 수 있으며, 다음 성질이 성립된다      
> $(c^*)* = c$        
> $c^*c = cc^*$       
> $(c_1c_2)^* = c_2^*c_1^*$
> - 어떤 복소수에 그 켤레 복소수를 서로 곱하면 해당 복소수의 크기를 제곱한 값을 얻을 수 있다      
> $cc^* = (a + bi) \cdot (a - bi) = a^2 + b^2 = |c|^2$
> 
> 복소수 곱셈의 역원:
> - 임의의 복소수 $c$에 대한 곱셈의 역원을 $c^{-1}$라고 할 때, 그 역원의 분모와 분자에 각각 켤레 복소수를 곱한다      
> $c^{-1} = \frac{1}{c} = \frac{c^*}{cc^*}$
> - 켤레 복소수의 성질에 따라 분모의 허수부가 제거되면서 역원의 표현이 가능해진다 
> - 임의의 복소수 $(a, b)$에 대한 곱셈의 역원을 구하는 식     
> $(a + bi)^{-1} = \frac{1}{(a + bi)} = \frac{(a - bi)}{(a + bi)(a - bi)} = \frac{(a - bi)}{(a^2 + b^2)}$
> - 복소수 $c$에 대한 곱셈의 역원 $c^{-1}$는 다음과 같이 켤레 복소수와 복소수 크기에 관한 식으로 나타낼 수 있다       
> $c^{-1} = \frac{c^*}{|c|^2}$        
> - 해당 복소수 크기가 1인 단위 복소수라면 분모의 값은 1이 된다       
> 따라서 단위 복소수의 곱셈 역원은 바로 켤레 복소수가 된다    
> - 복소수 집합은 덧셈과 곱셈에 대해 교환법칙, 결합법칙, 분배법칙이 성립되며 덧셈과 곱셈의 항등원과 역원까지 존재하므로 체의 구조를 만족한다

* * *

[본문](README-ORIGIN3.md#422-복소수의-구조)

# 43. 복소평면
### 선요약

> 복소평면(Complex plane):
> - 실수부에 해다하는 실수축과 허수부에 해당하는 허수축을 직각으로 교차시켜 표현하는 방식
> - 복소평면의 두 축의 이름을 순서대로 실수축($Re$)과 허수축($Im$)으로 설정하면 순서쌍으로 표현한 복소수 $(a, b)$는 좌표처럼 평면 상에 표현할 수 있다
> - 크기가 1인 단위 복소수를 모아 복소평면에서 표현하면 단위원의 형태가 만들어진다

* * *

[본문](README-ORIGIN3.md#43-복소평면)

# 43.1. 단위 복소수와의 곱
### 선요약

> 단위 복소수 곱셈의 성질:
> - 허수부가 0인 임의의 복소수 $(a, 0)$에 $i$라는 단위 복소수를 곱하면 다음과 같이 전개된다       
> $(a + 0i) \cdot (0 + i) = (0 + ai) = (0, a)$
> - 실수 $a$와 허수 $i$와의 곱셈 연산의 결과 $(0, a)$를 복소평면 상에 나타내보면 복소수 $(a, 0)$을 $90^\circ$ 회전시킨 결과와 같다
> - 복소수에 단위 복소수를 반복해서 곱하면 원래 값으로 돌아온다
> - 임의의 복소수에 단위 복소수 $i$를 곱한 결과는 해당 복소수를 $90^\circ$ 회전시킨 결과와 같다
> - 임의의 복소수 $(a, b)$에 복소수 $i$를 곱한 결과는 항상 실수부와 허수부의 값이 바뀌어 다음과 같은 식으로 표현된다      
> $(a, b) \cdot (0, 1) = (-b, a)$
> - 삼각함수의 공식 $\cos^2\theta + \sin^2\theta = 1$을 이용해 단위원을 형성하는 임의의 단위 복소수 $(a, b)$를 다음과 같이 삼각함수로 표현할 수 있다      
> $(a, b) = \cos\theta + i\sin\theta = (\cos\theta, \sin\theta)$
> - 삼각함수로 나타낸 단위 복소수에 임의의 복소수 $(x, y)$를 곱하면 복소수의 곱셈 식은 다음과 같이 전개된다       
> $(\cos\theta, \sin\theta) \cdot (x, y) = (x \cos\theta - y \sin\theta, y \cos\theta + x \sin\theta)$        
> 이는 2차원 공간의 회전행렬 $R$에 2차원 벡터 $(x, y)$를 곱한 결과와 같다     
> 따라서 임의의 복소수에 단위 복소수를 곱하는 것은 복소평면에서의 회전 변환을 의미한다
> - 서로 다른 각을 갖는 2개의 단위 복소수를 곱한 결과는 다음과 같다       
> $(\cos\alpha, \sin\alpha) \cdot (\cos\beta, \sin\beta) = (\cos\alpha\cos\beta - \sin\alpha\sin\beta, \sin\alpha\cos\beta + \sin\beta\cos\alpha)$        
> 위 식은 삼각함수의 덧셈 정리에 의해 다음과 같이 간단하게 표기된다       
> $(\cos(\alpha + \beta), \sin(\alpha + \beta))$      
> 이로써 서로 다른 두 각을 회전 변환한 후 곱셈 연산을 하는 것은 두 각의 합을 회전 변환하는 것과 동일함을 확인할 수 있다
> - 복소수 곱셈의 항등원은 실수에서의 곱셈의 항등원과 동일하게 1이다      
> 복소수 1 역시 단위 복소수로서, 이를 삼각함수로 표현하면 다음과 같이 각 $0^\circ$에 대응하는 수다        
> $(1, 0) = (\cos0^\circ, \sin0^\circ)$       
> 따라서 곱셈의 항등원을 곱한다는 의미는 아무런 변화가 일어나지 않는 $0^\circ$의 회전 변환이라 해석할 수 있다
> - 실수에서 크기가 1인 수는 오직 1과 -1 두가지만 존재한다        
> 이 두 수를 한 차원 높은 복소수에서 바라보면 각각은 $(1, 0)$과 $(-1, 0)$에 대응되고, 이들과의 곱은 각각 $0^\circ$와 $180^\circ$의 회전 변환으로 해석할 수 있다

* * *

[본문](README-ORIGIN3.md#431-단위-복소수와의-곱)

# 43.2. 켤레 복소수의 회전 변환
### 선요약

> 복소평면에서 켤레 복소수의 의미:
> - 임의의 복소수와 그 켤레 복소수는 실수부 축($Re$)을 중심으로 서로 대칭된 형태를 이룬다
> - 단위 복소수를 $(\cos\theta, \sin\theta)$라고 표현할 때 이의 켤레 복소수는 $(\cos\theta, -\sin\theta)$가 된다      
> 삼각함수의 성질을 활용하면 켤레 복소수는 다음과 같이 표현할 수 있다     
> $(\cos\theta, -\sin\theta) = (\cos(-\theta), \sin(-\theta))$        
> 따라서 단위 복소수가 실수 축에 위치한 단위 복소수 $(1, 0)$을 각 $\theta$만큼 회전한 수를 의미한다면, 켤레 복소수는 반대 방향인 $-\theta$만큼 회전한 수를 의미한다
> - 임의의 복소수 $(a, b)$에 단위 복소수를 곱하면 반시계 방향의 회전이 발생하는 데 반해, 단위 복소수의 켤레 복소수를 곱하면 시계 방향의 회전이 발생한다
> - 단위 복소수와 그 켤레 복소수를 곱한 값은 복소수의 크기의 제곱이므로 1이 된다      
> $c \cdot c^* = a^2 + b^2 = \sin^2\theta + \cos^2\theta = 1$     
> 이 식을 변환의 관점에서 해석하면 각 $\theta$만큼 회전한 후에 바로 $-\theta$만큼 거꾸로 회전하는 변환을 의미한다     
> 이 결과는 아무런 회전도 일어나지 않는 $0^\circ$ 회전 변환을 의미하므로 복소수 곱셈의 항등원 $(1, 0)$이 됨을 확인할 수 있다

* * *

[본문](README-ORIGIN3.md#432-켤레-복소수의-회전-변환)

# 44. 복소수와 행렬의 관계
### 선요약

> 복소수의 2차원 행렬 대응:
> - 복소수를 수의 관점이 아닌 변환의 관점에서 바라본다면 2차원 복소평면 상의 복소수는 2차원 행렬에 대응된다
> - 회전을 수행하는 단위 복소수와 2차원의 회전 변환행렬이 동일하다고 가정하고 수식을 전개한 뒤 $\cos\theta$와 $\sin\theta$에 대해 분리해 정리하면 실수부에 대응하는 행렬 $I$와 허수 $i$에 대응하는 행렬 $J$를 확인할 수 있다
> - 실수부에 대응하는 행렬 $I$는 어떤 수에 곱했을 때 아무 변화가 없는 항등행렬이고, 이는 곱셈의 항등원 1과 동등한 개념이다        
> 허수 $i$에 대응하는 행렬 $J$는 $90^\circ$ 회전 변환행렬인데 이를 두 번 곱하면 $-I$가 나오며, 이는 $-1$에 대응한다고 볼 수 있다      
> 이는 두 번 곱하면 $-1$이 나오는 허수 단위의 성질과도 일치한다
> 
> $$\cos\theta + i\sin\theta = 
\begin{bmatrix}
\cos\theta & -\sin\theta \\
\sin\theta & \cos\theta \\
\end{bmatrix}$$
> 
> $$\cos\theta + i\sin\theta =
\cos\theta \cdot
\begin{bmatrix}
1 & 0 \\
0 & 1 \\
\end{bmatrix} +
\sin\theta \cdot 
\begin{bmatrix}
0 & -1 \\
1 & 0 \\
\end{bmatrix}$$
> 
> $$I =
\begin{bmatrix}
1 & 0 \\
0 & 1 \\
\end{bmatrix}$$
> 
> $$J = 
\begin{bmatrix}
0 & -1 \\
1 & 0 \\
\end{bmatrix}$$
> 
> $$J \cdot J =
\begin{bmatrix}
-1 & 0 \\
0 & -1 \\
\end{bmatrix} = -I$$
> 
> $$i \cdot i = -1$$

* * *

[본문](README-ORIGIN3.md#44-복소수와-행렬의-관계)

# 45. 자연지수함수
### 선요약

> 오일러 공식:
> - $e^{i\theta} = \cos\theta + i\sin\theta$
> - 좌변에 위치한 자연지수함수의 밑을 무리수 $e$라고 한다

* * *

[본문](README-ORIGIN3.md#45-자연지수함수)

# 45.1. 무리수 e
### 선요약

> 무리수 $e$:  
> - 무리수 $e$는 복리로 얻을 수 있는 수익을 연구하다가 발견했으며, 다음 식에 굉장히 큰 값을 $x$값에 대입할수록 이의 결괏값은 특정 상수에 근접한다는 사실을 알아내게 되었다        
> $y = (1 + \frac{1}{x})^x$
> - 위 식의 $x$에 양의 실수를 대입해보면, $x$값이 증가하면 $y$값도 증가하지만, $x$값이 증가할수록 $y$의 증가량은 서서히 줄어들고 $x$가 굉장히 커질수록 2와 3사이에 있는 어떤 특정한 수에 근접하게 된다        
> $x$가 굉장히 커졌을 때 $y$값은 약 $2.7182818...$에 근접하며, 이 수를 무리수 $e$라고 부른다
> - 무리수 $e$는 극한(Limit)과 무한대($\infty$)의 개념을 사용해 다음과 같이 표현할 수 있다        
> $e = \lim_{x \rightarrow \infty}(1 + \frac{1}{x})^x$        
> $\infty$로 표시하는 무한대(Infinity)란 특정한 수를 가리키는 것이 아니고, 어떤 실수보다도 큰 상태를 의미한다
> - 극한이란 어떤 값 $x$가 지정한 값 $a$에 한없이 가까워질 때 함수 $f(x)$가 한없이 가까워지는 값 $L$을 의미하며, 이는 다음의 수식으로 표현한다        
> $L = \lim_{x \rightarrow a}f(x)$
> 
> - 수렴(Converge): 극한의 결괏값이 특정한 값에 한없이 가까워진다면 이를 어떤 값에 수렴한다고 표현한다
> - 발산(Diverge): 극한의 결괏값이 특정한 값에 수렴하지 않고 무한대로 증가하거나 여러 값들을 오고가면 발산한다고 표현한다
> 
> 극한과 무한대의 개념을 사용해 표현한 무리수 $e$ 식에서 함수 $(1 + \frac{1}{x})^x$에 사용하는 입력이 한없이 크면 그 결과는 무리수 $e$에 수렴한다고 설명할 수 있다

* * *

[본문](README-ORIGIN3.md#451-무리수-e)

# 45.2. 자연지수함수
### 선요약

> - 거듭제곱(Exponentiation): 같은 수를 여러 번 곱하는 작업
> - 지수(Exponent): 거듭제곱에서 곱하는 횟수
> - 밑(Base): 거듭제곱에서 곱하는 수      
> 예를 들어 3을 5번 거듭제곱한 식은 다음과 같이 지수와 밑을 사용해 $3^5$으로 짧게 표기한다        
> $3^5 = 3 \cdot 3 \cdot 3 \cdot 3 \cdot 3$
> - 지수법칙(Law of exponents): 거듭제곱을 구성하는 밑과 지수가 가지는 연산의 특징
> 
> 0보다 큰 수 무리수 $e$에 통용되는 3가지 지수법칙:
> 1. 밑이 같은 거듭제곱 간의 곱셈은 지수를 더한 거듭제곱과 동일하다        
> $a^m \cdot a^n = a^{m + n}$
> 2. 거듭제곱의 거듭제곱은 지수를 곱한 거듭제곱과 동일하다         
> $(a^m)^n = a^{m \cdot n}$       
> 거듭제곱의 개념은 수를 세는 자연수에서 비롯됐지만, 자연수가 아닌 0으로도 확장이 가능하다        
> 곱셈의 항등원 1을 활용해 0의 거듭제곱의 값은 다음과 같이 유도할 수 있다     
> $a^m = a^{(m + 0)} = a^m \cdot a^0 = a^m \cdot 1$       
> 따라서 다음과 같은 세 번째 지수법칙이 성립한다
> 3. 지수가 0인 거듭제곱은 항상 1의 값을 갖는다        
> $a^0 = 1$
> 
> - 지수함수(Exponential function): 거듭제곱의 지수에 미지수 $x$를 대입해 만든 함수       
> 밑이 $a$인 지수함수는 다음과 같이 표시한다      
> $f(x) = a^x$        
> 지수법칙에 따라 지수함수의 $x$값이 0이면 출력은 항상 1이 된다       
> 그러므로 밑이 0보다 큰 지수함수의 그래프는 언제나 좌표 $(0, 1)$을 지난다
> - 자연지수함수(Natural exponential function): 무리수 $e$를 밑으로 하는 지수함수     
> $f(x) = e^x$        
> 자연지수함수 $y = e^x$는 언제나 $(0, 1)$을 지나며 그래프를 그려보면 $x$가 커질수록 급격히 증가하는 형태를 띤다

* * *

[본문](README-ORIGIN3.md#452-자연지수함수)

# 46. 미분
### 선요약

> - 미분(Differentiation): 미분 가능한 함수를 대상으로 특정 지점에서의 접선의 기울기를 측정하는 작업      
> 미분 가능한 함수는 뾰족점이 없이 끊이지 않고 연속으로 이어져 있는 함수다        
> 자연지수함수, $\sin$ 함수, $\cos$ 함수도 모두 미분 가능한 함수다
> - 할선(Secant line): 어떤 미분 가능한 함수가 주어졌을 때 $x$값 $a$와 $b$에 대응되는 두 좌표를 연결해 만든 직선      
> 할선의 기울기는 다음과 같이 구할 수 있다        
> $m = \frac{f(b) - f(a)}{b - a}$     
> 여기서 $a$를 고정시킨 상태에서 $b$를 서서히 $a$로 이동시킨다고 가정하면, $b$를 $a$로 이동시킴에 따라 할선의 기울기는 시시각각 변화한다      
> $b$ 값이 왼쪽으로 이동해 $a$에 도달하면 할선의 기울기를 구하는 식의 분모 값은 0이 되어 할선은 더 이상 존재하지 않게 된다        
> 하지만 $b$가 $a$에 한없이 가깝게 접근했다면, 할선은 여전히 존재하며, 마치 $a$ 지점에서의 기울기처럼 보인다
> - 접선(Tangent line): 한없이 가까워지는 개념을 사용해 특정 지점에서의 기울기를 나타내는 선      
> 접선의 개념은 무리수 $e$에서 언급한 극한의 한없이 가까워지는 성질과 동일하다        
> 따라서 $b$가 $a$로 한없이 가까워질 때 접선의 기울기 $m$ 값은 극한을 적용해 다음과 같이 계산한다     
> $m = \lim_{b \rightarrow a}\frac{f(b) - f(a)}{b - a}$       
> 위 식에서 $a$에 한없이 가까워진 $b$ 값은 $a$에서 한없이 작은 값 $h$를 더한 값과 같다        
> 따라서 이 식에서 $f(b)$의 값을 $f(a + h)$로 바꾸고 $b - a$를 $h$로 바꾸면 접선식은 다음과 같이 바꿔 표현할 수 있다      
> $m = \lim_{h \rightarrow 0}\frac{f(a + h) - f(a)}{h}$       
> 이 값을 $a$에서의 미분 계수(Differential coefficient)라고 한다

* * *

[본문](README-ORIGIN3.md#46-미분)

# 46.1. 도함수
### 선요약

> 도함수(Derivative):
> - 함수가 모든 구간에서 미분이 가능하다면 이 개념을 확대해 임의의 수에 대해 미분 계수를 구할 수 있는 수식이 만들어진다       
> 이렇게 임의의 수 $x$에 대한 미분 계수를 구할 수 있도록 일반화한 함수를 도함수 또는 미분이라고 한다
> - 함수 $f(x)$의 도함수는 기호 $f'(x)$로 표시한다
> - 임의의 수 $a$에서의 미분 계수를 구하는 데 사용한 식을 임의 수 $x$에 대해 정리한 도함수 식은 다음과 같다       
> $f'(x) = \lim_{h \rightarrow 0}\frac{f(x + h) - f(x)}{h}$
> 
> 상수함수의 도함수:
> - 정의역과 무관하게 항상 일정한 값을 가지는 함수를 상수함수라고 한다
> - 일정한 값 $c$의 상수함수는 다음의 수식으로 나타낸다       
> $f(x) = c$
> - 상수함수의 그래프는 $x$축과 수평한 선의 형태를 띤다
> - 상수함수는 모든 정의역의 원소에 대해 항상 상수 $c$가 나온다       
> 따라서 상수함수의 도함수를 계산하면 그 결과는 언제나 0이 된다       
> 이는 상수함수의 모든 $x$에 대한 접선의 기울기가 0임을 뜻한다
> 
> 극한의 성질 6가지:
> - 두 함수 합의 극한값은 각 극한값의 합과 같다       
> $\lim_{x \rightarrow a}[f(x) + g(x)] = \lim_{x \rightarrow a}f(x) + \lim_{x \rightarrow a}g(x)$
> - 상수와 함수 곱의 극한값은 함수 극한값에 상수를 곱한 것과 같다     
> $\lim_{x \rightarrow a}cf(x) = c\lim_{x \rightarrow a}f(x)$
> - 두 함수 곱의 극한값은 각 극한값의 곱과 같다       
> $\lim_{x \rightarrow a}[f(x) \cdot g(x)] = \lim_{x \rightarrow a}f(x) \cdot \lim_{x \rightarrow a}g(x)$
> - 두 함수 나눗셈의 극한값은 각 극한값의 나눗셈과 동일하다       
> 단 분모의 극한값은 0이 아니어야 한다        
> $\lim_{x \rightarrow a}[\frac{f(x)}{g(x)}] = \frac{\lim_{x \rightarrow a}f(x)}{\lim_{x \rightarrow a}g(x)}$
> - 함수를 거듭제곱한 극한값은 극한값을 거듭제곱한 값과 같다      
> $\lim_{x \rightarrow a}[f(x)]^n = [\lim_{x \rightarrow a}f(x)]^n$
> - 세 함수의 대소 관계가 $g(x) \leq f(x) \leq h(x)$와 같을 때 양변 $g(x)$와 $h(x)$의 극한값이 같다면 가운데 위치한 함수 $f(x)$의 극한값도 같다       
> 즉 $lim_{x \rightarrow a}g(x) = \lim_{x \rightarrow a}h(x) = L$이면 $lim_{x \rightarrow a}f(x) = L$이 성립한다      
> 이를 조임 정리(Squeeze theorem)라고 한다
> 
> 거듭제곱 함수의 도함수:
> - $f(x) = x^n$의 도함수는 다음과 같이 전개된다      
> $f'(x) = n \cdot x^{n - 1}$

* * *

[본문](README-ORIGIN3.md#461-도함수)

# 46.2. 자연지수함수의 도함수
### 선요약

> 자연지수함수 $f(x) = e^x$의 도함수:
> - 자연지수함수의 도함수는 다음과 같이 원함수와 동일하다는 특징을 가진다     
> $f'(x) = e^x$
> - 함수를 미분했을 때 그 결과가 원함수와 동일하다면 그 함수는 몇 번을 미분하더라도 그 결과는 언제나 원함수와 동일하게 유지된다       
> 따라서 자연지수함수는 무한번 미분 가능하다는 성질을 가진다

* * *

[본문](README-ORIGIN3.md#462-자연지수함수의-도함수)

# 46.3. sin 함수와 cos 함수의 도함수
### 선요약

> $\sin$ 함수와 $\cos$ 함수의 도함수:
> - $\sin$ 함수의 도함수는 $\cos x$가 된다
> - $\cos$ 함수의 도함수는 $-\sin x$가 된다
> - $\sin$ 함수와 $\cos$ 함수는 네 번 미분하면 원함수로 돌아오기 때문에 자연지수함수와 동일한 성질을 가진 무한번 미분 가능한 함수다

* * *

[본문](README-ORIGIN3.md#463-sin-함수와-cos-함수의-도함수)

# 47. 급수
***오일러 공식에는 자연지수함수와 두 삼각함수의 미분이 사용된다***.   
***무한번 미분 가능하다는 공통점을 가진 세 함수는 각각 무한 급수로 표현***될 수 있고 세 함수가 모두 무한 급수로 표현되면 오일러 공식을 유도할 수 있다.    
무한번 미분 가능한 함수를 무한 급수로 표현하기 위해선 ***등비수열***에 대해 알아야 한다.

# 47.1. 등비수열
### 선요약

> - 수열(Sequence): 규칙에 따라 순서에 맞게 수를 나열한 것이다        
> 예를 들어 1부터 시작해 1씩 커지는 자연수를 순서대로 나열하면 1, 2, 3, 4, ...로 이어지는 수열을 이룬다
> - 수열과 집합의 차이: 집합은 순서의 개념이 없고 중복을 허용하지 않는다는 점에서 수열과는 엄연히 다른 개념이다
> - 등비수열(Geometric sequence): 연속된 항들이 일정한 비(Ratio)로 증가하는 수열
> - 공비(Common ratio): 등비수열 규칙에 사용된 비     
> 다음은 등비수열의 한 예시로, 연속된 두 항이 $\frac{1}{2}$배씩 증가하는 규칙을 가지므로 공비는 $\frac{1}{2}$이 된다      
> $\frac{1}{2}, \frac{1}{4}, \frac{1}{8}, \frac{1}{16}, \frac{1}{32}, ...$
> - 초항(First term): 수열의 첫 번째 값
> - 등비수열 표기: 초항은 $a$로, 공비는 $r$로, $n$번째의 항은 $a_n$으로 표기하며 다음과 같은 식으로 등비수열을 나타낸다       
> $a_n = a \cdot r^{n - 1}$       
> 등비수열의 $n + 1$번째 항과 $n$번째 항에 공비를 적용하면 다음과 같은 관계가 성립한다        
> $a_{n + 1} = a_{n} \cdot r$

* * *

[본문](README-ORIGIN3.md#471-등비수열)

# 47.2. 급수
### 선요약

> - 급수(Series): 수열의 개념을 확장해 모든 값을 더한 것을 급수라고 한다      
> 초항 $a_0$와 $n$개의 요소로 구성된 수열의 급수는 시그마 기호($\sum$)를 활용해 간략히 표현한다       
> $\sum_{k = 0}^n a_k = a_0 + a_1 + a_2 + a_3 + ... + a_n$
> - 기하급수(Geometric series): 등비수열의 급수를 특별히 기하급수라고 한다        
> 기하급수는 다음과 같이 표현할 수 있다       
> $\sum_{k = 0}^\infty a \cdot r^k$       
> 기하급수는 무한대로 계속 증가하거나 특정 수로 수렴하는 성질이 있다
> - 진동(Oscillate): 극한값이 일정한 값을 가지지 못하고 규칙적으로 값을 오고가는 현상     
> 특정 값으로 수렴하지 않으므로 발산한다
> - 멱급수(Power series): 항마다 계수가 다른 급수         
> $\sum_{n = 0}^\infty a_n \cdot r^n = a_1 + a_2r + a_3r^2 + a_4r^3 + a_5r^4 + ...$       
> 기하급수는 모든 계수의 값이 동일한 멱급수의 한 종류라고 할 수 있다      
> 멱급수도 기하급수와 동일하게 특정 조건에 따라 수렴하거나 발산하는데, 이를 판정하기 위해 비판정법을 사용한다
> - 비판정법(Ratio test): 비판정법은 멱급수의 항의 계수가 일정한 규칙으로 전개되는 경우, 다음의 극한값을 구해 수렴, 발산 여부를 파악하는 방법이다     
> $L = \lim_{n \rightarrow \infty}|\frac{a_n + 1}{a_n}|$      
> 비판정법의 결과로 계산되는 $L$의 값은 다음과 같은 3가지 경우가 있다     
>     - $L$의 값이 1보다 작으면 급수는 언제나 수렴한다.
>     - $L$의 값이 1보다 크면 급수는 언제나 발산한다.
>     - $L$의 값이 1이면 수렴할 수도, 발산할 수도 있다.       
> 
> 기하급수를 멱급수의 관점에서 다시 살펴보면, 기하급수는 모든 계수의 값이 동일한 $a$이고 공비가 $r$인 멱급수의 형태를 띤다        
> $\sum_{n = 0}^\infty a \cdot r^n$       
> 이 식에 비판정법을 적용한 결과 값은 $n$과 무관하게 $|r|$이 나온다       
> $L = \lim_{n \rightarrow \infty}|\frac{a \cdot r^{n + 1}}{a \cdot r^n}| = |r|$      
> 급수가 수렴하기 위해서는 $L$의 값이 1보다 작아야 하는데 이는 $|r| < 1$을 의미한다       
> 이는 앞서 살펴본 기하급수가 수렴하기 위한 조건과 동일하다
> - 수렴반지름(Radius of convergence): 멱급수가 수렴하기 위해 $r$이 가져야 할 범위를 수렴구간이라고 하며, 범위의 절반인 1의 값을 수렴반지름이라고 한다

* * *

[본문](README-ORIGIN3.md#472-급수)

# 47.3. 매클로린 급수
### 선요약

> - 매클로린 급수, 테일러 급수(Maclaurin series, Taylor series): 무한 미분 가능한 함수를 멱급수 형태로 바꾼 것      
> 멱급수 전개는 $n$번 미분한 도함수에 0을 대입한 형태로 일반화할 수 있다      
> 이를 매클로린 급수 또는 테일러 급수라고 한다        
> 매클로린 급수는 무한급수이므로 무한 미분 가능한 함수만이 일반화식을 만족할 수 있다
> - 계승(Factorial): 어떤 자연수보다 작은 모든 자연수의 곱        
> ! 기호를 사용해서 축약해 표현한다       
> $n! = (n - 1)! \cdot n$     
> $\therefore (n - 1)! = \frac{n!}{n}$        
> 0의 계승 0!의 값은 1이다    
> - 자연지수함수, $\sin$ 함수, $\cos$ 함수의 매클로린 급수 형식 전개: 세 함수의 매클로린 급수 모두 유효하다
> - 매클로린 급수의 활용: 매클로린 급수는 컴퓨터에서 복잡한 함수의 근사값을 구할 때 유용하게 사용된다     
> 예를 들어 $\sin$ 함수의 값을 컴퓨터에서 계산하고자 하는 경우 매클로린 급수를 사용하면 허용 가능한 오차 내의 이의 정밀한 값을 빠르게 계산할 수 있다

* * *

[본문](README-ORIGIN3.md#473-매클로린-급수)

# 48. 오일러 공식
### 선요약

> $\sin$ 함수와 $\cos$ 함수의 매클로린 급수를 합하면 서로에게 부족한 부분이 채워진다      
> 자연지수함수에 허수 단위 $i$를 넣은 결과는 $\sin$ 함수와 $\cos$ 함수의 매클로린 급수 합과 동일한 부호가 만들어진다      
> $\cos x + \sin x$에서 짝수 항은 $\sin$ 함수가 담당하므로 $\sin$ 함수에 허수 $i$를 곱하면 오일러 공식이 완성된다
> 
> $$e^{ix} = \cos x + i \sin x$$      
> 
> $$e^{i\theta} = \cos \theta + i \sin \theta$$
> 
> 우변의 식 $\cos \theta + i \sin \theta$는 복소평면에서 회전 변환을 담당하는 단위 복소수를 의미한다      
> 따라서 오일러 공식의 좌변에 위치한 $e^{i\theta}$는 복소평면에서의 회전 변환을 의미한다
> 
> $$e^{i\theta} = (\cos\theta, \sin\theta) = 
\begin{bmatrix}
\cos \theta & -\sin \theta \\
\sin \theta & \cos \theta \\
\end{bmatrix}$$
> 
> 행렬과 복소수를 사용해 표현했던 회전 변환을 오일러 공식으로 $e^{i\theta}$라는 자연지수함수로 더욱 간단하게 표현할 수 있다       
> 예를 들어 각 $\alpha, \beta$의 회전 변환은 오일러 공식에 의해 각각 $e^{\alpha i}$와 $e^{\beta i}$로 표현할 수 있다      
> 이 둘을 곱하면 $(\alpha + \beta)$의 회전 변환이 만들어지는데, 지수법칙에 의해 이 둘을 곱하면 자연스럽게 $e^{(\alpha + \beta)i}$가 만들어진다        
> 
> $$e^{(\alpha + \beta)i} = e^{\alpha i} \cdot e^{\beta i}$$

* * *

[본문](README-ORIGIN3.md#48-오일러-공식)

# 49. 사원수 대수
### 선요약

> - 사원수: 하나의 실수부와 세 개의 허수부로 구성된다     
> 세 허수부를 구성하는 단위를 각각 $i, j, k$로 표시한다

* * *

[본문](README-ORIGIN3.md#49-사원수-대수)    

# 49.1. 사원수를 구성하는 세 허수
### 선요약

> 사원수의 3개의 허수부 $i, j, k$는 모두 복소수의 허수 단위 $i$와 같은 성질을 가진다      
> 
> $$i^2 = -1$$
> 
> $$i^2 = j^2 = k^2 = -1$$
> 
> 세 허수 중에서 두 허수의 곱은 다음과 같이 나머지 다른 허수에 대응되는데 이들은 회전의 순환 순서 $x \rightarrow y \rightarrow z \rightarrow x$와 유사하게 $i \rightarrow j \rightarrow k \rightarrow i$ 순서로 대응된다      
> 
> $$ij = k, jk = i, ki = j$$
> 
> 위 식으로부터 $ij$의 값은 $k$가 되고 $kk$의 결과는 $-1$이므로 $ijk = -1$이라는 식이 성립한다        
> 따라서 $ijk$ 값은 $-1$이 되며, 각 세 허수의 곱셈 결과는 다음과 같다
> 
> $$ijk = jki = kij = -1$$
> 
> 실수부와 각 허수부의 계수를 $a, b, c, d$로 지정한 사원수는 다음과 같이 표현한다
> 
> $$q = a + bi + cj + dk$$
> 
> 사원수의 집합 기호: $H$

* * *

[본문](README-ORIGIN3.md#491-사원수를-구성하는-세-허수)        

# 49.2. 사원수의 구조
### 선요약

> 사원수의 덧셈:
> - 복소수와 유사하게 실수부와 각 허수부끼리 더하는 형태로 진행       
> $q_1 + q_2 = (a_1 + a_2) + (b_1 + b_2)i + (c_1 + c_2)j + (d_1 + d_2)k$
> - 사원수의 덧셈이 만족하는 성질     
> 
> |연산의 성질|만족 여부 및 값|
> |---|---|
> |덧셈에 대해 닫혀 있음|O|
> |덧셈에 대한 교환법칙이 성립함|O|
> |덧셈에 대한 결합법칙이 성립함|O|
> |덧셈에 대한 항등원이 존재함|0|
> |덧셈에 대한 역원이 존재함|$-(a + bi + cj + dk)$|
> 
> 사원수의 곱셈:
> - 해밀턴 곱(Hamilton product)으로도 불림
> - 모든 요소를 교차해 곱하는 방식으로 진행
> - 사원수는 총 4가지 요소로 구성되므로 곱의 결과는 총 16가지 인자가 만들어지며, 임의의 두 사원수 $q_1$과 $q_2$의 곱셈 결과는 다음과 같다     
> $q_1 \cdot q_2 = (a_1a_2 - b_1b_2 - c_1c_2 - d_1d_2) + (a_1b_2 + a_2b_1 + c_1d_2 - d_1c_2)i + (a_1c_2 + a_2c_1 + b_2d_1 - b_1d_2)j + (a_1d_2 + a_2d_1 + b_1c_2 - c_1b_2)k$
> - 사원수의 곱셈이 만족하는 성질
> 
> |연산의 성질|만족 여부 및 값|
> |---|---|
> |곱셈에 대해 닫혀 있음|O|
> |곱셈에 대한 교환법칙이 성립함|X|
> |곱셈에 대한 결합법칙이 성립함|O|
> |곱셈에 대한 항등원이 존재함|1|
> |곱셈에 대한 역원이 존재함|켤레를 활용해 계산|
> |덧셈과 곱셈에 대한 분배법칙이 성립함|O|
> 
> 유사체(Skew field):
> - 체의 구조에서 교환법칙이 성립하지 않는 구조
> - 사원수는 유사체의 구조를 지니며 사원수끼리 곱셈식을 전개할 때는 왼쪽과 오른쪽의 순서가 바뀌지 않도록 주의해야 한다
> 
> 사원수의 크기:
> - 노름(Norm)이라 부른다
> - 사원수의 크기는 복소수와 동일하게 각 계수를 제곱한 값을 더하고 제곱근을 취해 계산하며 절댓값 기호 $| |$를 써서 표기한다       
> $|q| = \sqrt{a^2 + b^2 + c^2 + d^2}$
> 
> 단위 사원수(Unit quaternion):
> - 사원수 중에서 크기가 1인 사원수
> 
> 켤레 사원수:
> - 사원수의 세 허수부의 계수에 음수를 적용한 사원수
> - $q^*$로 표기하며 다음과 같이 표현한다     
> $q^* = a - (bi + cj + dk)$
> - 사원수와 켤레 사원수의 곱은 복소수와 켤레 복소수 간의 곱의 성질과 동일하다        
> $(q^*)^* = q$       
> $(pq)^* = q^*p^*$
> - 임의의 사원수에 그 켤레를 곱하면 크기의 제곱 값이 나온다      
> $q^*q = qq^* = a^2 + b^2 + c^2 + d^2 = |q|^2$
> - 단위 사원수와 그의 켤레 사원수를 곱한 값은 언제나 1이 된다
> - 사원수도 복소수와 동일하게 켤레 사원수의 성질을 사용해 사원수 곱의 역원을 유도할 수 있다      
> $q^{-1} = \frac{1}{q} = \frac{q^*}{qq^*} = \frac{q^*}{|q|^2}$
> - 크기가 1인 단위 사원수의 곱셈의 역원은 복소수와 동일하게 켤레 사원수가 된다

* * *

[본문](README-ORIGIN3.md#492-사원수의-구조)    

# 49.3. 사원수와 벡터
### 선요약

> 사원수를 다룰 때에는 허수부를 사용하는 3개의 수 집합을 하나로 묶고, 나머지 실수부는 별도로 관리하는 방법을 사용한다     
> 세 허수부의 계수를 3차원 벡터로 묶는다면, 사원수는 실수부와 3차원 벡터 두 가지 요소로 구성된다고 볼 수 있다     
> 사원수 $q$를 실수와 3차원 벡터로 구성된 순서쌍으로 표현하면 다음과 같다     
> 
> $$q = w + xi + yj + zk = (w, \vec{v})$$
> 
> 이 순서쌍의 원소를 차례대로 실수부, 허수부라고 하는데, 이들을 스칼라부, 벡터부라고도 부른다     
> 임의의 두 사원수를 $q_1 = (w_1, \vec{v_1}), q_2 = (w_2, \vec{v_2})$로 표현하고 사원수의 기본 연산인 덧셈과 곱셈을 다시 표현해보면, 사원수 $q_1$과 $q_2$의 덧셈은 다음과 같은 순서쌍으로 표현할 수 있다      
> 
> $$q_1 + q_2 = (w_1 + w_2, \vec{v_1} + \vec{v_2})$$
> 
> 사원수 $q_1$과 $q_2$의 곱셈은 벡터의 내적과 외적을 사용해 다음과 같이 정리할 수 있다
> 
> $$q_1 \cdot q_2 = (w_1w_2 - (\vec{v_1} \cdot \vec{v_2}), w_1\vec{v_2} + w_2\vec{v_1} + v_1 \times v_2)$$
> 
> 사원수의 곱셈을 내적과 외적으로 정리했는데, 이를 통해 사원수의 곱셈은 교환법칙이 성립하지 않는지도 확인할 수 있다       
> 허수부를 구성하는 벡터 연산이 교환법칙이 성립하지 않는 외적에 관련되어 있기 때문이다
> 
> 순허수 사원수(Pure imaginary quaternion): 
> - 사원수에서 실수부가 0인 사원수
> - 순허수 사원수는 세 허수로만 구성된 수를 말하며, 이는 3차원 벡터 공간에 대응되는 개념이다
> - 3차원 공간이 사원수를 다루는 4차원 공간의 일부라면, 3차원 공간의 벡터 $\vec{v} = (x, y, z)$는 다음의 순허수 사원수에 대응된다고 할 수 있다        
> $xi + yj + zk = (0, \vec{v})$
> - 순허수 사원수 $q_1$과 $q_2$의 곱셈을 전개하면, $w_1$과 $w_2$의 값이 0이다 보니 이들이 포함된 항의 값은 모두 0이 된다      
> 곱셈 결과는 아래와 같이 내적과 외적만 남아 더욱 단순해진다      
> $q_1 \cdot q_2 = (-\vec{v_1} \cdot \vec{v_2}, \vec{v_1} \times \vec{v_2})$

* * *

[본문](README-ORIGIN3.md#493-사원수와-벡터)    

# 50. 사원수의 회전
### 선요약

> 자연지수함수, $\sin$ 함수, $\cos$ 함수를 매클로린 급수로 전개했을 때 세 급수가 서로 통합되기 위해서는 크기가 1이고, 제곱한 수가 -1이 되는 특별한 수가 필요하다      
> 복소수 체계에서 이 조건을 만족하는 특별한 수인 허수 $i$를 사용해 다음의 오일러 공식을 전개할 수 있다        
> 
> $$e^{i\theta} = \cos \theta + i\sin\theta = (\cos\theta, \sin\theta)$$
> 
> 사원수에서도 허수 $i$와 동일하게 크기가 1이고 제곱한 값이 -1인 수가 있다

* * *

[본문](README-ORIGIN4.md#50-사원수의-회전) 

# 50.1. 사원수와 오일러 공식
### 선요약

> 크기가 1인 순허수 사원수는 크기가 1이고 제곱한 값이 -1이다      
> 오일러 공식의 전개 과정에 허수 $i$ 대신 순허수 사원수의 벡터 $\vec{n}$을 사용할 수 있다     
> 이렇게 하면 자연상수의 지수함수로 사원수의 회전을 표현하는 것이 가능해진다      
> 이를 수식으로 정리하면 복소수와 형태가 유사해진다
> 
> $$e^{\vec{n}\theta} = \cos\theta + \sin\theta \cdot \vec{n} = (\cos\theta, \sin\theta \cdot \vec{n})$$
> 
> 회전 사원수(Rotation quaternion): 
> - $(\cos\theta, \sin\theta \cdot \vec{n})$ 형태의 사원수는 4차원 공간에서 회전축 $\vec{n}$을 중심으로 회전 변환하는 성질을 가지는데, 이를 회전 사원수라고 한다      
> - 회전 사원수는 언제나 단위 사원수다
> 
> 회전 사원수의 켤레 사원수:
> - $q^* = (\cos\theta, -\sin\theta \cdot \vec{n})$
> - 이는 반대 방향의 회전을 의미한다      
> $q^* = (\cos(-\theta), \sin(-\theta) \cdot \vec{n})$
> - 단위 사원수와 그 켤레를 곱한 값은 언제나 1이 나오는데, 이를 자연지수함수로 표현하면 다음과 같이 0의 지수로 나타낼 수 있다     
> $q \cdot q^* = 1 = e^0$
> - 오일러의 공식에 의해 회전 사원수에 대응하는 지수함수는 다음과 같다    
> $q = e^{\vec{n}\theta}$     
> - 이를 회전 사원수 $q$에 치환한 식은 다음과 같이 전개된다     
> $e^{\vec{n}\theta} \cdot q^* = e^0$
> - 이를 만족하는 $q^*$의 값은 $e^{-\vec{n}\theta}$이며 이는 같은 축 $\vec{n}$을 중심으로 반대 방향으로 $\theta$ 돌리는 회전을 의미한다       
> $\therefore q^* = e^{-\vec{n}\theta} = e^{\vec{n}(-\theta)}$

* * *

[본문](README-ORIGIN4.md#501-사원수와-오일러-공식) 

# 50.2. 회전 사원수를 이용한 3차원 공간에서의 회전
### 선요약

> 회전 사원수 $q$를 사용해 임의의 회전축 $\vec{n}$에 대해 3차원 공간의 벡터 $\vec{v}$를 각 $\theta$만큼 회전시키는 방법:
> - 일반적으로 사용하는 3차원 공간의 벡터 $\vec{v}$는 순허수 사원수에 대응되는 개념이다
> - 회전축은 단위 벡터이기 때문에 $a^2 + b^2 + c^2 = 1$의 조건을 가진다
> - 회전 사원수 $q$를 사용해 벡터를 회전시키는 방법은 회전 사원수를 벡터의 왼쪽에 배치하고 둘을 곱한다
> - 계산 결과를 살펴보면 회전 사원수와 벡터를 곱한 결과는 순허수 사원수가 아닌 네 요소를 모두 사용하는 일반 사원수가 나온다       
> - 따라서 이 곱의 결과는 순허수 사원수와 1:1로 대응했던 3차원 공간의 규격에서 벗어나게 되므로 3차원 공간의 요소로 사용할 수 없게 된다
> - 3차원 공간에서 벡터를 회전시키는 용도로 사원수를 사용하기 위해서는 사원수 곱의 결과가 항상 순허수 사원수가 되는 특별한 수식을 사용해야 한다
> 
> 사원수 곱의 결과가 항상 순허수 사원수가 되는 회전 사원수의 곱셈:
> - 회전 사원수의 벡터 $\vec{n}$은 회전축의 역할을 수행한다
> - 이는 로드리게스 회전 공식에서 언급한 축-각 회전에 대응하는 벡터다
> - 회전시킬 벡터 $\vec{v}$를 회전축 $\vec{n}$에 평행한 성분과 수직인 성분으로 나눈다
> - 이를 각 $\theta$만큼 회전시킨 최종 벡터 $\vec{v'}$는 회전축에 수직인 성분만 회전시킨 후, 수평 성분은 그대로 더하면 구할 수 있다
> - 따라서 3차원 공간에서의 회전은 다음과 같은 식이 된다      
> $\vec{v'} = \vec{v_\parallel} + q \cdot \vec{v_\perp}$
> - 오일러 공식을 활용해 위 수식을 간단하게 정리할 수 있다        
> 이 식에서 회전 사원수 $q$를 자연지수함수로 바꿔 표현하면 다음과 같다        
> $\vec{v'} = \vec{v_\parallel} + e^{\vec{n}\theta} \cdot \vec{v_\perp}$
> - 회전축에 수직인 벡터와 회전 사원수의 곱으로 얻어지는 사원수는 항상 실수부 값이 0인 수허수 사원수가 된다       
> 때문에, 이의 결과는 언제나 3차원 공간의 벡터에 대응된다

* * *

[본문](README-ORIGIN4.md#502-회전-사원수를-이용한-3차원-공간에서의-회전)

# 51. 사원수의 변환
사원수를 활용해 3차원 벡터를 회전시키는 기능을 구현할 수 있지만, 사원수를 구성하는 요소 값은 직관적이지 않아 실제로 사용하는 회전을 설계할 때 어려움이 따른다.

3차원 공간에서 물체의 회전을 설정할 때에는 오일러 각 방식이 사원수보다 직관적이고 편리하기 때문에, 오일러 각의 값을 사원수로 변환해주는 기능을 만들면 게임 제작에 유용하게 사용할 수 있다.

# 51.1. 오일러 각에서 사원수로의 변환
### 선요약

> 오일러 각의 각 회전은 $x, y, z$ 기저 축이 회전축의 역할을 수행한다      
> 이를 사원수로 표현할 때, 3차원 공간에서 $x$축을 중심으로 각 $\theta$만큼 회전시키는 데 사용하는 회전 사원수 $q$는 다음과 같다       
> 
> $$q = (\cos\frac{\theta}{2}, \sin\frac{\theta}{2} \cdot \vec{x}) = \cos\frac{\theta}{2} + \sin\frac{\theta}{2}i$$
> 
> 오일러 각의 회전 순서를 롤, 피치, 요 순으로 적용하면, 이에 대응하는 사원수를 동일한 순서에 맞춰서 곱하여 오일러 각에 대응하는 사원수를 만들 수 있다

* * *

[본문](README-ORIGIN4.md#511-오일러-각에서-사원수로의-변환)

# 51.2. 사원수에서 오일러 각으로의 변환
거꾸로 사원수로부터 오일러 각의 값을 변환하는 방법에 대해 알아보자.     
[식 14-3](#식-14-3)에서 실수부를 $w$, 각 허수부 값을 $x, y, z$로 치환한 후 $2(wz + xy)$를 계산한 결과를 살펴본다.       
요, 롤 피치의 절반각을 $y, r, p$로 표기하고, 이들의 $\sin$ 값을 $sy, sr, sp$로 지정하고 $\cos$ 값을 $cr, cp, cy$로 지정해 식을 전개하면 다음과 같다.

$$
\begin{matrix}
w &=& cr \cdot cp \cdot cy + sr \cdot sp \cdot sy \\
z &=& sr \cdot cp \cdot cy - cr \cdot sp \cdot sy \\
wz &=& cy^2 \cdot cr \cdot cp^2 \cdot sr - cy \cdot ct^2 \cdot cp \cdot sy \cdot sp + cy \cdot cp \cdot sy \cdot sr^2 \cdot sp - cr \cdot sy^2 \cdot sr \cdot sp^2 \\
x &=& sy \cdot sr \cdot cp + sp \cdot cy \cdot cr \\
y &=& sy \cdot cp \cdot cr - sp \cdot sr \cdot cy \\
xy &=& cr \cdot cp^2 \cdot sy^2 \cdot sr - cy \cdot cp \cdot sy \cdot sr^2 \cdot sp + cy \cdot cr^2 \cdot cp \cdot sy \cdot sp - cy^2 \cdot cr \cdot sr \cdot sp^2 \\
\end{matrix}
$$

사원수로부터 오일러 각을 구하려면 사원수를 잘 조합해 단일 각에 대한 삼각함수가 나오도록 식을 설정해야 한다.     
롤 회전에 대한 삼각함수를 만들어주는 $wz + xy$의 값을 계산한다.

$$
\begin{matrix}
wz + xy &=& cr \cdot cp^2 \cdot sr - (cy \cdot cp \cdot sy \cdot sp) + cy \cdot cp \cdot sy \cdot sp - (cr \cdot sr \cdot sp^2) \\
&=& cr \cdot sr(cp^2 - sp^2) \\
&=& \frac{\sin(2r)}{2} \cdot \cos (2p) \\
\end{matrix}
$$

삼각함수의 배각 공식을 사용해 두 배의 각으로 변환한다.

$2(wz + xy)$의 값은 $\sin\theta_{roll} \cdot \cos \theta_{pitch}$가 된다.       
같은 방식으로 $1 - 2(z^2 + x^2)$를 계산하면 $\cos \theta_{roll} \cdot \cos \theta_{pitch}$가 된다.      
그렇다면 $\sin\theta_{roll} \cdot \cos\theta_{pitch}$ 값을 $\cos\theta_{roll} \cdot \cos \theta_{pitch}$로 나누면 다음과 같이 롤 회전의 $\tan$ 값이 나온다.

$$\frac{\sin\theta_{roll} \cdot \cos\theta_{pitch}}{\cos\theta_{roll} \cdot \cos\theta_{pitch}} = \tan\theta_{roll} = \frac{2(wz + xy)}{(1 - 2(z^2 + x^2))}$$

이제 롤 회전의 값은 $\arctan$ 함수를 사용해 구할 수 있다.

$$\theta_{roll} = atan2(2(wz + xy), 1 - 2(z^2 + x^2))$$

피치 회전에 대한 삼각함수를 만들어주는 $wx - yz$ 값은 다음과 같이 전개된다.

$$
\begin{matrix}
wx - yz &=& \sin\frac{\theta_{pitch}}{2} \cdot \cos\frac{\theta_{pitch}}{2} \\
&=& \frac{1}{2}\sin\theta_{pitch} \\
\end{matrix}
$$

$\sin$ 함수의 배각 공식을 사용해 간략화 한다.

따라서 피치 회전각은 $\arcsin$ 함수를 사용해 구할 수 있다.

$$\theta_{pitch} = asin(2(wx - yz))$$

이때 주의할 점은 $\arcsin$ 함수의 정의역은 $|-1, 1|$ 범위로 제한되어 있으므로 $wx - yz$ 값이 $|-0.5, 0.5|$ 범위를 벗어나지 않는지 확인하고 벗어나는 경우에는 범위 내 가장 가까운 값으로 설정해야 한다.

요 회전은 롤 회전과 유사한 방식으로 요 회전의 $\tan$ 함수 값을 구한 후 $\arctan$ 함수를 사용한다.

$$\theta_{yaw} = atan2(2(wy + xz), 1 - 2(x^2 + y^2))$$

# 51.3. 사원수에서 회전 변환행렬로의 변환
사원수에서 회전 변환행렬로 변환하는 식을 계산해보자.        
***회전 변환행렬은 로컬 축으로 구성***되어 있기 때문에 사원수를 사용해 회전된 세 로컬 축의 값을 구하면 쉽게 해결할 수 있다.       
[식 14-2](#식-14-2)를 활용해 사원수로 로컬축을 회전한 결과를 계산한다.

사원수를 구성하는 네 요소를 $x, y, z, w$라고 할 때 $\vec{r}$의 값은 $(x, y, z)$이 되고 여기에 회전시킬 벡터 값을 $\vec{v}$에 대입하면 외적 식으로 회전된 벡터 값을 계산할 수 있다.      
먼저 회전할 벡터는 $x$축 기저벡터 $(1, 0, 0)$이다.      
이를 계산한 결과는 사원수에 의해 회전된 $x$ 로컬 축을 의미한다.

$$
\begin{matrix}
x_{local} &=& (1, 0, 0) + w(0, 2z, -2y) + (x, y, z) \times (0, 2z, -2y) \\
&=& (1, 2zw, -2yw) + (-2y^2 - 2z^2, 2xy, 2xz) \\
&=& (1 - 2(y^2 + z^2), 2(xy + zw), 2(xz - yw)) \\
\end{matrix}
$$

마찬가지로 동일한 사원수에 벡터 $(0, 1, 0), (0, 0, 1)$을 곱하면 각각 다음 식이 나온다.

$$y_{local} = (2(xy - zw), 1 - 2(x^2 + z^2), 2(yz + xw))$$

$$z_{local} = (2(xz + yw), 2(yz - xw), 1 - 2(x^2 + y^2))$$

모든 로컬 축을 구했다면, 이들을 꽂아 넣으면 회전 변환행렬을 만들 수 있다.

###### 식 14-4

$$
\begin{bmatrix}
1-2(y^2 + z^2) & 2(xy - zw) & 2(xz + yw) \\
2(xy + zw) & 1-2(x^2 + z^2) & 2(yz - xw) \\
2(xz - yw) & 2(yz + xw) & 1-2(x^2 + y^2) \\
\end{bmatrix}
$$

# 51.4. 회전 변환행렬에서 사원수로의 변환
### 선요약

> 트레이스(Trace):
> - 정방행렬의 대각 성분을 모두 더한 값
> - 트레이스를 활용해 행렬의 요소를 조합해서 사원수를 구성하는 $x, y, z, w$ 값을 개별로 구할 수 있다
> - 트레이스를 활용하는 방식으로 사원수를 구할 때 트레이스 값이 -1보다 작거나 같으면 제곱근을 구하는 값이 0보다 작거나 같아져 $w$를 구하는 데 필요한 $r$의 해가 존재하지 않는다       
> 이러한 경우, $w$가 아닌 다른 요소부터 계산한 후에 이로부터 다른 성분을 구하도록 계산 방법을 우회해야 한다

* * *

[본문](README-ORIGIN4.md#512-사원수에서-오일러-각으로의-변환)

# 52. 사원수의 보간
### 선요약

> 사원수는 로드리게스 회전과 동일한 축-각 방식을 사용해 3차원 공간의 회전을 표현한다
> 
> 사원수를 사용하는 경우의 장점:
> - 오일러 각과 쉽게 변환이 가능하며 회전행렬 제작이 용이하다
> - 임의의 축에 대한 회전 표현이 가능하기 때문에 짐벌락 현상을 방지할 수 있다
> - 임의의 축에 대한 회전 보간 값을 구할 수 있다
> - 4개의 숫자로 회전을 표현하기 때문에 저장 공간을 효율적으로 쓸 수 있다
> 
> 다른 회전 방식과 비교한 사원수의 장단점:
> 
> ||오일러 각|행렬|사원수|
> |---|---|---|---|
> |저장 공간|가장 작다. 저장 공간의 수는 3|크다. 저장 공간의 수는 9|작다. 저장 공간의 수는 4|
> |짐벌락 현상|발생|발생하지 않음|발생하지 않음|
> |회전 보간|한 기저 축에 대해서만 가능|불가능|임의의 축에 가능|
> |직관성|직관적이다.|직관적이지 않다.|직관적이지 않다.|
> 
> 사원수의 회전 보간:
> - 사원수를 4차원 공간의 벡터로 생각하고, 두 사원수가 만들어내는 4차원 공간에서의 평면에서 주어진 비율 $t$에 대응하는 사원수는 두 사원수의 위치를 선형 보간한 지점이 된다
> - 두 사원수가 만든 평면에서 $\frac{1}{3}$만큼 보간된 사원수를 구하는 식은 다음과 같다       
> $q(t) = (1 - t) \cdot q_1 + t \cdot q_2$
> - 선형 보간으로 얻어지는 사원수는 크기가 1인 단위 사원수가 아니기 떄문에 해당 사원수를 회전에 사용하려면 정규화 과정을 거쳐야 한다      
> $q' = \frac{q(t)}{|q(t)|}$
> - 선형 보간법은 빠르고 간편하지만, 원의 궤적을 따라 발생하는 회전을 정확히 반영하지는 못한다        
> 좀 더 높은 수준의 결과물을 위해 회전의 움직임을 따르는 중간 사원수를 구하려면 두 사원수가 이루는 각을 $\theta$로 지정하고 주어진 비율 $t$를 사용해 두 각을 각각 $t\theta$와 $(1 - t)\theta$로 나눠야 한다       
> $q' = \alpha \cdot q_1 + \beta \cdot q_2$     
> 이를 구면 선형 보간(Spherical linear interpolation)이라고 하며, 줄여서 슬럽(Slerp)이라 부른다

* * *

[본문](README-ORIGIN4.md#52-사원수의-보간)